# <a name="exceptions"></a><span data-ttu-id="420eb-101">예외</span><span class="sxs-lookup"><span data-stu-id="420eb-101">Exceptions</span></span>

<span data-ttu-id="420eb-102">C#에서 예외 시스템 수준 및 응용 프로그램 수준 모두 처리는 구조적이 고 일정 하며 형식이 안전한 방식을 제공 오류 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-102">Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions.</span></span> <span data-ttu-id="420eb-103">C#의 예외 메커니즘은 매우 비슷한 c + +, 몇 가지 중요 한 차이점을 사용 하 여:</span><span class="sxs-lookup"><span data-stu-id="420eb-103">The exception mechanism in C# is quite similar to that of C++, with a few important differences:</span></span>

*  <span data-ttu-id="420eb-104">C#에서 모든 예외에서 파생 된 클래스 형식의 인스턴스에 의해 표현 합니다 `System.Exception`합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-104">In C#, all exceptions must be represented by an instance of a class type derived from `System.Exception`.</span></span> <span data-ttu-id="420eb-105">C + +에서 예외를 나타내는 모든 형식의 모든 값을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-105">In C++, any value of any type can be used to represent an exception.</span></span>
*  <span data-ttu-id="420eb-106">C#의 경우에 finally 블록 ([try 문](statements.md#the-try-statement)) 일반 실행 및 예외 조건에서 실행 되는 종료 코드를 쓰는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-106">In C#, a finally block ([The try statement](statements.md#the-try-statement)) can be used to write termination code that executes in both normal execution and exceptional conditions.</span></span> <span data-ttu-id="420eb-107">이러한 코드는 c + + 코드를 복제 하지 않고 작성 하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-107">Such code is difficult to write in C++ without duplicating code.</span></span>
*  <span data-ttu-id="420eb-108">C#에서는 시스템 수준 예외 오버플로, 0으로 나누기 및 null 역참조와 같은 예외 클래스 정의 되며 응용 프로그램 수준 오류 조건와 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-108">In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</span></span>

## <a name="causes-of-exceptions"></a><span data-ttu-id="420eb-109">예외의 원인</span><span class="sxs-lookup"><span data-stu-id="420eb-109">Causes of exceptions</span></span>

<span data-ttu-id="420eb-110">두 가지 방법으로 예외가 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-110">Exception can be thrown in two different ways.</span></span>

*  <span data-ttu-id="420eb-111">A `throw` 문 ([throw 문을](statements.md#the-throw-statement)) 즉시 및 무조건 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-111">A `throw` statement ([The throw statement](statements.md#the-throw-statement)) throws an exception immediately and unconditionally.</span></span> <span data-ttu-id="420eb-112">컨트롤에 도달 하지 않습니다. 문 바로 다음의 `throw`합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-112">Control never reaches the statement immediately following the `throw`.</span></span>
*  <span data-ttu-id="420eb-113">통합 문서 작업을 정상적으로 완료 될 수 없는 C# 문 및 식 처리 중 발생 하는 특정 예외 조건을 특정 상황에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-113">Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally.</span></span> <span data-ttu-id="420eb-114">예를 들어 정수 나누기 연산 ([나누기 연산자](expressions.md#division-operator))를 throw 한 `System.DivideByZeroException` 분모가 0 이면 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-114">For example, an integer division operation ([Division operator](expressions.md#division-operator)) throws a `System.DivideByZeroException` if the denominator is zero.</span></span> <span data-ttu-id="420eb-115">참조 [일반적인 예외 클래스](exceptions.md#common-exception-classes) 이 방식으로 발생할 수 있는 다양 한 예외 목록에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-115">See [Common Exception Classes](exceptions.md#common-exception-classes) for a list of the various exceptions that can occur in this way.</span></span>

## <a name="the-systemexception-class"></a><span data-ttu-id="420eb-116">System.Exception 클래스</span><span class="sxs-lookup"><span data-stu-id="420eb-116">The System.Exception class</span></span>

<span data-ttu-id="420eb-117">`System.Exception` 클래스는 모든 예외의 기본 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-117">The `System.Exception` class is the base type of all exceptions.</span></span> <span data-ttu-id="420eb-118">이 클래스에는 모든 예외를 공유 하는 몇 가지 중요 한 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-118">This class has a few notable properties that all exceptions share:</span></span>

*  <span data-ttu-id="420eb-119">`Message` 형식의 읽기 전용 속성인 `string` 읽을 설명은 예외에 대 한 이유를 포함 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-119">`Message` is a read-only property of type `string` that contains a human-readable description of the reason for the exception.</span></span>
*  <span data-ttu-id="420eb-120">`InnerException` 형식의 읽기 전용 속성인 `Exception`합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-120">`InnerException` is a read-only property of type `Exception`.</span></span> <span data-ttu-id="420eb-121">현재 예외를 발생 시킨 예외를 참조 하는 해당 값이 null 이면-즉, 현재 예외를 catch 블록에서 발생 처리는 `InnerException`합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-121">If its value is non-null, it refers to the exception that caused the current exception—that is, the current exception was raised in a catch block handling the `InnerException`.</span></span> <span data-ttu-id="420eb-122">그렇지 않으면 해당 값은 null,이 예외가 다른 예외 원인은 하지 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-122">Otherwise, its value is null, indicating that this exception was not caused by another exception.</span></span> <span data-ttu-id="420eb-123">이 방식으로 함께 연결 하는 예외 개체의 수는 임의의 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-123">The number of exception objects chained together in this manner can be arbitrary.</span></span>

<span data-ttu-id="420eb-124">인스턴스 생성자에 대 한 호출에서 이러한 속성의 값을 지정할 수 있습니다 `System.Exception`합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-124">The value of these properties can be specified in calls to the instance constructor for `System.Exception`.</span></span>

## <a name="how-exceptions-are-handled"></a><span data-ttu-id="420eb-125">예외 처리 방법</span><span class="sxs-lookup"><span data-stu-id="420eb-125">How exceptions are handled</span></span>

<span data-ttu-id="420eb-126">예외를 처리 한 `try` 문 ([try 문](statements.md#the-try-statement)).</span><span class="sxs-lookup"><span data-stu-id="420eb-126">Exceptions are handled by a `try` statement ([The try statement](statements.md#the-try-statement)).</span></span>

<span data-ttu-id="420eb-127">시스템 검색에 대 한 예외가 발생 하는 경우 가장 가까운 `catch` 예외의 런타임 형식에 따른 예외를 처리할 수 있는 절.</span><span class="sxs-lookup"><span data-stu-id="420eb-127">When an exception occurs, the system searches for the nearest `catch` clause that can handle the exception, as determined by the run-time type of the exception.</span></span> <span data-ttu-id="420eb-128">첫째, 현재 메서드가 검색 하는 어휘 적으로 묶는 `try` 문과 try 문 관련된 catch 절의 순서로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-128">First, the current method is searched for a lexically enclosing `try` statement, and the associated catch clauses of the try statement are considered in order.</span></span> <span data-ttu-id="420eb-129">현재 메서드를 호출한 메서드는 어휘 적으로 묶는 검색할 실패할 경우 `try` 현재 메서드에 대 한 호출 지점을 포함 하는 문입니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-129">If that fails, the method that called the current method is searched for a lexically enclosing `try` statement that encloses the point of the call to the current method.</span></span> <span data-ttu-id="420eb-130">이 검색 될 때까지 계속는 `catch` 예외 클래스는 같은 클래스 또는 런타임 throw 되는 예외 형식의 기본 클래스의 이름을 지정 하 여 현재 예외를 처리할 수 있는 절을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-130">This search continues until a `catch` clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown.</span></span> <span data-ttu-id="420eb-131">`catch` 절 예외 클래스를 명명 하지 않는 모든 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-131">A `catch` clause that doesn't name an exception class can handle any exception.</span></span>

<span data-ttu-id="420eb-132">일치 하는 catch 절 발견 되 면 시스템 준비 catch 절의 첫 번째 문으로 제어를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-132">Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause.</span></span> <span data-ttu-id="420eb-133">Catch 절은 실행이 시작 되기 전에 시스템을 처음 실행할를 순서 대로 `finally` 자세한 try 문과 사용 하 여 연결 된 절 중첩 예외를 포착 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-133">Before execution of the catch clause begins, the system first executes, in order, any `finally` clauses that were associated with try statements more nested that than the one that caught the exception.</span></span>

<span data-ttu-id="420eb-134">일치 하는 catch 절이 없으면 두 가지 중 하나가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-134">If no matching catch clause is found, one of two things occurs:</span></span>

*  <span data-ttu-id="420eb-135">정적 생성자에 일치 하는 catch 절에 대 한 검색이 도달 하는 경우 ([정적 생성자](classes.md#static-constructors)) 또는 정적 필드 이니셜라이저는 `System.TypeInitializationException` 정적 생성자의 호출을 트리거한 지점에서 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-135">If the search for a matching catch clause reaches a static constructor ([Static constructors](classes.md#static-constructors)) or static field initializer, then a `System.TypeInitializationException` is thrown at the point that triggered the invocation of the static constructor.</span></span> <span data-ttu-id="420eb-136">내부 예외를 `System.TypeInitializationException` 원래 throw 된 예외를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-136">The inner exception of the `System.TypeInitializationException` contains the exception that was originally thrown.</span></span>
*  <span data-ttu-id="420eb-137">Catch 절을 일치 하는 검색 스레드를 처음 시작 하는 코드에 도달 하면 스레드 실행이 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-137">If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated.</span></span> <span data-ttu-id="420eb-138">이런 종료가 미치는 구현 시 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-138">The impact of such termination is implementation-defined.</span></span>

<span data-ttu-id="420eb-139">소멸자가 실행 하는 동안 발생 하는 예외는 특별 한 언급이 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-139">Exceptions that occur during destructor execution are worth special mention.</span></span> <span data-ttu-id="420eb-140">소멸자가 실행 하는 동안 예외가 발생 하는 경우 해당 예외 잡히지 않는 해당 소멸자가 실행 종료 되 고 (있는 경우) 기본 클래스의 소멸자가 호출 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-140">If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called.</span></span> <span data-ttu-id="420eb-141">기본 클래스가 없는 경우 (의 경우로 `object` 형식) 또는 기본 클래스 소멸자가 되지 않은 경우는 예외는 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-141">If there is no base class (as in the case of the `object` type) or if there is no base class destructor, then the exception is discarded.</span></span>

## <a name="common-exception-classes"></a><span data-ttu-id="420eb-142">일반적인 예외 클래스</span><span class="sxs-lookup"><span data-stu-id="420eb-142">Common Exception Classes</span></span>

<span data-ttu-id="420eb-143">특정 C# 작업에 의해 다음과 같은 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-143">The following exceptions are thrown by certain C# operations.</span></span>

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | <span data-ttu-id="420eb-144">`System.DivideByZeroException`, `System.OverflowException` 등의 산술 연산 중에 발생하는 예외에 대한 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-144">A base class for exceptions that occur during arithmetic operations, such as `System.DivideByZeroException` and `System.OverflowException`.</span></span> | 
| `System.ArrayTypeMismatchException`  | <span data-ttu-id="420eb-145">저장소 배열에 저장 된 요소의 실제 형식이 배열의 실제 형식과 호환 되지 않으므로 실패 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-145">Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</span></span> | 
| `System.DivideByZeroException`       | <span data-ttu-id="420eb-146">정수 값을 0으로 나누려 할 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-146">Thrown when an attempt to divide an integral value by zero occurs.</span></span> | 
| `System.IndexOutOfRangeException`    | <span data-ttu-id="420eb-147">0 보다 작거나 배열의 경계 외부에 있는 인덱스를 통해 배열을 인덱싱하려 하려고 할 때 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-147">Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</span></span> | 
| `System.InvalidCastException`        | <span data-ttu-id="420eb-148">기본 형식 또는 인터페이스에서 파생된 형식으로 변환 하는 명시적 변환을 런타임에 실패 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-148">Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</span></span> | 
| `System.NullReferenceException`      | <span data-ttu-id="420eb-149">경우에 throw를 `null` 참조가 참조 된 개체를 필요로 하는 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-149">Thrown when a `null` reference is used in a way that causes the referenced object to be required.</span></span> | 
| `System.OutOfMemoryException`        | <span data-ttu-id="420eb-150">메모리를 할당 하려고 할 때 throw 됩니다 (통해 `new`)에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-150">Thrown when an attempt to allocate memory (via `new`) fails.</span></span> | 
| `System.OverflowException`           | <span data-ttu-id="420eb-151">`checked` 컨텍스트의 산술 연산이 오버플로될 경우 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-151">Thrown when an arithmetic operation in a `checked` context overflows.</span></span> | 
| `System.StackOverflowException`      | <span data-ttu-id="420eb-152">보류 중인 메서드 호출이 너무 많아서; 실행 스택이 부족할 때 throw 너무 깊거나 재귀 일반적으로 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-152">Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</span></span> | 
| `System.TypeInitializationException` | <span data-ttu-id="420eb-153">정적 생성자 없음 예외를 throw 하는 경우에 throw `catch` 절 catch 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="420eb-153">Thrown when a static constructor throws an exception, and no `catch` clauses exists to catch it.</span></span> | 
