# <a name="expressions"></a>식

식은 연산자와 피연산자의 시퀀스입니다. 이 장에서 구문, 피연산자 및 연산자를 평가 및 식의 의미는 순서를 정의합니다.

## <a name="expression-classifications"></a>식 분류

식은 다음 중 하나로 분류됩니다.

*  값입니다. 모든 값에는 연결된 형식이 있습니다.
*  변수입니다. 모든 변수에는 연결된 형식, 즉 변수의 선언 된 형식이 있습니다.
*  네임스페이스입니다. 이 분류를 사용 하 여 식 왼쪽에만 나타날 수 있습니다는 *member_access* ([멤버 액세스](expressions.md#member-access)). 다른 컨텍스트에서 네임 스페이스로 분류 되는 식 하면 컴파일 타임 오류가 발생 합니다.
*  형식입니다. 이 분류를 사용 하 여 식 왼쪽에만 나타날 수 있습니다는 *member_access* ([멤버 액세스](expressions.md#member-access)), 또는 대 한 피연산자로 합니다 `as` 연산자 ([As 연산자 ](expressions.md#the-as-operator)), `is` 연산자 ([는 연산자가](expressions.md#the-is-operator)), 또는 `typeof` 연산자 ([typeof 연산자](expressions.md#the-typeof-operator)). 다른 컨텍스트에서 형식으로 분류 되는 식 하면 컴파일 타임 오류가 발생 합니다.
*  멤버 조회에서 발생 하는 오버 로드 된 메서드 집합인 메서드 그룹 ([멤버 조회](expressions.md#member-lookup)). 메서드 그룹을 연결 된 인스턴스 식과 연결 된 형식 인수 목록에 있을 수 있습니다. 인스턴스 식의 평가 결과에서 표시 되는 인스턴스가 인스턴스 메서드를 호출 하면 `this` ([이 액세스](expressions.md#this-access)). 메서드 그룹에서 허용 되는 *invocation_expression* ([호출 식](expressions.md#invocation-expressions)), *delegate_creation_expression* ([대리자 생성 식을](expressions.md#delegate-creation-expressions))와 왼쪽에는 연산자 이며 호환 되는 대리자 형식으로 암시적으로 변환할 수 있습니다 ([메서드 그룹 변환](conversions.md#method-group-conversions)). 다른 컨텍스트에서 메서드 그룹으로 분류 되는 식은 컴파일 타임 오류가 발생 합니다.
*  Null 리터럴입니다. 이 분류를 사용 하 여 식은 참조 형식 또는 nullable 형식에 암시적으로 변환할 수 있습니다.
*  익명 함수입니다. 이 분류를 사용 하 여 식은 호환 되는 대리자 형식 또는 식 트리 형식을 암시적으로 변환할 수 있습니다.
*  속성 액세스입니다. 모든 속성 액세스에는 연관 된 형식, 즉 속성의 형식이 있습니다. 또한 속성 액세스는 연결된 된 인스턴스 식이 있을 수 있습니다. 접근자 (합니다 `get` 또는 `set` 블록) 인스턴스의 속성 액세스 호출 되 면 인스턴스 식의 평가 결과가 됩니다 하 여 표시 되는 인스턴스 `this` ([이 액세스](expressions.md#this-access)).
*  이벤트 액세스 합니다. 모든 이벤트 액세스에는 연관 된 형식, 즉 이벤트 형식이 있습니다. 또한 이벤트 액세스 연결된 된 인스턴스 식이 있을 수 있습니다. 왼쪽 피연산자와 이벤트 액세스 나타날 수 있습니다 합니다 `+=` 하 고 `-=` 연산자 ([이벤트 할당](expressions.md#event-assignment)). 다른 컨텍스트에서 이벤트 액세스로 분류 되는 식 하면 컴파일 타임 오류가 발생 합니다.
*  인덱서 액세스 합니다. 모든 인덱서 액세스에는 연관 된 형식, 즉 인덱서의 요소 형식이 있습니다. 또한 인덱서 액세스에 연결 된 인수 목록과 연결된 된 인스턴스 식이 있습니다. 접근자 (합니다 `get` 또는 `set` 블록) 인덱서의 액세스 호출 되 면 인스턴스 식의 평가 결과 나타내는 인스턴스 `this` ([이 액세스](expressions.md#this-access)), 및의 결과 인수 목록의 계산 매개 변수 목록이 호출 됩니다.
*  항목이 없습니다. 식의 반환 형식과 메서드를 호출 하는 경우 이런 `void`합니다. 그대로 아무만의 컨텍스트에서 분류 되는 식에 *statement_expression* ([식 문은](statements.md#expression-statements)).

식의 최종 결과 네임 스페이스, 유형, 메서드 그룹 또는 이벤트 액세스 하지 않습니다. 대신 위에서 설명한 대로 식의 이러한 범주는 특정 컨텍스트에서 허용 되는 중간 구문입니다.

속성 액세스 또는 인덱서 액세스는 항상 다시 분류 값으로 호출을 수행 하 여 합니다 *get 접근자* 또는 *set 접근자*합니다. 특정 접근자는 속성 또는 인덱서 액세스의 컨텍스트에 의해 결정 됩니다: 액세스는 할당 대상일 경우는 *set 접근자* 새 값을 할당 하기 위해 호출 됩니다 ([단순 할당](expressions.md#simple-assignment)) . 그렇지 않은 경우는 *get 접근자* 가 현재 값을 얻기 위해 호출 됩니다 ([식의 값](expressions.md#values-of-expressions)).

### <a name="values-of-expressions"></a>식의 값

대부분의 식을 포함 하는 구문에는 궁극적으로을 나타내는 식이 필요는 ***값***합니다. 이러한 경우에는 실제 식 나타냅니다 네임 스페이스, 형식, 메서드 그룹 또는 아무 것도 컴파일 타임 오류가 발생 합니다. 그러나 식 속성 액세스, 인덱서 액세스, 또는 변수를 표시할 경우 속성, 인덱서 또는 변수 값은 암시적으로 대체 합니다.

*  변수 값은 단순히 현재 변수로 식별 된 저장소 위치에 저장 된 값. 변수는 정적으로 할당 된 간주 해야 합니다 ([한정 된 할당](variables.md#definite-assignment)) 해당 값을 가져올 수 있습니다 하거나 그렇지 않으면 컴파일 타임 오류가 발생 합니다.
*  호출 하 여 가져올 속성 액세스 식의 값을 *get 접근자* 속성입니다. 속성에 없는 경우 *get 접근자*, 컴파일 시간 오류가 발생 합니다. 이 고, 그렇지 함수 멤버 호출 ([컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 수행한 호출의 결과 속성 액세스 식의 값이 됩니다.
*  호출 하 여 가져온 인덱서 액세스 식의 값을 *get 접근자* 인덱서의 합니다. 인덱서가 없으면 *get 접근자*, 컴파일 시간 오류가 발생 합니다. 이 고, 그렇지 함수 멤버 호출 ([컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 인수를 사용 하 여 수행 됩니다 인덱서 액세스 식과 사용 하 여 연결 된 목록 및 호출의 결과 값이 됩니다. 인덱서 액세스 식입니다.

## <a name="static-and-dynamic-binding"></a>정적 및 동적 바인딩

형식 또는 구성 식 (인수, 피연산자, 수신자)의 값에 따라 작업의 의미를 확인 하는 과정은 라고도 ***바인딩***합니다. 예를 들어 메서드 호출의 의미를 사용 하 고 수신자와 인수의 형식에 따라 결정 됩니다. 연산자의 의미는 해당 피연산자의 형식에 따라 결정 됩니다.

C#의 경우이 작업의 의미는 일반적으로 결정 됩니다 컴파일 타임에 구성 식 중 컴파일 타임 형식을 기반으로 합니다. 마찬가지로, 식에 오류가 있으면 오류가 감지 되 고 컴파일러에서 보고 합니다. 이 접근 방식 이라고 ***정적 바인딩***합니다.

그러나 식이 동적 식을 경우 (즉, 형식이 `dynamic`) 형식에 해당 하는 대신에 참여 하는 모든 바인딩을 기반으로 해당 런타임 형식 (즉, 런타임에 나타냅니다 개체의 실제 형식)를 나타냅니다 컴파일 시간입니다. 따라서 이러한 작업의 바인딩은 작업이 프로그램을 실행 하는 동안 실행할 수 있는 시간까지 지연 됩니다. 이 이라고 ***동적 바인딩***합니다.

작업을 동적으로 바인딩하면 컴파일러에서 거의 또는 전혀 검사를 수행 됩니다. 대신 런타임에 바인딩이 실패 한 경우 오류는 런타임 시 예외로 보고 됩니다.

C#에서 다음 작업을는 바인딩에 적용 됩니다.

*  멤버 액세스: `e.M`
*  메서드 호출: `e.M(e1, ..., eN)`
*  대리자 호출:`e(e1, ..., eN)`
*  요소 액세스: `e[e1, ..., eN]`
*  개체 만들기: `new C(e1, ..., eN)`
*  오버 로드 된 단항 연산자: `+`, `-`를 `!`를 `~`를 `++`를 `--`, `true`, `false`
*  이항 연산자를 오버 로드 된: `+`, `-`, `*`, `/`, `%`를 `&`, `&&`를 `|`, `||`를 `??`, `^`, `<<` , `>>`, `==`,`!=`, `>`, `<`, `>=`, `<=`
*  할당 연산자: `=`, `+=`, `-=`, `*=`, `/=`를 `%=`, `&=`를 `|=`를 `^=`, `<<=`, `>>=`
*  암시적 변환과 명시적 변환

동적 식을 없는 관련 된 경우 C# 기본값은 정적 바인딩 구성 식의 컴파일 시간 형식 선택 프로세스에서 사용 되는 의미입니다. 그러나 위에 나열 된 작업에 구성 식 중 하나는 동적 식인 경우 작업 대신 동적으로 바인딩됩니다.

### <a name="binding-time"></a>바인딩 시간

런타임 시 동적 바인딩을 수행 하는 반면 정적 바인딩 작업 컴파일 타임에 발생 합니다. 다음 섹션에서는 용어 ***바인딩 시간*** 컴파일 타임 또는 런타임 바인딩 위치를 사용 하는 경우에 따라을 나타냅니다.

다음 예제에서는 정적 및 동적 바인딩 및 바인딩 시간 개념을 보여 줍니다.
```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
```

처음 두 호출 정적으로 바인딩된: 오버 로드 `Console.WriteLine` 해당 인수의 컴파일 타임 형식에 따라 선택 됩니다. 따라서 바인딩-시간은 컴파일 시간입니다.

세 번째 호출을 동적으로 바인딩됩니다: 오버 로드 `Console.WriteLine` 인수의 런타임 형식에 따라 선택 됩니다. 인수는 동적 식 때문에 이런-컴파일 타임 형식은 해당 `dynamic`합니다. 따라서 세 번째 호출에 대 한 바인딩 시간 런타임 됩니다.

### <a name="dynamic-binding"></a>동적 바인딩

C# 프로그램이 상호 작용할 수 있도록 동적 바인딩 목적은 ***동적 개체***, 즉, C#의 일반 규칙을 따르지 않는 개체 형식 시스템. 동적 개체를 다른 형식 시스템을 사용 하 여 다른 프로그래밍 언어의 개체 수 또는 프로그래밍 방식으로 다른 작업에 대 한 자신의 바인딩 의미 체계를 구현 하는 설치 된 개체가 있을 수 있습니다.

동적 개체는 해당 의미 체계를 구현 하는 메커니즘은 정의 된 구현입니다. 지정 된 인터페이스-다시 정의 된 구현-신호를 보내는 데 C# 런타임 특별 한 의미를가지고 있다고 동적 개체로 구현 됩니다. 따라서 동적 개체에 대 한 작업에 동적으로 바운드 때마다 자신의 바인딩 의미 체계 보다는이 문서에 지정 된 대로 C#의 인수입니다.

동적 바인딩의 목적은 동적 개체를 사용 하 여 상호 운용 있도록 이지만, C# 동적 바인딩할 수 모든 개체에 있는지 동적 여부. 이렇게 하면 동적 개체의 원활 하 게 통합 하는 작업의 결과 하지 자체 동적 개체 일 수 있지만 컴파일 타임에 프로그래머에 게 알 수 없는 형식으로 계속 되어 있습니다. 도 동적 바인딩 관련된 없는 개체에 동적 개체가 있는 경우에 오류가 리플렉션 기반 코드를 제거할 수 있습니다.

다음 섹션에서는 정확 하 게 동적 바인딩이 적용 될 때, 어떤 컴파일 타임 검사-모든-적용 되는 경우 및 컴파일 시간 식 및 결과 분류 어떤 언어로 각 구문에 대해 설명 합니다.

### <a name="types-of-constituent-expressions"></a>구성 요소 식의 형식

작업을 정적으로 바인딩하면 (예:: 수신기에 및 인수, 인덱스 또는 피연산자) 구성 요소 식의 형식은 해당 식의 컴파일 시간 형식으로 항상 간주 됩니다.

작업을 동적으로 바인딩하면 구성 식의 컴파일 시간 형식에 따라 다양 한 방식에서 구성 식의 형식이 결정 됩니다.

*  컴파일 타임 형식 구성 식 `dynamic` 런타임에 식이 계산 되는 실제 값의 형식이 것으로 간주 됩니다
*  컴파일 타임 형식은 해당 형식 매개 변수는 구성 요소 식 형식이 런타임 시 형식 매개 변수에 바인딩되는 것으로 간주 됩니다.
*  그렇지 않으면 구성 식은 컴파일 시간 형식으로 간주 됩니다.

## <a name="operators"></a>연산자

식에서 생성 됩니다 ***피연산자*** 하 고 ***연산자***합니다. 식의 연산자는 피연산자에 적용할 연산을 나타냅니다. 연산자의 예로 `+`, `-`, `*`, `/` 및 `new`가 있습니다. 피연산자의 예로는 리터럴, 필드, 지역 변수 및 식이 있습니다.

연산자는 다음과 같은 세 가지 종류가 있습니다.

*  단항 연산자. 단항 연산자는 피연산자 하나를 사용 하 고 두 접두사 표기법을 사용 (같은 `--x`) 또는 후 위 표기법 (같은 `x++`).
*  이항 연산자입니다. 이항 연산자의 피연산자 2 개 및 중 위 표기법을 사용 하 여 모든 (같은 `x + y`).
*  삼진 연산자입니다. 삼항 연산자만 `?:`에 있으면 세 개의 피연산자를 사용 하 고 사용 하 여 위 표기법 (`c ? x : y`).

식에서 연산자의 계산 순서에 의해 결정 됩니다 합니다 ***우선 순위*** 하 고 ***결합성*** 연산자 ([연산자 우선순위 및 결합성](expressions.md#operator-precedence-and-associativity)) .

식의 피연산자는 왼쪽에서 오른쪽으로 계산 됩니다. 예를 들어 `F(i) + G(i++) * H(i)`, 메서드 `F` 의 이전 값을 사용 하 여 호출 됩니다 `i`, then 메서드 `G` 의 이전 값을 사용 하 여 호출 됩니다 `i`, 및 마지막으로 메서드 `H` 의새값을사용하여라고`i`. 연산자 우선 순위를 별도로 관련이 없는입니다.

특정 연산자 수 ***오버 로드 된***합니다. 사용자 정의 연산자 구현 하나 있는 작업에 대 한 지정을 허용 하는 연산자 오버 로드 또는 두 피연산자 모두 사용자 정의 클래스 또는 구조체 형식 ([연산자 오버 로드](expressions.md#operator-overloading)).

### <a name="operator-precedence-and-associativity"></a>연산자 우선 순위 및 결합성

식에 여러 연산자가 포함되어 있으면 연산자의 ***우선 순위***에 따라 개별 연산자가 계산되는 순서가 제어됩니다. 예를 들어 식 `x + y * z` 로 평가 됩니다 `x + (y * z)` 때문에 `*` 연산자 보다 우선 순위가 더 높은 이진 `+` 연산자입니다. 연산자의 우선 순위는 해당 연결 된 문법 프로덕션의 정의에서 설정 됩니다. 예를 들어를 *additive_expression* 의 시퀀스로 구성 됩니다 *multiplicative_expression*s 구분 `+` 또는 `-` 연산자에 게는 `+` 및 `-` 연산자 보다 우선 순위가 낮은 합니다 `*`를 `/`, 및 `%` 연산자입니다.

다음 표에서 순위가 가장 높은 우선 순위에 따라에서 모든 연산자를 보여 줍니다.

| __섹션__                                                                                   | __범주__                | __연산자__ | 
|-----------------------------------------------------------------------------------------------|-----------------------------|---------------|
| [기본 식](expressions.md#primary-expressions)                                     | 기본 연산자                     | `x.y`  `f(x)`  `a[x]`  `x++`  `x--`  `new`  `typeof`  `default`  `checked`  `unchecked`  `delegate` | 
| [단항 연산자](expressions.md#unary-operators)                                             | 단항                       | `+`  `-`  `!`  `~`  `++x`  `--x`  `(T)x` | 
| [산술 연산자](expressions.md#arithmetic-operators)                                   | 곱하기              | `*`  `/`  `%` | 
| [산술 연산자](expressions.md#arithmetic-operators)                                   | 더하기                    | `+`  `-`      | 
| [시프트 연산자](expressions.md#shift-operators)                                             | 시프트                       | `<<`  `>>`    | 
| [관계형 및 형식 테스트 연산자](expressions.md#relational-and-type-testing-operators) | 관계형 및 형식 테스트 | `<`  `>`  `<=`  `>=`  `is`  `as` | 
| [관계형 및 형식 테스트 연산자](expressions.md#relational-and-type-testing-operators) | 같음                    | `==`  `!=`    | 
| [논리 연산자](expressions.md#logical-operators)                                         | 논리적 AND                 | `&`           | 
| [논리 연산자](expressions.md#logical-operators)                                         | 논리 XOR                 | `^`           | 
| [논리 연산자](expressions.md#logical-operators)                                         | 논리적 OR                  | <code>&#124;</code>           |
| [조건부 논리 연산자](expressions.md#conditional-logical-operators)                 | 조건부 AND             | `&&`          | 
| [조건부 논리 연산자](expressions.md#conditional-logical-operators)                 | 조건부 OR              | <code>&#124;&#124;</code>          | 
| [Null 결합 연산자](expressions.md#the-null-coalescing-operator)                   | Null 결합             | `??`          | 
| [조건 연산자](expressions.md#conditional-operator)                                   | 조건                 | `?:`          | 
| [대입 연산자](expressions.md#assignment-operators), [익명 함수 식](expressions.md#anonymous-function-expressions)  | 할당 및 람다 식 | `=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `^=`  <code>&#124;=</code>  `=>` | 

피연산자 간에 두 연산자의 우선 순위가 같은 경우 연산자의 결합성 순서를 제어 합니다 작업이 수행 됩니다.

*  모든 이항 연산자는 대입 연산자 및 null 병합 연산자를 제외 하 고 ***왼쪽 결합성***에 작업을 수행 왼쪽에서 오른쪽으로 의미 합니다. 예를 들어, `x + y + z`는 `(x + y) + z`로 계산됩니다.
*  대입 연산자, null 병합 연산자 및 조건부 연산자 (`?:`)은 ***오른쪽 결합성***, 즉 연산이 오른쪽에서 왼쪽으로 수행 됩니다. 예를 들어, `x = y = z`는 `x = (y = z)`로 계산됩니다.

우선 순위 및 결합성은 괄호를 사용하여 제어할 수 있습니다. 예를 들어 `x + y * z`는 먼저 `y`와 `z`를 곱한 다음 그 결과를 `x`와 더하지만 `(x + y) * z`는 먼저 `x`와 `y`를 더한 다음 그 결과에 `z`를 곱합니다.

### <a name="operator-overloading"></a>연산자 오버 로드

모든 단항 및 이항 연산자 구현을 자동으로 모든 식에서 사용할 수 있는 미리 정의 합니다. 미리 정의 된 구현 하는 것 외에도 구현을 사용자 정의 포함 하 여 도입 수 `operator` 클래스 및 구조체에서 선언 ([연산자](classes.md#operators)). 사용자 정의 연산자 구현 보다 항상 우선 미리 정의 된 연산자 구현: 구현할 필요 없이 해당 사용자 정의 연산자가 있는 경우 미리 정의 된 연산자 구현을 고려해 야 에설명된대로[ 단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution) 하 고 [이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)합니다.

합니다 ***오버 로드할 수 있는 단항 연산자*** 됩니다.
```csharp
+   -   !   ~   ++   --   true   false
```

하지만 `true` 하 고 `false` 식에 명시적으로 사용 되지 않습니다 (않으며의 우선 순위 표에 포함 되지 않습니다 [연산자 우선순위 및 결합성](expressions.md#operator-precedence-and-associativity)), 이기 때문에 연산자 간주 되므로 여러 식 컨텍스트에서 호출: 부울 식 ([부울 식](expressions.md#boolean-expressions)) 및 조건부 포함 하는 식 ([조건부 연산자](expressions.md#conditional-operator)), 및 조건부 논리 연산자 ([조건부 논리 연산자](expressions.md#conditional-logical-operators)).

합니다 ***이항 연산자를 오버 로드할 수 있는*** 됩니다.
```csharp
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
```

위에 나열 된 연산자만 오버 로드 될 수 있습니다. 멤버 액세스, 메서드 호출 오버 로드할 수는 특히 또는 `=`, `&&`, `||`, `??`를 `?:`를 `=>`, `checked`를 `unchecked`, `new`, `typeof`, `default`하십시오 `as`, 및 `is` 연산자.

이항 연산자가 오버로드되면 해당 대입 연산자도 암시적으로 오버로드됩니다. 예를 들어, 연산자 오버 로드 `*` 연산자를 오버 이기도 `*=`합니다. 이에서 더 자세히 설명 [복합 할당](expressions.md#compound-assignment)합니다. 대입 연산자 (`=`) 오버 로드할 수 없습니다. 변수에 값 단순한 비트 복사를 수행 하는 항상 할당 합니다.

와 같은 작업을 캐스팅할 `(T)x`, 사용자 정의 변환 함으로써 오버 로드 됩니다 ([사용자 정의 변환은](conversions.md#user-defined-conversions)).

요소와 같은 액세스 `a[x]`를 오버 로드할 수 있는 운영자 간주 되지 않습니다. 인덱서를 통해 사용자 정의 인덱싱이 지원 되는 대신 ([인덱서](classes.md#indexers)).

식에서 연산자 연산자 표기법을 사용 하 여 참조 하는 및 선언에서 연산자 기능적 표기법을 사용 하 여 참조 됩니다. 다음 표에서 연산자와 단항 및 이항 연산자에 대 한 기능적 표기법의 관계를 보여 줍니다. 첫 번째 항목에서 *op* 모든 오버 로드할 수 있는 단항 전위 연산자를 나타냅니다. 두 번째 항목에서 *op* 단항 후 위 나타냅니다 `++` 고 `--` 연산자. 세 번째 항목에서 *op* 오버 로드할 수 있는 모든 이항 연산자를 나타냅니다.


| __연산자 표기법__ | __기능적 표기법__ |
|-----------------------|-------------------------|
| `op x`                | `operator op(x)`        | 
| `x op`                | `operator op(x)`        | 
| `x op y`              | `operator op(x,y)`      | 

항상 사용자 정의 연산자 선언에 연산자 선언을 포함 하는 클래스 또는 구조체 형식의 매개 변수 중 하나 이상이 필요 합니다. 따라서 수 없으면 사용자 정의 연산자는 미리 정의 된 연산자와 동일한 시그니처가 있어야 합니다.

사용자 정의 연산자 선언에는 구문, 우선 순위 또는 연산자의 결합성 수정할 수 없습니다. 예를 들어 합니다 `/` 연산자는 이항 연산자가 항상이 수준의 우선 순위에 지정 된 항상 [연산자 우선순위 및 결합성](expressions.md#operator-precedence-and-associativity), 이며 항상 왼쪽 결합성 합니다.

계산이 든 수행 하는 사용자 정의 연산자에 대 한 가능한 상태인 직관적으로 예상 되는 것과 다른 결과 생성 하는 구현 해서는 안 됩니다. 예를 들어 구현을 `operator ==` 같음에 대 한 두 피연산자를 비교 하 고 적절 한 반환 해야 `bool` 결과입니다.

개별 연산자에 대 한 설명은 [기본 식](expressions.md#primary-expressions) 를 통해 [조건부 논리 연산자](expressions.md#conditional-logical-operators) 미리 정의 된 연산자 및 적용 되는 추가 규칙의 구현을 지정 합니다. 각 연산자입니다. 설명을 확인 사용 조건의 ***단항 연산자 오버 로드 확인***, ***이항 연산자 오버 로드 확인에***, 및 ***숫자 승격이***정의 다음 섹션에서 찾을 수 있습니다.

### <a name="unary-operator-overload-resolution"></a>단항 연산자 오버 로드 확인

폼의 작업 `op x` 또는 `x op`여기서 `op` 오버 로드할 수 있는 단항 연산자는 및 `x` 식 형식입니다 `X`, 다음과 같이 처리 됩니다.

*  제공한 후보 사용자 정의 연산자 집합 `X` 작업용 `operator op(x)` 규칙을 사용 하 여 결정 됩니다 [후보 사용자 정의 연산자](expressions.md#candidate-user-defined-operators)합니다.
*  사용자 정의 연산자 후보 집합이 비어 있지 않은 경우 작업에 대 한 후보 연산자 집합이 됩니다. 그렇지 않으면 미리 정의 된 단항 `operator op` 구현에서는 해당 리프트 된 폼을 포함 하 여 작업에 대 한 후보 연산자의 집합이 됩니다. 연산자의 설명에 지정된 된 운영자의 미리 정의 된 구현 된 ([기본 식](expressions.md#primary-expressions) 하 고 [단항 연산자](expressions.md#unary-operators)).
*  오버 로드 확인 규칙 [오버 로드 확인](expressions.md#overload-resolution) 인수 목록에 대해 최상의 연산자를 선택 후보 연산자 집합에 적용 됩니다 `(x)`, 하며이 연산자가 오버 로드 하면 됩니다. 확인 프로세스입니다. 오버 로드 확인을 최상의 single 연산자를 선택 하지 못하면 바인딩 시간 오류가 발생 합니다.

### <a name="binary-operator-overload-resolution"></a>이항 연산자 오버 로드 확인

폼의 작업 `x op y`, 여기서 `op` 를 오버 로드할 수 있는 이항 연산자는 `x` 형식의 식 `X`, 및 `y` 형식의 식 `Y`, 다음과 같이 처리 됩니다:

*  제공한 후보 사용자 정의 연산자 집합 `X` 하 고 `Y` 작업용 `operator op(x,y)` 결정 됩니다. 집합은 구성에서 제공 하는 후보 연산자의 합집합 `X` 및에서 제공 하는 후보 연산자 `Y`, 각각의 규칙을 사용 하 여 결정 [후보 사용자 정의 연산자](expressions.md#candidate-user-defined-operators)합니다. 하는 경우 `X` 및 `Y` 동일한 형식 이거나 `X` 및 `Y` 공유 후보 연산자 결합된 된 집합에서 한 번만 발생한 다음 일반적인 기본 형식에서 파생 됩니다.
*  사용자 정의 연산자 후보 집합이 비어 있지 않은 경우 작업에 대 한 후보 연산자 집합이 됩니다. 그렇지 않으면 미리 정의 된 이진 `operator op` 구현에서는 해당 리프트 된 폼을 포함 하 여 작업에 대 한 후보 연산자의 집합이 됩니다. 연산자의 설명에 지정된 된 운영자의 미리 정의 된 구현 된 ([산술 연산자](expressions.md#arithmetic-operators) 를 통해 [조건부 논리 연산자](expressions.md#conditional-logical-operators)). 미리 정의 된 열거형 및 대리자 연산자에 대 한 것으로 간주 하는 유일한 연산자는 피연산자 중 하나의 바인딩 시간 형식인 열거형 또는 대리자 형식에 의해 정의 합니다.
*  오버 로드 확인 규칙 [오버 로드 확인](expressions.md#overload-resolution) 인수 목록에 대해 최상의 연산자를 선택 후보 연산자 집합에 적용 됩니다 `(x,y)`, 하며이 연산자가 오버 로드 하면 됩니다. 확인 프로세스입니다. 오버 로드 확인을 최상의 single 연산자를 선택 하지 못하면 바인딩 시간 오류가 발생 합니다.

### <a name="candidate-user-defined-operators"></a>후보 사용자 정의 연산자

지정 된 형식 `T` 및 작업 `operator op(A)`, 여기서 `op` 는 오버 로드할 수 있는 연산자 및 `A` 후보 집합이 인수 목록에서 제공 하는 사용자 정의 연산자는 `T` 에 대 한 `operator op(A)` 결정 됩니다 다음과 같이 합니다.

*  형식을 확인할 `T0`합니다. 하는 경우 `T` nullable 형식인 `T0` 해당 내부 형식이, 그렇지 않으면 `T0` 값과 같음 `T`합니다.
*  모든 `operator op` 의 선언 `T0` 및 하나 이상의 연산자를 적용할 수 있는 경우 이러한 연산자의 형태를 리프트 모든 ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)) 인수 목록 `A`, 다음 집합 후보 연산자에서 이러한 모든 적용 가능한 연산자 이루어져 `T0`합니다.
*  그렇지 않은 경우, `T0` 는 `object`, 후보 연산자 집합이 비어 있습니다.
*  후보 연산자 집합에서 제공 하는 고, 그렇지 `T0` 직접 기본 클래스에서 제공 하는 후보 연산자 집합이 `T0`, 또는의 유효 기본 클래스 `T0` 경우 `T0` 형식 매개 변수입니다.

### <a name="numeric-promotions"></a>숫자 프로 모션

숫자 승격이 자동으로 미리 정의 된 단항 및 이항 숫자 연산자의 피연산자는 특정 암시적 변환을 수행 이루어져 있습니다. 숫자 승격이 고유 메커니즘을 아니라 대신 미리 정의 된 연산자를 오버 로드 확인을 적용 하는 효과입니다. 숫자 승격이 특히 영향을 주지 않습니다 사용자 정의 연산자의 계산 되지만 비슷한 효과 나타낼 하도록 사용자 정의 연산자를 구현할 수 있습니다.

숫자 승격이의 예를 들어, 이진 파일의 미리 정의 된 구현 고려 `*` 연산자:

```csharp
int operator *(int x, int y);
uint operator *(uint x, uint y);
long operator *(long x, long y);
ulong operator *(ulong x, ulong y);
float operator *(float x, float y);
double operator *(double x, double y);
decimal operator *(decimal x, decimal y);
```

때 오버 로드 해결 규칙 ([오버 로드 확인](expressions.md#overload-resolution))이이 집합에 적용 됩니다 효과 연산자의 피연산자 형식에서 암시적 변환이 있는 연산자의 첫 번째 선택 합니다. 작업에 대 한 예를 들어 `b * s`, 여기서 `b` 는 `byte` 및 `s` 는 `short`, 해상도 오버 로드 `operator *(int,int)` 최상의 연산자로. 따라서 결과 `b` 및 `s` 변환할 `int`, 및 결과의 형식은 `int`합니다. 마찬가지로, 작업에 대 한 `i * d`, 여기서 `i` 는 `int` 및 `d` 는 `double`, 해상도 오버 로드 `operator *(double,double)` 최상의 연산자로 합니다.

#### <a name="unary-numeric-promotions"></a>단항 숫자 프로 모션

미리 정의 된 피연산자에 대 한 단항 숫자 승격이 발생 `+`, `-`, 및 `~` 단항 연산자입니다. 단항 숫자 승격이 형식의 피연산자를 변환 만으로 구성 됩니다 `sbyte`, `byte`를 `short`를 `ushort`, 또는 `char` 형식으로 `int`입니다. 단항에 대 한 뿐만 `-` 연산자를 단항 숫자 승격이 형식의 피연산자를 변환 `uint` 형식으로 `long`합니다.

#### <a name="binary-numeric-promotions"></a>이진 숫자 프로 모션

미리 정의 된 피연산자에 대 한 이진 숫자 승격이 발생 `+`, `-`, `*`, `/`, `%`를 `&`, `|`를 `^`를 `==`, `!=`, `>`, `<`를 `>=`, 및 `<=` 이항 연산자입니다. 이진 숫자 승격이 비 관계형 연산자의 경우 작업의 결과 형식은 또한 되는 공용 형식으로 두 피연산자를 암시적으로 변환 합니다. 여기에 표시 되는 순서에서 다음 규칙을 적용 하는 이진 숫자 승격이 구성 됩니다.

*  피연산자 중 하나가 형식인 경우 `decimal`, 다른 피연산자는 형식으로 변환 됩니다 `decimal`, 또는 바인딩 시간 오류가 발생 하는 경우 다른 피연산자가 형식의 `float` 또는 `double`.
*  피연산자 중 하나가 형식인 경우 그러지 `double`, 다른 피연산자는 형식으로 변환 됩니다 `double`합니다.
*  피연산자 중 하나가 형식인 경우 그러지 `float`, 다른 피연산자는 형식으로 변환 됩니다 `float`합니다.
*  피연산자 중 하나가 형식인 경우 그러지 `ulong`, 다른 피연산자는 형식으로 변환 됩니다 `ulong`, 바인딩 시간 오류가 발생 하는 경우 다른 피연산자는 형식 또는 `sbyte`, `short`를 `int`, 또는 `long`합니다.
*  피연산자 중 하나가 형식인 경우 그러지 `long`, 다른 피연산자는 형식으로 변환 됩니다 `long`합니다.
*  피연산자 중 하나가 형식인 경우 그러지 `uint` 이 고 다른 피연산자가 형식의 `sbyte`, `short`, 또는 `int`, 두 피연산자는 형식으로 변환 됩니다 `long`합니다.
*  피연산자 중 하나가 형식인 경우 그러지 `uint`, 다른 피연산자는 형식으로 변환 됩니다 `uint`합니다.
*  그렇지 않은 경우 두 피연산자는 형식으로 변환할 `int`합니다.

첫 번째 규칙을 혼합 하는 작업을 허용 하지 않습니다는 참고 합니다 `decimal` 유형과 합니다 `double` 및 `float` 형식입니다. 간의 암시적 변환은 없습니다 한다는 사실에서 규칙을 따릅니다 합니다 `decimal` 형식 및 `double` 및 `float` 형식입니다.

형식의 피연산자에 대 한 수 있다는 것을 참고 `ulong` 경우 다른 피연산자가 부호 있는 정수 계열 형식입니다. 정수 계열 형식이 존재 하지 않습니다 하는 이유는 전체 범위를 나타낼 수 있습니다 `ulong` 부호 있는 정수 계열 형식 뿐만 아니라 합니다.

위의 경우 모두, 캐스트 식은 다른 피연산자와 호환 되는 형식에 하나의 피연산자를 명시적으로 변환할 수 있습니다.

예제
```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
```
바인딩 시간 오류 때문에 발생 한 `decimal` 곱할 수 없습니다는 `double`합니다. 두 번째 피연산자를 명시적으로 변환 하 여 오류가 해결 될 `decimal`다음과 같이 합니다.

```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (decimal)(1.0 + percent / 100.0);
}
```

### <a name="lifted-operators"></a>리프트 된 연산자

***연산자 리프트*** 도 이러한 형식의 null 허용 형식으로 사용할 nullable이 아닌 값 형식에서 작동 하는 미리 정의 된 및 사용자 정의 연산자를 허용 합니다. 리프트 된 연산자는 다음에 설명 된 대로 특정 요구 사항을 충족 하는 미리 정의 된 및 사용자 정의 연산자에서 구성 됩니다.

*   단항 연산자

    ```csharp
    +  ++  -  --  !  ~
    ```

    운영자의 리프트 된 형태는 피연산자와 결과 형식이 모두 nullable이 아닌 값 형식인 경우 존재 합니다. 리프트는 폼이 단일을 추가 하 여 생성 된 `?` 피연산자와 결과 형식에는 한정자입니다. 리프트 된 연산자는 피연산자가 null 이면 null 값을 생성 합니다. 이 고, 그렇지 리프트 된 연산자는 피연산자의 래핑을 해제 기본 연산자를 적용 되며 결과 래핑합니다.

*   이항 연산자

    ```csharp
    +  -  *  /  %  &  |  ^  <<  >>
    ```

    운영자의 리프트 된 형태는 피연산자와 결과 형식이 모든 비 nullable 값 형식인 경우 존재 합니다. 리프트는 폼이 단일을 추가 하 여 생성 된 `?` 각 피연산자와 결과 형식에는 한정자입니다. 리프트 된 연산자를 null 값을 생성 하는 경우 하나 또는 두 피연산자가 null 인 (되는 예외를 `&` 하 고 `|` 연산자는 `bool?` 에 설명 된 대로 입력 [부울 논리 연산자](expressions.md#boolean-logical-operators)). 이 고, 그렇지 리프트 된 연산자는 피연산자의 래핑을 해제 기본 연산자에 적용 되며 결과 래핑합니다.

*   같음 연산자

    ```csharp
    ==  !=
    ```

    리프트 된 연산자의 형태가 피연산자 형식이 nullable이 아닌 값 형식 및 결과 형식이 인지 모두 않으면 `bool`합니다. 리프트는 폼이 단일을 추가 하 여 생성 된 `?` 각 피연산자 형식에는 한정자입니다. 리프트 된 연산자 고려 두 개의 null 값 같음 및 null 값을 null이 아닌 값으로 같지 않은 합니다. 두 피연산자 모두 null이 아닌 경우 리프트 된 연산자 피연산자의 래핑을 해제 하 고 생성 하는 기본 연산자를 적용 합니다 `bool` 결과입니다.

*   관계형 연산자

    ```csharp
    <  >  <=  >=
    ```

    리프트 된 연산자의 형태가 피연산자 형식이 nullable이 아닌 값 형식 및 결과 형식이 인지 모두 않으면 `bool`합니다. 리프트는 폼이 단일을 추가 하 여 생성 된 `?` 각 피연산자 형식에는 한정자입니다. 리프트 된 연산자에 값을 생성 `false` 하나 또는 두 피연산자가 null 인 경우. 리프트 된 연산자는 피연산자의 래핑을 해제 하 고 생성 하는 기본 연산자를 적용 하는 고, 그렇지는 `bool` 결과입니다.

## <a name="member-lookup"></a>멤버 조회

멤버 조회 하는 프로세스 컨텍스트에서 형식 이름의 의미를 여기서 결정 됩니다. 멤버 조회 평가의 일부로 발생할 수 있습니다는 *simple_name* ([단순 이름](expressions.md#simple-names)) 또는 *member_access* ([멤버 액세스](expressions.md#member-access))에 식입니다. 경우는 *simple_name* 또는 *member_access* 으로 발생 합니다 *primary_expression* 의 *invocation_expression* ([ 메서드 호출](expressions.md#method-invocations)), 호출할 멤버 라고 합니다.

구성원은 메서드 또는 이벤트 또는 상수, 필드 또는 속성 중 하나는 대리자 형식의 경우 ([대리자](delegates.md)) 또는 형식 `dynamic` ([동적 형식](types.md#the-dynamic-type)), 멤버 를라고합니다.그런다음*invocable*합니다.

멤버 조회 뿐만 아니라 이름의 멤버 뿐만 아니라 개수 멤버에 형식 매개 변수 및 멤버에 액세스할 수 있는지 여부를 고려 합니다. 멤버 조회에서는 제네릭 메서드 및 중첩 된 제네릭 형식을 형식 매개 변수는 해당 선언에 지정 된 수 있고 다른 모든 멤버 0 형식 매개 변수입니다.

이름의 멤버 조회 `N` 사용 하 여 `K` 형식에서 형식 매개 변수 `T` 다음과 같이 처리 됩니다.

*  먼저, 액세스할 수 있는 멤버를 명명 된 집합이 `N` 결정 됩니다.
    * 하는 경우 `T` 가 형식 매개 변수 집합에 액세스할 수 있는 멤버를 명명 된 집합의 합집합 `N` 각 보조 제약 조건 또는 기본 제약 조건으로 지정 된 형식에서 ([형식 매개 변수 제약 조건](classes.md#type-parameter-constraints))에 대 한 `T`에 액세스할 수 있는 멤버를 명명 된 집합이 함께 `N` 에서 `object`합니다.
    * 이 고, 그렇지는 구성 된 집합 모두 액세스할 수 있습니다 ([멤버 액세스](basic-concepts.md#member-access)) 라는 멤버 `N` 에서 `T`상속 된 멤버 및 명명 된 액세스할 수 있는 멤버를 비롯 한 `N` 에서 `object`합니다. 하는 경우 `T` 생성 된 형식인 멤버 집합에 설명 된 대로 형식 인수를 대체 하 여 가져온 [생성 된 형식의 멤버](classes.md#members-of-constructed-types)합니다. 포함 하는 멤버는 `override` 한정자 집합에서 제외 됩니다.
*  다음으로 `K` 가 0 이면 모든 중첩 된 형식을 형식 매개 변수를 포함 하는 해당 선언에서 제거 됩니다. 경우 `K` 0이 아니면 모든 멤버 수가 서로 다른 형식 매개 변수가 제거 되었습니다. 경우 `K` 0 메서드 형식 매개 변수 제거 되지 않습니다 형식 유추 프로세스 이후 것 ([형식 유추](expressions.md#type-inference)) 형식 인수를 유추 하는 일을 할 수 있습니다.
*  다음을 멤버인 경우 *호출*, 모든 비-*invocable* 멤버 집합에서 제거 됩니다.
*  다음으로, 다른 멤버가 숨겨져 있는 멤버 집합에서 제거 됩니다. 모든 멤버에 대 한 `S.M` 집합에 위치 `S` 는 형식이 멤버 `M` 가 선언 된 다음 규칙이 적용 됩니다.
    * 하는 경우 `M` 의 기본 형식에서 선언 된 모든 멤버는 상수, 필드, 속성, 이벤트 또는 열거형 멤버를이 `S` 집합에서 제거 됩니다.
    * 경우 `M` 형식 선언 이면 모든 아닌 형식을 기본 형식에서 선언 `S` 집합에서 제거 됩니다 모든 형식으로 형식 매개 변수 수가 사용 하 여 선언 하 고 `M` 의 기본 형식에서 선언 된 `S` 제거 됩니다 집합입니다.
    * 하는 경우 `M` 모든 메서드가 아닌 멤버의 기본 형식에서 선언 된 메서드를가 `S` 집합에서 제거 됩니다.
*  다음으로, 클래스 멤버에 의해 숨겨진 된 인터페이스 멤버 집합에서 제거 됩니다. 이 단계에만 적용 하는 경우 `T` 는 형식 매개 변수 및 `T` 이외의 모두는 유효한 기본 클래스에 `object` 설정 비어 있지 않은 효과적인 인터페이스 ([형식 매개 변수 제약 조건](classes.md#type-parameter-constraints)). 모든 멤버에 대 한 `S.M` 집합에 있는 `S` 나타나는 형식인 멤버 `M` 가 선언 된 경우 다음 규칙이 적용 됩니다 `S` 은 클래스 선언 이외의 `object`:
    * 경우 `M` 이면 상수, 필드, 속성, 이벤트, 열거형 멤버 또는 형식 선언 인터페이스 선언에서 선언 된 모든 멤버 집합에서 제거 됩니다.
    * 하는 경우 `M` 인터페이스 선언에서 선언 된 모든 메서드가 아닌 멤버 집합과 동일한 시그니처가 있는 모든 방법에서 제거 되는 메서드이기 `M` 선언 된 인터페이스 선언 집합에서 제거 됩니다.
*  조회 결과 숨겨진된 멤버를 제거, 마지막으로 결정 됩니다.
    * 집합 메서드 없는 단일 구성원으로 구성 된 경우이 멤버는 조회 결과.
    * 이 고, 그렇지 집합 방법만 있으면 메서드의이 그룹은 조회 결과.
    * 이 고, 그렇지 조회 모호 하 고 바인딩 시간 오류가 발생 합니다.

형식 매개 변수 및 인터페이스 이외의 형식에서 멤버 조회 및 단일 상속 된 인터페이스 멤버 조회에 대 한 (상속 체인의 각 인터페이스에 정확히 0 개 이상의 직접 기본 인터페이스)는 조회 규칙의 효과 단순히는 멤버 이름 또는 시그니처가 같은 사용 하 여 기본 멤버 숨기기를 파생 합니다. 이러한 단일 상속 조회는 모호 하지 않습니다. 설명 하는 다중 상속 인터페이스의 멤버 조회에서 발생할 수 있는 모호성 [인터페이스 멤버 액세스](interfaces.md#interface-member-access)합니다.

### <a name="base-types"></a>기본 형식

형식 멤버 조회의 목적을 위해 `T` 기본 형식은 것으로 간주 됩니다.

*  하는 경우 `T` 됩니다 `object`, 다음 `T` 에 기본 형식이 없습니다.
*  경우 `T` 은 *enum_type*, 기본 유형의 `T` 클래스 유형은 `System.Enum`, `System.ValueType`, 및 `object`.
*  경우 `T` 은 *struct_type*, 기본 유형의 `T` 클래스 유형은 `System.ValueType` 및 `object`.
*  경우 `T` 은 *class_type*, 기본 유형의 `T` 의 기본 클래스는 `T`, 클래스 유형을 포함 하 여 `object`.
*  경우 `T` 은 *interface_type*, 기본 유형의 `T` 의 기본 인터페이스는 `T` 클래스 형식과 `object`합니다.
*  경우 `T` 은 *array_type*, 기본 유형의 `T` 클래스 유형은 `System.Array` 및 `object`합니다.
*  경우 `T` 은 *delegate_type*, 기본 유형의 `T` 클래스 유형은 `System.Delegate` 및 `object`.

## <a name="function-members"></a>함수 멤버

멤버 함수는 실행 가능 문을 포함 하는 멤버입니다. 함수 멤버는 형식의 멤버는 항상 및 네임 스페이스의 구성원이 될 수 없습니다. C#에서는 다음과 같은 범주의 함수 멤버를 정의합니다.

*  메서드
*  속성
*  이벤트
*  인덱서
*  사용자 정의 연산자
*  인스턴스 생성자
*  정적 생성자
*  소멸자

(명시적으로 호출할 수 없습니다)는 정적 생성자 및 소멸자를 제외 하 고 함수 멤버에 포함 된 문의 함수 멤버 호출을 통해 실행 됩니다. 함수 멤버 호출을 작성 하는 실제 구문은 특정 함수 멤버 범주에 따라 달라 집니다.

인수 목록 ([인수 목록](expressions.md#argument-lists)) 함수 멤버의 호출 실제 값 또는 변수 참조를 제공 하는 함수 멤버의 매개 변수입니다.

제네릭 메서드는 호출 된 메서드에 전달할 형식 인수 집합을 결정 하는 형식 유추를 사용할 수 있습니다. 이 프로세스에 설명 되어 [형식 유추](expressions.md#type-inference)합니다.

메서드, 인덱서, 연산자 및 인스턴스 생성자의 호출 함수를 호출 하는 멤버의 후보 집합을 결정 하기 위해 오버 로드 확인을 사용 합니다. 이 프로세스에 설명 되어 [오버 로드 확인](expressions.md#overload-resolution)합니다.

바인딩 시간에 특정 함수 멤버를 식별 가능한 오버 로드 확인을 통해 호출 하는 함수 멤버의 실제 런타임 프로세스에서 설명 하는 [컴파일 타임 검사가동적오버로드확인](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

다음 표에서 명시적으로 호출할 수 있는 함수 멤버의 6 개 범주를 포함 하는 구문에서 발생 하는 과정을 보여 줍니다. 표에 `e`, `x`, `y`, 및 `value` 변수 또는 값으로 분류 하는 식을 나타내는 `T` 형식으로 분류 하는 식을 나타내는 `F` 메서드와 간단한이름인`P` 속성의 단순한 이름입니다.


| __구문__     | __예제__    | __설명__ |
|-------------------|----------------|-----------------|
| 메서드 호출 | `F(x,y)`       | 최상의 방법을 선택 하기 오버 로드 확인을 적용 `F` 클래스 또는 구조체에서. 메서드가 호출 된 인수 목록을 사용 하 여 `(x,y)`입니다. 메서드가 없는 경우 `static`, 인스턴스 식은 `this`합니다. | 
|                   | `T.F(x,y)`     | 최상의 방법을 선택 하기 오버 로드 확인을 적용 `F` 클래스나 구조체에서 `T`합니다. 바인딩 시간 오류가 발생 하는 메서드가 없는 경우 `static`합니다. 메서드가 호출 된 인수 목록을 사용 하 여 `(x,y)`입니다. | 
|                   | `e.F(x,y)`     | 클래스, 구조체 또는 인터페이스의 형식에 의해 지정 된 최상의 방법을 F를 선택 하기 오버 로드 확인을 적용 `e`합니다. 바인딩 시간 오류가 발생 하는 방법이 `static`합니다. 메서드가 호출 된 인스턴스 식이 `e` 및 인수 목록을 `(x,y)`합니다. | 
| 속성 액세스   | `P`            | 합니다 `get` 속성의 접근자 `P` 클래스 또는 구조체에서 호출 됩니다. 컴파일 타임 오류가 발생 하는 경우 `P` 쓰기 전용입니다. 하는 경우 `P` 아닙니다 `static`, 인스턴스 식은 `this`합니다. | 
|                   | `P = value`    | 합니다 `set` 속성의 접근자 `P` 포함 하는 클래스나 구조체가 호출 된 인수 목록과 `(value)`합니다. 컴파일 타임 오류가 발생 하는 경우 `P` 읽기 전용입니다. 하는 경우 `P` 아닙니다 `static`, 인스턴스 식은 `this`합니다. | 
|                   | `T.P`          | 합니다 `get` 속성의 접근자 `P` 클래스나 구조체에서 `T` 가 호출 됩니다. 컴파일 타임 오류가 발생 하는 경우 `P` 아닙니다 `static` 이거나 `P` 쓰기 전용입니다. | 
|                   | `T.P = value`  | `set` 속성의 접근자 `P` 클래스 또는 구조체 `T` 인수 목록을 사용 하 여 호출 `(value)`합니다. 컴파일 타임 오류가 발생 하는 경우 `P` 아닙니다 `static` 이거나 `P` 읽기 전용입니다. | 
|                   | `e.P`          | 합니다 `get` 속성의 접근자 `P` 클래스, 구조체 또는 인터페이스의 형식에 의해 지정 된 `e` 인스턴스 식을 사용 하 여 호출 `e`합니다. 바인딩 시간 오류가 발생 하는 경우 `P` 됩니다 `static` 이거나 `P` 쓰기 전용입니다. | 
|                   | `e.P = value`  | 합니다 `set` 속성의 접근자 `P` 클래스, 구조체 또는 인터페이스의 형식에 의해 지정 된 `e` 인스턴스 식을 사용 하 여 호출 됩니다 `e` 인수 목록과 `(value)`합니다. 바인딩 시간 오류가 발생 하는 경우 `P` 됩니다 `static` 이거나 `P` 읽기 전용입니다. | 
| 이벤트 액세스      | `E += value`   | 합니다 `add` 이벤트의 접근자 `E` 클래스 또는 구조체에서 호출 됩니다. 하는 경우 `E` 는 static이 아닌 인스턴스 식은 `this`합니다. | 
|                   | `E -= value`   | 합니다 `remove` 이벤트의 접근자 `E` 클래스 또는 구조체에서 호출 됩니다. 하는 경우 `E` 는 static이 아닌 인스턴스 식은 `this`합니다. | 
|                   | `T.E += value` | 합니다 `add` 이벤트의 접근자 `E` 클래스나 구조체에서 `T` 가 호출 됩니다. 바인딩 시간 오류가 발생 하는 경우 `E` static이 아닙니다. | 
|                   | `T.E -= value` | 합니다 `remove` 이벤트의 접근자 `E` 클래스나 구조체에서 `T` 가 호출 됩니다. 바인딩 시간 오류가 발생 하는 경우 `E` static이 아닙니다. | 
|                   | `e.E += value` | 합니다 `add` 이벤트의 접근자 `E` 클래스, 구조체 또는 인터페이스의 형식에 의해 지정 된 `e` 인스턴스 식을 사용 하 여 호출 `e`합니다. 바인딩 시간 오류가 발생 하는 경우 `E` 고정 됩니다. | 
|                   | `e.E -= value` | 합니다 `remove` 이벤트의 접근자 `E` 클래스, 구조체 또는 인터페이스의 형식에 의해 지정 된 `e` 인스턴스 식을 사용 하 여 호출 `e`합니다. 바인딩 시간 오류가 발생 하는 경우 `E` 고정 됩니다. | 
| 인덱서 액세스    | `e[x,y]`       | 오버 로드 확인은 최고 클래스, 구조체 또는 e 형식으로 지정 된 인터페이스의 선택에 적용 됩니다. 합니다 `get` 인덱서의 접근자가 인스턴스 식을 사용 하 여 호출 됩니다 `e` 인수 목록과 `(x,y)`합니다. 인덱서는 쓰기 전용 바인딩 시간 오류가 발생 합니다. | 
|                   | `e[x,y] = value` | 오버 로드 확인은 최고 클래스, 구조체 또는 인터페이스의 형식에 의해 지정 된 선택 적용할 `e`합니다. 합니다 `set` 인덱서의 접근자가 인스턴스 식을 사용 하 여 호출 됩니다 `e` 인수 목록과 `(x,y,value)`합니다. 인덱서는 읽기 전용 바인딩 시간 오류가 발생 합니다. | 
| 연산자 호출 | `-x`         | 클래스 또는 구조체의 형식이 지정한 최상의 단항 연산자를 선택 하기 오버 로드 확인을 적용 `x`합니다. 인수 목록을 사용 하 여 선택한 연산자가 호출 `(x)`합니다. | 
|                     | `x + y`      | 클래스 또는 구조체 형식에 따라 지정 된 가장 이항 연산자를 선택 하기 오버 로드 확인을 적용 `x` 고 `y`입니다. 인수 목록을 사용 하 여 선택한 연산자가 호출 `(x,y)`합니다. | 
| 인스턴스 생성자 호출 | `new T(x,y)` | 클래스 또는 구조체에서 최상의 인스턴스 생성자를 선택 하기 오버 로드 확인을 적용 `T`합니다. 인스턴스 생성자가 인수 목록을 사용 하 여 호출 `(x,y)`합니다. | 

### <a name="argument-lists"></a>인수 목록

모든 함수 멤버 및 대리자 호출 하는 함수 멤버의 매개 변수에 대 한 실제 값 또는 변수 참조를 제공 하는 인수 목록이 포함 됩니다. 함수 멤버 호출의 인수 목록을 지정 하는 구문은 함수 멤버 범주에 따라 달라 집니다.

*  예를 들어 생성자, 메서드, 인덱서 및 대리자의 인수는 *argument_list*아래 설명 된 대로 합니다. 인덱서를 호출할 때에 `set` 접근자 인수 목록에 대입 연산자의 오른쪽 피연산자로 지정 된 식이 또한 포함 합니다.
*  속성에 대 한 인수 목록이 비어를 호출할 때 합니다 `get` 접근자를 호출할 때 대입 연산자의 오른쪽 피연산자로 지정 된 식으로 구성 하 고는 `set` 접근자입니다.
*  이벤트에 대 한의 오른쪽 피연산자로 지정 된 식의 인수 목록을 구성 합니다 `+=` 또는 `-=` 연산자입니다.
*  사용자 정의 연산자에 대 한 인수 목록에는 단항 연산자의 단일 피연산자는 이항 연산자의 두 피연산자의 구성 됩니다.

속성의 인수 ([속성](classes.md#properties)), 이벤트 ([이벤트](classes.md#events)), 및 사용자 정의 연산자 ([연산자](classes.md#operators))는 항상 값 매개 변수로 전달 됩니다 ([ 매개 변수 값](classes.md#value-parameters)). 인덱서 인수 ([인덱서](classes.md#indexers))는 항상 값 매개 변수로 전달 됩니다 ([매개 변수 값](classes.md#value-parameters)) 또는 매개 변수 배열 ([매개 변수 배열](classes.md#parameter-arrays)). 참조 및 출력 매개 변수는 함수 멤버의 이러한 범주에 대 한 지원 되지 않습니다.

으로 지정 된 인스턴스 생성자, 메서드, 인덱서 또는 대리자 호출의 인수는 *argument_list*:

```antlr
argument_list
    : argument (',' argument)*
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier ':'
    ;

argument_value
    : expression
    | 'ref' variable_reference
    | 'out' variable_reference
    ;
```

*argument_list* 하나 이상의 구성 *인수*s, 쉼표로 구분 합니다. 각 인수는 선택적 구성 *argument_name* 뒤에 *argument_value*합니다. *인수* 사용 하 여는 *argument_name* 라고는 ***명명 된 인수가***반면는 *인수* 없이  *argument_name* 되는 ***위치 인수***합니다. 명명 된 인수를 뒤에 위치 인수에 대 한 오류가 발생 한 *argument_list*합니다.

합니다 *argument_value* 다음 형식 중 하나를 수행 합니다.

*  *식*를 나타내는 인수가 값 매개 변수로 전달 됩니다 ([매개 변수 값](classes.md#value-parameters)).
*  키워드 `ref` 뒤에 *variable_reference* ([변수 참조](variables.md#variable-references))를 나타내는 인수는 참조 매개 변수로 전달 되는 ([참조 매개 변수 ](classes.md#reference-parameters)). 변수 할당 되어야 합니다 ([한정 된 할당](variables.md#definite-assignment)) 전에 참조 매개 변수로 전달할 수 있습니다. 키워드 `out` 뒤에 *variable_reference* ([변수 참조](variables.md#variable-references))를 나타내는 인수는 출력 매개 변수로 전달 되는 ([매개변수를출력합니다.](classes.md#output-parameters)). 변수를 정적으로 할당 된 것으로 간주 됩니다 ([한정 된 할당](variables.md#definite-assignment)) output 매개 변수로 전달 되는 변수는 함수 멤버 호출을 수행 합니다.

#### <a name="corresponding-parameters"></a>해당 매개 변수

인수 목록의 각 인수에 대 한 더 함수 멤버 또는 호출 되는 대리자를 해당 매개 변수 여야 합니다.

매개 변수 목록 다음에 사용 되는 다음과 같이 결정 됩니다.

*  가상 메서드 및 클래스에 정의 된 인덱서의 경우 매개 변수 목록 가장 구체적인 선언에서 선택 하거나 수신기의 정적 형식을 사용 하 여 시작 하 고 해당 기본 클래스를 통해 검색 함수 멤버를 재정의 합니다.
*  인터페이스 메서드 및 인덱서의 경우 매개 변수 목록 선택은 가장 구체적인 인터페이스 형식을 사용 하 여 시작 하 고 기본 인터페이스를 통해 검색 된 멤버의 정의 형성 합니다. 고유한 매개 변수 목록이 없는 발견 되 면 호출 명명 된 매개 변수를 사용 하거나 선택적 인수를 생략할 수 없습니다 있도록 액세스할 수 없는 이름 및 선택적 매개 변수 없이 사용 하 여 매개 변수 목록이 생성 됩니다.
*  부분 메서드를 정의 하는 partial 메서드 선언 매개 변수 목록을 사용 됩니다.
*  모든 기타 함수 멤버 및 대리자에 사용 되는 단일 매개 변수 목록만 있습니다.

매개 변수 또는 인수의 위치 인수 또는 인수 목록 또는 매개 변수 목록에서 앞에 매개 변수 수가 정의 됩니다.

함수 멤버 인수에 대 한 해당 매개 변수를 다음과 같이 설정 됩니다.

*  인수에는 *argument_list* 인스턴스 생성자, 메서드, 인덱서 및 대리자.
    * 고정된 매개 변수가 매개 변수 목록의 동일한 위치에서 발생 하는 위치 인수는 해당 매개 변수에 해당 합니다.
    * 일반적인 형태로 호출 하는 매개 변수 배열 사용 하 여 함수 멤버의 위치 인수 매개 변수 목록의 동일한 위치에서 발생 해야 하는 매개 변수 배열에 해당 합니다.
    * 매개 변수가 없는 고정된이 발생 한 위치 매개 변수 목록의 동일한 위치에 있는 확장 된 형태로 호출 매개 변수 배열로 함수 멤버의 위치 인수 매개 변수 배열의 요소에 해당 합니다.
    * 명명된 된 인수 매개 변수 목록에 같은 이름의 매개 변수에 해당합니다.
    * 인덱서를 호출할 때 합니다 `set` 접근자, 대입 연산자의 오른쪽 피연산자에 암시적으로 지정 된 식을 `value` 의 매개 변수는 `set` 접근자 선언의 합니다.
*  속성을 호출 하는 경우에 `get` 있습니다 접근자에 인수가 없습니다. 호출할 때 합니다 `set` 접근자, 대입 연산자의 오른쪽 피연산자에 암시적으로 지정 된 식을 `value` 의 매개 변수는 `set` 접근자 선언의 합니다.
*  사용자 정의 단항 연산자 (변환 포함)에 대 한 단일 피연산자 연산자 선언의 단일 매개 변수에 해당 합니다.
*  사용자 정의 이항 연산자의 첫 번째 매개 변수에 해당 하는 왼쪽된 피연산자 및 연산자 선언의 두 번째 매개 변수에 해당 하는 오른쪽 피연산자입니다.

#### <a name="run-time-evaluation-of-argument-lists"></a>인수 목록의 런타임에 평가

멤버 함수 호출의 런타임 처리를 사용 하는 동안 ([컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), 식 또는 변수 참조 인수 목록의 왼쪽에서 오른쪽 순서로 평가 됩니다 다음과 같습니다.

*  인수 식이 계산 되는 값 매개 변수에 대 한 암시적으로 변환 하 고 ([암시적 변환을](conversions.md#implicit-conversions)) 해당 매개 변수에 형식 수행 됩니다. 결과 값을 멤버 함수 호출에 값 매개 변수의 초기 값이 됩니다.
*  참조 또는 출력 매개 변수의 경우 변수 참조는 평가 하 고 결과 저장소 위치는 멤버 함수 호출에서 매개 변수가 나타내는 저장소 위치가 됩니다. 참조 또는 출력 매개 변수로 지정 된 변수 참조의 배열 요소 이면을 *reference_type*, 런타임 검사를 수행 하 여 배열의 요소 형식 매개 변수의 유형과 동일 인지 확인 합니다. 이 검사가 실패 하는 경우는 `System.ArrayTypeMismatchException` throw 됩니다.

메서드, 인덱서 및 인스턴스 생성자는 매개 변수 배열에 맨 오른쪽 매개 변수를 선언할 수 있습니다 ([매개 변수 배열](classes.md#parameter-arrays)). 이러한 함수 멤버에 적용 되는에 따라 해당 확장된 형식 또는 해당 기본 폼의 호출 됩니다 ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)):

*  매개 변수 배열에 대 한 지정 된 인수 암시적으로 변환할 수 있는 단일 식 이어야 합니다 일반적인 형태로 함수 멤버는 매개 변수 배열 사용 하 여 호출 되 면 ([암시적 변환을](conversions.md#implicit-conversions)) 매개 변수 배열 형식입니다. 이 경우 매개 변수 배열의 값 매개 변수 처럼 정확 하 게 작동합니다.
*  확장 된 형태로 매개 변수 배열로 함수 멤버를 호출 하면 호출 각 인수는 암시적으로 변환할 수 있는 식을 매개 변수 배열에 대해 0 개 이상의 위치 인수를 지정 해야 합니다 ([암시적 변환](conversions.md#implicit-conversions)) 매개 변수 배열의 요소 형식입니다. 호출을 인수의 번호에 해당 하는 길이 사용 하 여 매개 변수 배열 형식의 인스턴스를 만듭니다, 그리고 요소의 지정 된 인수 값을 사용 하 여 배열 인스턴스를 초기화 및 새로 만든된 배열 인스턴스는 실제 사용 하 여이 예제의 경우 인수입니다.

인수 목록의 식은 항상 기록 될 때 해당 순서로 계산 됩니다. 따라서 예제
```csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine("x = {0}, y = {1}, z = {2}", x, y, z);
    }

    static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
```
는 출력을 생성합니다.
```
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
```

배열 공동 분산 규칙 ([배열 공변성 (covariance)](arrays.md#array-covariance)) 배열 형식의 값을 허용 `A[]` 배열 형식의 인스턴스에 대 한 참조가 되도록 `B[]`암시적 참조 변환이 존재에서 제공 하는, `B` 를 `A`. 이러한 규칙의 경우 배열 요소의 때문를 *reference_type* 전달 되는 런타임 검사 되는 실제 요소 배열의 형식은 동일한 매개 변수를 확인 하는 데 필요한 참조 또는 출력 매개 변수로 합니다. 예제
```csharp
class Test
{
    static void F(ref object x) {...}

    static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
```
두 번째로 호출 하면 `F` 발생을 `System.ArrayTypeMismatchException` 의 실제 요소 형식 때문 `b` 는 `string` 아니라 `object`합니다.

확장 된 형태로 매개 변수 배열로 함수 멤버를 호출 하면 호출 됩니다 것 처럼 처리 배열 만들기 식을 배열 이니셜라이저로 ([배열 만들기 식](expressions.md#array-creation-expressions)) 주위에 삽입 된는 확장 된 매개 변수입니다. 예를 들어 선언 된 경우
```csharp
void F(int x, int y, params object[] args);
```
다음 호출의 확장 된 형태의 메서드
```csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, "hello", 3.0);
```
정확히 일치
```csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, "hello", 3.0});
```

특히, 매개 변수 배열에 대 한 인수가 있으면 빈 배열을 만들어졌는지 note 합니다.

해당 선택적 매개 변수를 사용 하 여 멤버 함수에서에서 인수를 생략 하면 함수 멤버 선언의 기본 인수를 암시적으로 전달 됩니다. 이기 때문에 항상 상수 평가 나머지 인수의 평가 순서 영향을 주지 않습니다.

### <a name="type-inference"></a>형식 유추

형식 인수를 지정 하지 않고 제네릭 메서드를 호출 하는 경우는 ***형식 유추*** 프로세스 호출에 대 한 형식 인수를 유추 하려고 합니다. 형식 유추의 존재는 제네릭 메서드 호출에 사용 되는 더 편리한 구문을 허용 하 고 중복 형식 정보를 지정 하지 않으려면 프로그래머를 허용 합니다. 예를 들어 다음과 같습니다. 메서드 선언
```csharp
class Chooser
{
    static Random rand = new Random();

    public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
```
호출 하는 것이 불가능 합니다 `Choose` 형식 인수를 명시적으로 지정 하지 않고 메서드:
```csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int>

string s = Chooser.Choose("foo", "bar");        // Calls Choose<string>
```

형식 인수를 형식 유추를 통해서도 `int` 고 `string` 메서드에 인수에서 결정 됩니다.

형식 유추 메서드 호출을 처리 하는 바인딩 시간 부분으로 이루어집니다 ([메서드 호출](expressions.md#method-invocations)) 및 이전 호출의 오버 로드 확인 단계를 수행 합니다. 특정 메서드 그룹은 메서드 호출에 지정 된 메서드 호출의 일부로 지정 된 형식 인수가 없는 경우 형식 유추는 메서드 그룹에 각 제네릭 메서드에 적용 됩니다. 형식 유추에 성공 하면 후속 오버 로드 확인에 대 한 인수의 유형을 확인 하는 유추 된 형식 인수가 사용 됩니다. 오버 로드 확인 제네릭 메서드를 호출 하는 것을 선택 하는 경우 유추 된 형식 인수는 호출에 대 한 실제 형식 인수로 사용 됩니다. 특정 메서드에 대 한 형식 유추에 실패 하면 해당 메서드 오버 로드 확인에 참여 하지 않습니다. 형식 유추를 자체, 오류의 바인딩 시간 오류를 발생 하지 않습니다. 그러나 종종 바인딩 시간 오류를 하지 못하면 오버 로드 확인 한 다음 해당 메서드를 찾을 수 있습니다.

제공 된 인수 개수는 메서드의 매개 변수 수가 다른 경우 유추 즉시 실패 합니다. 그렇지 않으면 제네릭 메서드 시그니처가 다음 가정 합니다.
```csharp
Tr M<X1,...,Xn>(T1 x1, ..., Tm xm)
```

형식의 메서드 호출으로 `M(E1...Em)` 형식 유추는 작업은 고유한 형식 인수를 찾으려면 `S1...Sn` 각 형식 매개 변수에 대해 `X1...Xn` 있도록 호출 `M<S1...Sn>(E1...Em)` 유효 하 게 됩니다.

각 형식 매개 변수는 유추 과정 `Xi` 중 하나는 *고정* 특정 형식에 `Si` 또는 *고정 되지 않은* 연결된 집합이 있는 *범위*. 각 경계는 일부 형식 `T`합니다. 각 형식 변수에 처음 `Xi` 경계 빈 집합을 사용 하 여 고정 아닙니다.

형식 유추 단계로 이루어집니다. 각 단계는 이전 단계의 결과에 따라 자세한 형식 변수에 대 한 형식 인수를 유추 하려고 합니다. 첫 번째 단계는 두 번째 단계는 특정 형식에 형식 변수를 수정 하 고 범위를 유추 하는 반면 일부 초기 추론을 경계를 만듭니다. 두 번째 단계는 해야 할 수 있습니다 횟수 만큼 반복 합니다.

*참고:* 제네릭 메서드를 호출 하는 경우에 뿐만 아니라 수행 하는 형식 유추 됩니다. 에 설명 된 메서드 그룹 변환에 대 한 형식 유추 [메서드 그룹 변환에 대 한 형식 유추](expressions.md#type-inference-for-conversion-of-method-groups) 에 설명 된 식 집합의 가장 일반적인 형식이 찾기 및 [집합의 가장 일반적인 형식 찾기 식의](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)합니다.

#### <a name="the-first-phase"></a>첫 번째 단계

각 메서드 인수에 대 한 `Ei`:

*   하는 경우 `Ei` 는 익명 함수는 *명시적 매개 변수 형식 유추* ([명시적 매개 변수 형식 추론](expressions.md#explicit-parameter-type-inferences))에서 만들어진 `Ei` 를 `Ti`
*   그렇지 않은 경우, `Ei` 형식이 `U` 하 고 `xi` 값 매개 변수는 *유추가* 이루어집니다 *에서* `U` *를* `Ti`.
*   그렇지 않은 경우, `Ei` 형식이 `U` 하 고 `xi` 은 `ref` 또는 `out` 매개 변수는 *유추 정확한* 이루어집니다 *에서* `U` *하* `Ti`합니다.
*   그렇지 않은 경우이 인수에 대 한 유추가 이루어집니다.


#### <a name="the-second-phase"></a>두 번째 단계

두 번째 단계는 다음과 같이 진행 됩니다.

*   모든 *고정 되지 않은* 변수를 입력 `Xi` 하지 않는 *종속* ([종속성](expressions.md#dependence)) 모든 `Xj` 수정 ([수정](expressions.md#fixing)).
*   모든 없는 이러한 형식 변수가 존재 하는 경우 *고정 되지 않은* 변수를 입력 `Xi` 됩니다 *고정* 저장한 다음이 모두는:
    *   하나 이상의 형식 변수가 `Xj` 에 종속 된 `Xi`
    *   `Xi` 집합이 아닌-빈 범위
*   이러한 없는 형식 변수가 존재 하 고 여전히 *고정 되지 않은* 변수 형식 유추 실패를 입력 합니다.
*   그렇지 않으면 더 이상 *고정 되지 않은* 형식 변수, 형식 유추 성공 합니다.
*   모든 인수에 대 한이 고, 그렇지 `Ei` 해당 매개 변수 형식과 `Ti` 여기서 합니다 *출력 형식* ([출력 형식](expressions.md#output-types))를 포함 *고정 되지 않은* 변수를 입력 `Xj` 되지만 *입력 형식을* ([입력 형식을](expressions.md#input-types)) 하지는 *출력 형식 유추* ([출력 형식 추론 ](expressions.md#output-type-inferences)) 이루어집니다 *에서* `Ei` *하* `Ti`합니다. 다음 두 번째 단계를 반복 합니다.

#### <a name="input-types"></a>입력된 형식

경우 `E` 는 메서드 그룹 또는 익명 함수를 암시적으로 형식화 및 `T` 인 대리자 형식 또는 식 트리 형식의 모든 매개 변수 형식은 `T` 됩니다 *입력 형식을* 의 `E` *형식과* `T`합니다.

####  <a name="output-types"></a>출력 형식

경우 `E` 메서드 그룹 또는 익명 함수 및 `T` 인 대리자 형식 또는 식 트리 형식의 반환 형식을 `T` 가 *유형의 출력* `E` *형식을 사용 하 여*  `T`.

#### <a name="dependence"></a>종속성

*고정 되지 않은* 유형 변수에 `Xi` *에 직접 종속* 고정 되지 않은 형식 변수를 `Xj` 경우에 일부 인수에 대 한 `Ek` 형식과 `Tk` `Xj` 발생을 *입력 유형* 의 `Ek` 형식과 `Tk` 및 `Xi` 에서 발생는 *출력 형식* 의 `Ek` 형식을 사용 하 여 `Tk`합니다.

`Xj` *에 따라 달라 집니다* `Xi` 하는 경우 `Xj` *에 직접 종속* `Xi` 이거나 `Xi` *에 직접 종속* `Xk` 고 `Xk` *에 따라 달라 집니다* `Xj`합니다. 따라서 "에 종속"는 "에 직접 종속" 전이적 하지만 하지 반사 종결 합니다.

#### <a name="output-type-inferences"></a>출력 형식 추론

*출력 형식 유추* 이루어집니다 *에서* 식을 `E` *하* 형식 `T` 다음과 같은 방식:

*  하는 경우 `E` 유추 된 반환 형식이 익명 함수로 `U` ([유추 반환 형식](expressions.md#inferred-return-type)) 및 `T` 대리자 형식 또는 반환 형식 가진 식 트리 형식 `Tb`, 다음을 *유추가* ([하한값 추론](expressions.md#lower-bound-inferences)) 이루어집니다 *에서* `U` *하* `Tb`합니다.
*  그렇지 않은 경우, `E` 는 메서드 그룹 및 `T` 대리자 형식 또는 매개 변수 형식 가진 식 트리 형식 `T1...Tk` 및 반환 형식을 `Tb`의 오버 로드 확인 하 고 `E` 형식을 사용 하 여 `T1...Tk` 생성을 메서드 반환 형식 사용 하 여 단일 `U`에 *유추가* 이루어집니다 *에서* `U` *에* `Tb`합니다.
*  그렇지 `E` 형식 사용 하 여 식 `U`에 *유추가* 이루어집니다 *에서* `U` *를* `T`.
*  그렇지 않으면 없습니다 추론이 됩니다.

#### <a name="explicit-parameter-type-inferences"></a>명시적 매개 변수 형식 추론

*명시적 매개 변수 형식 유추* 이루어집니다 *에서* 식을 `E` *하* 형식 `T` 다음과 같은 방법으로:

*  경우 `E` 매개 변수 형식이 명시적으로 형식화 된 익명 함수로 `U1...Uk` 하 고 `T` 대리자 형식 또는 매개 변수 형식 가진 식 트리 형식 `V1...Vk` 각각에 대 한 다음 `Ui` 는 *정확한 유추* ([추론 정확한](expressions.md#exact-inferences)) 이루어집니다 *에서* `Ui` *하* 해당 `Vi`합니다.

#### <a name="exact-inferences"></a>정확한 추론

*유추 정확한* *에서* 형식 `U` *에* 형식 `V` 다음과 같이 이루어집니다.

*  경우 `V` 중 하나인 합니다 *고정 되지 않은* `Xi` 한 다음 `U` 집합에 대 한 정확한 범위에 추가 됩니다 `Xi`합니다.

*  설정 하 고, 그렇지 `V1...Vk` 고 `U1...Uk` 다음 경우 중 하나라도 있는지 확인 하 여 결정 됩니다.

   *  `V` 배열 형식인 `V1[...]` 하 고 `U` 배열 형식인 `U1[...]` 같은 순위
   *  `V` 형식인 `V1?` 고 `U` 형식인 `U1?`
   *  `V` 생성 된 형식인 `C<V1...Vk>`고 `U` 생성 된 형식인 `C<U1...Uk>`

   이러한 경우 다음에 적용 하는 경우는 *유추 정확한* 이루어집니다 *에서* 각 `Ui` *하* 해당 `Vi`합니다.

*  그렇지 않으면 없습니다 추론이 됩니다.

#### <a name="lower-bound-inferences"></a>하한값 추론

A *유추가* *에서* 형식 `U` *를* 형식 `V` 다음과 같이 이루어집니다.

*  경우 `V` 중 하나인 합니다 *고정 되지 않은* `Xi` 한 다음 `U` 집합에 대 한 하한값을 추가할 `Xi`.
*  그렇지 않은 경우, `V` 형식인 `V1?`하 고 `U` 형식인 `U1?` 하한값 유추에서 수행할 `U1` 에 `V1`입니다.
*  설정 하 고, 그렇지 `U1...Uk` 고 `V1...Vk` 다음 경우 중 하나라도 있는지 확인 하 여 결정 됩니다.
   *  `V` 배열 형식입니다 `V1[...]` 하 고 `U` 배열 형식인 `U1[...]` (유효한 기본 형식의 형식 매개 변수나 `U1[...]`) 같은 순위
   *  `V` 중 하나인 `IEnumerable<V1>`, `ICollection<V1>` 또는 `IList<V1>` 하 고 `U` 형식인 1 차원 배열 `U1[]`(유효한 기본 형식의 형식 매개 변수나 `U1[]`)
   *  `V` 생성 된 클래스, 구조체, 인터페이스 또는 대리자 형식인 `C<V1...Vk>` 고유한 형식이 며 `C<U1...Uk>` 되도록 `U` (또는 `U` 형식 매개 변수, 유효한 기본 클래스 또는 효과적인 인터페이스 집합의 모든 멤버)는 과 동일 (직접 또는 간접적으로)에서 상속 되거나 (직접 또는 간접적으로) 구현 `C<U1...Uk>`합니다.

      ("고유성" 제한 사례 인터페이스의 의미 `C<T> {} class U: C<X>, C<Y> {}`, 유추가에서 유추 하는 경우 수행할 `U` 에 `C<T>` 때문에 `U1` 일 수 있습니다 `X` 또는 `Y`.)

   이러한 경우는 유추 수행할를 적용 하는 경우 *에서* 각 `Ui` *를* 해당 `Vi` 다음과 같습니다.

   *  하는 경우 `Ui` 참조 형식으로 알려지지 않은 됩니다 *유추 정확한* 됩니다
   *  그렇지 않고 `U` 배열 형식인는 *유추가* 됩니다
   *  그렇지 않고 `V` 됩니다 `C<V1...Vk>` 유추 i 번째 형식 매개 변수에 따라 다음 `C`:
      *  공변 (covariant) 경우는 *유추가* 이루어집니다.
      *  반공 변 경우는 *상한을 유추* 이루어집니다.
      *  Variant 없으면 됩니다 *유추 정확한* 이루어집니다.
*  그렇지 않으면 없습니다 추론이 됩니다.

#### <a name="upper-bound-inferences"></a>상한 추론

*상한을 유추* *에서* 형식 `U` *에* 형식 `V` 다음과 같이 이루어집니다.

*  경우 `V` 중 하나인 합니다 *고정 되지 않은* `Xi` 한 다음 `U` 상한의 집합에 추가 됩니다 `Xi`합니다.
*  설정 하 고, 그렇지 `V1...Vk` 고 `U1...Uk` 다음 경우 중 하나라도 있는지 확인 하 여 결정 됩니다.
   *  `U` 배열 형식인 `U1[...]` 하 고 `V` 배열 형식인 `V1[...]` 같은 순위
   *  `U` 중 하나인 `IEnumerable<Ue>`, `ICollection<Ue>` 하거나 `IList<Ue>` 고 `V` 형식인 1 차원 배열 `Ve[]`
   *  `U` 형식인 `U1?` 고 `V` 형식인 `V1?`
   *  `U` 생성 된 클래스, 구조체, 인터페이스 또는 대리자 형식 `C<U1...Uk>` 및 `V` (직접 또는 간접적으로) 클래스, 구조체, 인터페이스 또는 대리자 형식에서 상속 (직접 또는 간접적으로)를 동일한 또는 구현 되는 고유한 형식 `C<V1...Vk>`

      ("고유성" 제한 한다는 것을 의미 했습니다 `interface C<T>{} class V<Z>: C<X<Z>>, C<Y<Z>>{}`에서 유추할 때 유추가 수행할 `C<U1>` 에 `V<Q>`입니다. 추론에서 되지 `U1` 하나로 `X<Q>` 또는 `Y<Q>`.)

   이러한 경우는 유추 수행할를 적용 하는 경우 *에서* 각 `Ui` *를* 해당 `Vi` 다음과 같습니다.
   *  하는 경우 `Ui` 참조 형식으로 알려지지 않은 됩니다 *유추 정확한* 됩니다
   *  그렇지 않은 경우, `V` 배열 형식인 됩니다 *상한을 유추* 됩니다
   *  그렇지 않고 `U` 됩니다 `C<U1...Uk>` 유추 i 번째 형식 매개 변수에 따라 다음 `C`:
      *  공변 (covariant) 경우는 *상한을 유추* 이루어집니다.
      *  반공 변 경우는 *유추가* 이루어집니다.
      *  Variant 없으면 됩니다 *유추 정확한* 이루어집니다.
*  그렇지 않으면 없습니다 추론이 됩니다.   

#### <a name="fixing"></a>수정

*고정 되지 않은* 유형의 변수에 `Xi` 경계 설정 *고정* 다음과 같습니다:

*  집합이 *후보 형식* `Uj` 경계를 집합에서 모든 종류의 집합으로 시작 `Xi`합니다.
*  그런 다음 각 경계를 살펴봅니다 `Xi` 차례로: 각 정확한 범위에 대 한 `U` 의 `Xi` 유형도 `Uj` 와 동일 하지 않습니다 `U` 후보 집합에서 제거 됩니다. 각 범위에 대 한 `U` 의 `Xi` 유형도 `Uj` 는 여기에는 *하지* 암시적 변환이 `U` 후보 집합에서 제거 됩니다. 각 상한 값에 대 한 `U` 의 `Xi` 유형도 `Uj` 는 여기에서 *하지* 암시적 변환 `U` 후보 집합에서 제거 됩니다.
*  If 나머지 후보 형식 간의 `Uj` 고유 유형이 `V` 는 암시적 변환이 모든 다른 후보 유형으로 다음에서 `Xi` 로 고정 됩니다 `V`합니다.
*  그렇지 않은 경우 형식 유추가 실패 했습니다.

#### <a name="inferred-return-type"></a>유추 반환 형식

유추 된 익명 함수 유형을 반환 `F` 형식 유추 및 오버 로드 확인 중에 사용 됩니다. 유추 반환 형식 종류를 알고 있는 경우 하거나 명시적으로 학생은 때문에 모든 매개 변수는 익명 함수 변환을 통해 제공 하거나 유추 하는 동안에 형식 유추 바깥쪽 제네릭 있는 익명 함수에만 확인할 수 있습니다. 메서드 호출입니다.

합니다 ***결과 형식 유추*** 다음과 같이 결정 됩니다.

*  경우 본문 `F` 은 *식* 형식에 다음의 유추 된 결과 형식에는 `F` 해당 식의 형식입니다.
*  경우 본문 `F` 되는 *블록* 및 식 블록의 집합 `return` 문을 가장 일반적인 형식이 `T` ([식집합의가장일반적인형식찾기](expressions.md#finding-the-best-common-type-of-a-set-of-expressions))의 유추 된 결과 형식은 `F` 는 `T`합니다.
*  에 대 한 결과 형식을 유추할 수 없습니다이 고, 그렇지 `F`합니다.

합니다 ***반환 형식을 유추*** 다음과 같이 결정 됩니다.

*  하는 경우 `F` 비동기 이며 본문 `F` nothing으로 분류 하거나 식 ([식 분류](expressions.md#expression-classifications)), 또는 return 문은 없습니다 있는 식, 문 블록을 유추 된 반환 형식은 `System.Threading.Tasks.Task`
*  하는 경우 `F` 비동기 이며 유추 결과 형식이 `T`, 유추 된 반환 형식이 `System.Threading.Tasks.Task<T>`합니다.
*  하는 경우 `F` 비동기가 아닌 이며 유추 결과 형식이 `T`, 유추 된 반환 형식이 `T`합니다.
*  에 대 한 반환 형식을 유추할 수 없습니다이 고, 그렇지 `F`합니다.

익명 함수를 포함 하는 형식 유추의 예로 `Select` 에 선언 된 확장 메서드는 `System.Linq.Enumerable` 클래스:
```csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable<TResult> Select<TSource,TResult>(
            this IEnumerable<TSource> source,
            Func<TSource,TResult> selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
```

가정 합니다 `System.Linq` 네임 스페이스를 사용 하 여 가져온를 `using` 절 클래스가 있다고 가정 하 고 `Customer` 사용 하 여를 `Name` 형식의 속성 `string`, `Select` 메서드 고객 목록의 이름을 선택 하는데 사용할 수 있습니다:
```csharp
List<Customer> customers = GetCustomerList();
IEnumerable<string> names = customers.Select(c => c.Name);
```

확장 메서드 호출 ([확장 메서드 호출](expressions.md#extension-method-invocations))의 `Select` 정적 메서드 호출에 대 한 호출을 다시 작성 하 여 처리 됩니다.
```csharp
IEnumerable<string> names = Enumerable.Select(customers, c => c.Name);
```

형식 인수를 명시적으로 지정 되지 않았습니다, 이후 형식 유추 형식 인수를 유추 하는 데 사용 됩니다. 먼저 합니다 `customers` 인수는 관련이 합니다 `source` 매개 변수를 유추 `T` 되도록 `Customer`합니다. 익명 함수를 사용 하 여 위에서 설명한 유추 과정을 입력 하는 한 `c` 형식이 지정 되며 `Customer`, 및 식 `c.Name` 의 반환 형식은 관련이 합니다 `selector` 매개 변수를 유추 `S` 되도록`string`. 따라서 호출에 해당 하는
```csharp
Sequence.Select<Customer,string>(customers, (Customer c) => c.Name)
```
형식의 결과 `IEnumerable<string>`합니다.

다음 예제에서는 어떻게 익명 함수 형식 유추 "흘러나오는" 제네릭 메서드 호출의 인수 간의 형식 정보를 사용 하면 됩니다. 메서드를 제공 합니다.
```csharp
static Z F<X,Y,Z>(X value, Func<X,Y> f1, Func<Y,Z> f2) {
    return f2(f1(value));
}
```

호출에 대 한 형식 유추 합니다.
```csharp
double seconds = F("1:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds);
```
다음과 같이 진행 됩니다: 첫 번째 인수 `"1:15:30"` 관련이 `value` 매개 변수를 유추 `X` 되도록 `string`합니다. 다음, 첫 번째 익명 함수의 매개 변수 `s`, 유추 된 형식이 지정 되며 `string`, 및 식 `TimeSpan.Parse(s)` 의 반환 형식은 관련이 `f1`, 유추 `Y` 되도록 `System.TimeSpan`합니다. 마지막으로, 두 번째 익명 함수의 매개 변수 `t`, 유추 된 형식이 지정 되며 `System.TimeSpan`, 및 식 `t.TotalSeconds` 의 반환 형식은 관련이 `f2`, 유추 `Z` 되도록 `double`합니다. 따라서 호출의 결과 형식 `double`합니다.

#### <a name="type-inference-for-conversion-of-method-groups"></a>메서드 그룹 변환에 대 한 형식 유추

비슷하게 제네릭 메서드 호출 형식 유추도 적용 해야 때 메서드 그룹이 `M` 지정 된 대리자 형식을 제네릭 메서드가 포함 된 변환할 `D` ([메서드 그룹 변환](conversions.md#method-group-conversions)). 지정 된 메서드
```csharp
Tr M<X1...Xn>(T1 x1 ... Tm xm)
```
메서드 그룹과 `M` 대리자 형식에 할당할 `D` 형식 인수를 검색할 형식 유추는 작업은 `S1...Sn` 있도록 식:
```csharp
M<S1...Sn>
```
호환 됩니다 ([대리자 선언](delegates.md#delegate-declarations)) 사용 하 여 `D`입니다.

제네릭 메서드 호출에 대 한 형식 유추 알고리즘, 달리이 경우 가지 인수만 *형식*에 인수가 없습니다 *식을*합니다. 특히 가지 익명 함수가 없습니다. 따라서 유추의 여러 단계에 대 한 필요가 없습니다.

대신, 모든 `Xi` 것으로 간주 됩니다 *고정 되지 않은*, 및 *유추가* 이루어집니다 *에서* 각 인수 형식이 `Uj` 의 `D` *하* 해당 매개 변수 형식 `Tj` 의 `M`합니다. 에 대 한 경우에는 `Xi` 없는 경계를 찾을 수 없습니다, 형식 유추가 실패 했습니다. 그렇지 않으면 모든 `Xi` 는 *고정* 해당 `Si`, 형식 유추의 결과.

#### <a name="finding-the-best-common-type-of-a-set-of-expressions"></a>식 집합의 가장 일반적인 형식 찾기

경우에 따라 공용 형식 식의 집합에 대 한 유추 해야 합니다. 특히, 암시적으로 형식화 된 배열의 요소 형식 및 포함 된 익명 함수의 반환 형식은 *블록* 본문이 이렇게에 포함 됩니다.

직관적으로 지정 된 식 집합 `E1...Em` 이 유추에 해당 하는 메서드를 호출 해야 합니다.
```csharp
Tr M<X>(X x1 ... X xm)
```
사용 하 여는 `Ei` 인수로 합니다.

보다 정확 하 게 유추가 시작을 *고정 되지 않은* 유형의 변수에 `X`합니다. *출력 형식 유추* 됩니다 *에서* 각 `Ei` *하* `X`합니다. 마지막으로, `X` 됩니다 *고정* 하 고 성공 하면 결과 입력 `S` 식의 결과 가장 일반적인 형식입니다. 그러한 `S` 있는 식이 있는 가장 일반적인 형식이 없습니다.

### <a name="overload-resolution"></a>오버 로드 확인

오버 로드 확인은 인수 목록 및 후보 함수 멤버 집합을 호출할 최상의 함수 멤버를 선택 하는 바인딩 타임 메커니즘입니다. 오버 로드 확인은 다음과 같은 컨텍스트 내에서 C#를 호출 하는 함수 멤버를 선택 합니다.

*  에 명명 된 메서드 호출을 *invocation_expression* ([메서드 호출](expressions.md#method-invocations)).
*  에 명명 된 인스턴스 생성자의 호출을 *object_creation_expression* ([개체 만들기 식](expressions.md#object-creation-expressions)).
*  통해 인덱서 접근자의 호출을 *element_access* ([요소 액세스](expressions.md#element-access)).
*  호출 식에서 참조 하는 미리 정의 된 또는 사용자 정의 연산자 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution) 하 고 [이항 연산자 오버 로드 확인에](expressions.md#binary-operator-overload-resolution)).

이러한 각 컨텍스트 정의 후보 함수 멤버 집합 및 인수 목록을 자체 고유한 방식으로 위의 섹션에서 자세히 설명 된 대로 합니다. 예를 들어, 메서드 호출에 대 한 후보 집합을 표시 하는 방법을 다루지 않습니다 `override` ([멤버 조회](expressions.md#member-lookup)), 기본 클래스에서 메서드 후보가 아닙니다 파생된 클래스에서 모든 메서드는 해당 하는 경우 및 ([ 메서드 호출](expressions.md#method-invocations)).

후보 함수 멤버 및 인수 목록을 식별 되 면 최상의 함수 멤버를 선택은 모든 경우에서와 동일:

*  최상의 집합이 멤버를 함수 적용 가능한 후보 함수 멤버 집합을 지정 합니다. 집합 함수 멤버가 하나만 있으면 해당 하는 함수 멤버는 최상의 함수 멤버입니다. 최상의 함수 멤버는 각 함수 멤버의 규칙을 사용 하 여 모든 기타 함수 멤버과 비교 되는 지정 된 인수 목록에 대해 모든 기타 함수 멤버 보다는 하나의 함수 멤버가 고, 그렇지 [ 최상의 함수 멤버](expressions.md#better-function-member)합니다. 정확 하 게 모든 기타 함수 멤버 보다 나은 함수 멤버가 하나 있으면 함수 멤버 호출이 모호 합니다 및 바인딩 시간에 발생 합니다.

다음 섹션에서는 정의 용어의 정확한 의미 ***적용 가능한 함수 멤버*** 하 고 ***최상의 함수 멤버***합니다.

#### <a name="applicable-function-member"></a>적용 가능한 함수 멤버

함수 멤버 라고는 ***적용 가능한 함수 멤버*** 인수 목록에 대해 `A` 경우 다음 모두:

*  각 인수 `A` 에 설명 된 대로 함수 멤버 선언의 매개 변수에 해당 [해당 매개 변수](expressions.md#corresponding-parameters)를 인수 없이 해당 하는 모든 매개 변수는 선택적 매개 변수입니다.
*  각 인수에 대 한 `A`모드는 인수를 전달 매개 변수 (즉, 값 `ref`, 또는 `out`) 해당 매개 변수의 매개 변수 전달 모드와 동일 하 고
   *  값 매개 변수 또는 매개 변수 배열로 암시적 변환에 대 한 ([암시적 변환을](conversions.md#implicit-conversions)) 해당 매개 변수의 형식 인수에서 존재 또는
   *  에 `ref` 또는 `out` 매개 변수 인수의 형식은 해당 매개 변수의 유형과 동일 합니다. 결국에 `ref` 또는 `out` 매개 변수는 전달 된 인수에 대 한 별칭입니다.

매개 변수 배열에 포함 하는 함수 멤버에 적용할 라고 하는 함수 멤버를 위의 규칙에 따라 적용할 수 있는 경우 해당 ***정규형***합니다. 함수 멤버 대신에 적용할 수 있습니다 매개 변수 배열을 포함 하는 함수 멤버를 해당 기본 형식에 적용할 수 없는 경우 해당 ***폼을 확장***:

*  함수 멤버 선언의 매개 변수 배열의 0으로 대체 하 여 생성 된 확장 된 형식 또는 매개 변수의 요소 형식의 자세한 값 매개 변수 배열 같은 해당 인수 목록의 인수 개수 `A` 합계와 일치 매개 변수 개수입니다. 경우 `A` 함수 멤버 선언에서 고정 된 매개 변수 개수 보다 더 적은 인수가, 확장 된 형태의 함수 멤버를 생성할 수 없습니다 하 고 있으므로 적용 되지 않습니다.
*  확장 된 형식 그러지 않으면 각 인수에 대해 작업 하는 경우 해당은 `A` 인수 매개 변수 전달 모드는 해당 매개 변수의 매개 변수 전달 모드와 동일 하 고
   *  고정된 값 매개 변수 또는 암시적 변환이 확장을 통해 만들어진 값 매개 변수 ([암시적 변환을](conversions.md#implicit-conversions)) 형식 인수의 형식에서 해당 매개 변수의 형식으로 또는
   *  에 `ref` 또는 `out` 매개 변수 인수의 형식은 해당 매개 변수의 유형과 동일 합니다.

#### <a name="better-function-member"></a>최상의 함수 멤버

최상의 함수 멤버를 결정 하는 용도로 인수 식 자체 원래 인수 목록에 표시 되는 순서 대로 포함 하는 축소 된 기본 인수 목록을 생성 됩니다.

각 멤버는 다음과 같은 방법으로 생성 된 후보 함수에 대 한 매개 변수는 나열:

*  확장 된 양식은 함수 멤버를 확장 된 형식에만 해당 하는 경우에 사용 됩니다.
*  해당 인수를 사용 하 여 선택적 매개 변수는 매개 변수 목록에서 제거 됩니다.
*  매개 변수는 인수 목록의 해당 인수와 동일한 위치에서 발생 하는 기록 되는 합니다.

인수 목록 `A` 인수 식의 집합을 사용 하 여 `{E1, E2, ..., En}` 및 두 적용 가능한 함수 멤버 `Mp` 및 `Mq` 매개 변수 형식을 가진 `{P1, P2, ..., Pn}` 및 `{Q1, Q2, ..., Qn}`, `Mp` 것으로 정의 되는 ***최상의 함수 멤버*** 보다 `Mq` 경우

*  각 인수에 암시적으로 변환 `Ex` 하 `Qx` 암시적으로 변환 보다 좋습니다 `Ex` 에 `Px`, 및
*  하나 이상의 인수를 변환에 대 한 `Ex` 하 `Px` 변환 보다 나은 `Ex` 에 `Qx`입니다.

이 평가 수행할 때 `Mp` 또는 `Mq` 이면 해당 확장된 형식에 적용할 수 `Px` 또는 `Qx` 확장된 형식의 매개 변수 목록에서 매개 변수를 참조 합니다.

매개 변수는 시퀀스를 입력 하는 경우 `{P1, P2, ..., Pn}` 하 고 `{Q1, Q2, ..., Qn}` 동일 (즉, 각 `Pi` 에 해당 하는 id 변환을 `Qi`)를 향상을 확인 하려면 다음 주요 동률 규칙이 적용 됩니다 함수 멤버입니다.

*  하는 경우 `Mp` 제네릭이 아닌 메서드는 및 `Mq` 제네릭 메서드 이면 `Mp` 보다 나은 `Mq`합니다.
*  그렇지 않은 경우, `Mp` 해당 기본 폼에 적용 됩니다 및 `Mq` 에 `params` 배열을 가져온 다음 해당 확장된 형식에만 적용 됩니다 `Mp` 보다 나은 `Mq`합니다.
*  그렇지 않은 경우, `Mp` 보다 매개 변수를 더 선언에 `Mq`, 한 다음 `Mp` 보다 나은 `Mq`합니다. 두 방법 모두 경우 발생할 수 있습니다이 `params` 배열 및 확장된의 형식에만 적용 됩니다.
*  그렇지 않은 경우의 모든 매개 변수 `Mp` 기본 인수에 하나 이상의 선택적 매개 변수를 대체 해야 하는 반면 해당 인수를 가질 `Mq` 한 다음 `Mp` 보다는 낫습니다 `Mq`합니다.
*  그렇지 않은 경우, `Mp` 보다 구체적인 매개 변수 형식이 `Mq`, 한 다음 `Mp` 보다 나은 `Mq`합니다. 수 있도록 `{R1, R2, ..., Rn}` 하 고 `{S1, S2, ..., Sn}` 인스턴스화되지 않은 및 확장 되지 않은 매개 변수 형식을 나타내는 `Mp` 및 `Mq`합니다. `Mp`매개 변수 유형은 보다 구체적인 `Mq`의 경우 각 매개 변수에 `Rx` 보다 덜 구체적인 아닙니다 `Sx`, 및 하나 이상의 매개 변수가 `Rx` 보다 구체적인 `Sx`:
   *  형식 매개 변수는 비형식 매개 변수 보다 덜 구체적입니다.
   *  재귀적으로 생성된 된 형식을 다른 생성 된 형식 (동일한 개수의 형식 인수) 하나 이상의 인수를 입력 하는 경우 보다 구체적인 이며 형식 인수 없이 다른의 해당 형식 인수 보다 덜 구체적인 것 보다 더 구체적입니다.
   *  배열 형식 (사용 하 여 동일한 차원 수) 다른 배열 형식 보다 구체적인 경우 첫 번째 요소 형식은 두 번째 요소 형식 보다 더 구체적입니다.
*  그렇지 않으면 멤버가 하나는 비 리프트 된 연산자는 다른 리프트 된 연산자를 리프트 되지 않는 것이 좋습니다.
*  그렇지 않으면 함수 멤버 모두이 좋습니다.

#### <a name="better-conversion-from-expression"></a>식에서 더 나은 변환

암시적 변환을 지정 `C1` 식에서 변환 하 `E` 형식으로 `T1`, 및 변환 하는 암시적 변환을 `C2` 식에서 변환 `E` 형식으로 `T2`, `C1` ***향상 된 변환*** 보다 `C2` 하는 경우 `E` 정확히 일치 하지 않는 `T2` 다음 중 하나 이상 보유 하 고:

* `E` 정확히 일치 `T1` ([정확 하 게 일치 식](expressions.md#exactly-matching-expression))
* `T1` 보다 나은 변환 대상인 `T2` ([변환 대상 더 나은](expressions.md#better-conversion-target))

#### <a name="exactly-matching-expression"></a>정확히 일치 하는 식

식에 지정 되었습니다 `E` 형식과 `T`를 `E` 정확히 일치 `T` 다음 중 하나를 보유 하는 경우:

*  `E` 형식이 `S`, 및에서 id 변환이 존재 `S` 를 `T`
*  `E` 익명 함수 `T` 이 대리자 형식이 `D` 또는 식 트리 형식 `Expression<D>` 다음 중 하나를 보유 하 고 있습니다.
   *  유추 된 반환 형식 `X` 에 대 한 존재 `E` 매개 변수 목록이의 컨텍스트에서 `D` ([유추 반환 형식](expressions.md#inferred-return-type))에서 id 변환이 존재 `X` 의 반환 형식 `D`
   *  어느 `E` 은 비동기가 아닌 및 `D` 반환 형식이 `Y` 또는 `E` 는 비동기 및 `D` 반환 형식이 `Task<Y>`, 다음 중 하나를 보유 하 고:
      * 본문 `E` 정확 하 게 일치 하는 식 `Y`
      * 본문 `E` 은 문 블록이 모든 return 문이 반환 하는 위치 식을 정확 하 게 일치 `Y`

#### <a name="better-conversion-target"></a>더 나은 변환 대상

두 가지 유형이 지정 된 `T1` 및 `T2`를 `T1` 보다는 더 나은 변환 대상 `T2` 경우에서 암시적 변환은 없습니다 `T2` 에 `T1` 가 다음 중 하나 이상 보유 하 고:

*  암시적 변환이 `T1` 에 `T2` 존재
*  `T1` 이 대리자 형식이 `D1` 또는 식 트리 형식을 `Expression<D1>`, `T2` 이 대리자 형식이 `D2` 또는 식 트리 형식 `Expression<D2>`를 `D1` 반환 형식이 `S1` 및 중 하나는 다음 저장 합니다.
   * `D2` void 반환
   * `D2` 반환 형식이 `S2`, 및 `S1` 보다는 더 나은 변환 대상 `S2`
*  `T1` 됩니다 `Task<S1>`, `T2` 됩니다 `Task<S2>`, 및 `S1` 보다는 더 나은 변환 대상 `S2`
*  `T1` `S1` 또는 `S1?` 여기서 `S1` 부호 있는 정수 계열 형식이, 및 `T2` 는 `S2` 또는 `S2?` 여기서 `S2` 부호 없는 정수 계열 형식입니다. 구체적으로는 다음과 같습니다.
   * `S1` `sbyte` 하 고 `S2` 됩니다 `byte`, `ushort`, `uint`, 또는 `ulong`
   * `S1` `short` 하 고 `S2` 됩니다 `ushort`, `uint`, 또는 `ulong`
   * `S1` 됩니다 `int` 하 고 `S2` 는 `uint`, 또는 `ulong`
   * `S1` 됩니다 `long` 고 `S2` 됩니다 `ulong`

#### <a name="overloading-in-generic-classes"></a>제네릭 클래스에서 오버 로드

선언 된 서명이 고유 해야 하는 동안 가능성이 동일한 서명에서 형식 인수는 대체 결과 있습니다. 이러한 경우에 동률 주요 규칙 위의 오버 로드 확인에는 대부분의 특정 멤버를 선택 합니다.

다음 예에서는 유효 하 고이 규칙에 따라 잘못 된 오버 로드를 보여 줍니다.

```csharp
interface I1<T> {...}

interface I2<T> {...}

class G1<U>
{
    int F1(U u);                  // Overload resolution for G<int>.F1
    int F1(int i);                // will pick non-generic

    void F2(I1<U> a);             // Valid overload
    void F2(I2<U> a);
}

class G2<U,V>
{
    void F3(U u, V v);            // Valid, but overload resolution for
    void F3(V v, U u);            // G2<int,int>.F3 will fail

    void F4(U u, I1<V> v);        // Valid, but overload resolution for    
    void F4(I1<V> v, U u);        // G2<I1<int>,int>.F4 will fail

    void F5(U u1, I1<V> v2);      // Valid overload
    void F5(V v1, U u2);

    void F6(ref U u);             // valid overload
    void F6(out V v);
}
```

### <a name="compile-time-checking-of-dynamic-overload-resolution"></a>컴파일 타임 검사 동적 오버 로드 확인

대부분 동적으로 바인딩된 작업에 대 한 해결 방법에 대 한 가능한 후보 집합이 컴파일 타임에 알려진 아닙니다. 그러나 경우에 따라 후보 집합이 컴파일 타임에 알려져 있습니다.

*  동적 인수를 사용 하 여 정적 메서드 호출
*  수신자가 동적 식이 아닌 인스턴스 메서드 호출
*  인덱서 호출 수신자가 동적 식이 아닌
*  동적 인수를 사용 하 여 생성자 호출

이러한 경우 경우 고 가능한 경우 적용할 수 런타임 시 확인 하려면 각 후보에 대 한 제한 된 컴파일 타임 검사를 수행 됩니다. 이 검사는 다음 단계로 구성 됩니다.

*  부분 형식 유추: 모든 형식 인수 형식의 인수에 직접 또는 간접적으로 종속 되지 않습니다 `dynamic` 의 규칙을 사용 하 여 유추 [형식 유추](expressions.md#type-inference)합니다. 알 수 없는 나머지 형식 인수입니다.
*  부분 적용 가능성 확인: 적용 가능성에 따라 확인란이 [적용 가능한 함수 멤버](expressions.md#applicable-function-member)에 형식이 알려지지 않은 매개 변수는 무시 되지만 합니다.
*  없는 후보가이 테스트를 통과 하는 경우 컴파일 타임 오류가 발생 합니다.

### <a name="function-member-invocation"></a>함수 멤버 호출

이 섹션에서는 특정 함수 멤버를 호출 하려면 런타임 시 발생 하는 프로세스를 설명 합니다. 바인딩 시간 프로세스 호출, 가능한 경우 적용 하 여 오버 로드 확인 후보 함수 멤버 집합에 특정 멤버를 이미 결정에 간주 됩니다.

호출 프로세스를 설명 하는 용도로 함수 멤버 두 범주로 나뉩니다.

*  정적 함수 멤버입니다. 이들은, 인스턴스 생성자, 정적 메서드를 정적 속성 접근자 및 사용자 정의 연산자입니다. 정적 함수 멤버는 항상 가상입니다.
*  인스턴스 함수 멤버입니다. 이들은, 인스턴스 메서드, 인스턴스 속성 접근자 및 인덱서 접근자입니다. 인스턴스 함수 멤버 비가상 이거나 가상 되며 특정 인스턴스에서 항상 호출 됩니다. 인스턴스를 인스턴스 식에서 계산 되 고으로 함수 멤버에 액세스할 수 있습니다 `this` ([이 액세스](expressions.md#this-access)).

멤버 함수 호출의 런타임 처리는 다음 단계로 구성 됩니다 여기서 `M` 함수 멤버인 경우 `M` 는 인스턴스 멤버 `E` 인스턴스 식:

*  경우 `M` 멤버인 정적 함수:
   * 인수 목록에 설명 된 대로 평가 됩니다 [인수 목록](expressions.md#argument-lists)합니다.
   * `M` 가 호출 됩니다.

*  하는 경우 `M` 인스턴스 함수 멤버에 선언 된 *value_type*:
   * `E` 평가 됩니다. 이 평가 예외를 발생 시키는 경우에 추가 단계 없이 실행 됩니다.
   * 하는 경우 `E` 변수를 다음의 임시 로컬 변수로 분류 되지 않은 `E`의 형식을 만들 값 `E` 해당 변수에 할당 됩니다. `E` 해당 임시 지역 변수에 대 한 참조로 다시 다음 분류 됩니다. 임시 변수가로 액세스할 수 있습니다 `this` 내에서 `M`에 있지만 다른 방식으로 합니다. 경우에 따라서만 `E` true 변수는 호출자가 변경 내용을 관찰할 수 있는 `M` 게 `this`합니다.
   * 인수 목록에 설명 된 대로 평가 됩니다 [인수 목록](expressions.md#argument-lists)합니다.
   * `M` 가 호출 됩니다. 참조 변수의 `E` 변수에서 참조 됩니다 `this`합니다.

*  하는 경우 `M` 인스턴스 함수 멤버에 선언 된 *reference_type*:
   * `E` 평가 됩니다. 이 평가 예외를 발생 시키는 경우에 추가 단계 없이 실행 됩니다.
   * 인수 목록에 설명 된 대로 평가 됩니다 [인수 목록](expressions.md#argument-lists)합니다.
   * 경우 형식의 `E` 되는 *value_type*, boxing 변환 ([Boxing 변환](types.md#boxing-conversions)) 변환 하기 위해 수행 됩니다 `E` 형식으로 `object`, 및 `E` 것으로 간주 됩니다 형식의 `object` 다음 단계에 있습니다. 이 예에서 `M` 의 멤버일 수만 있습니다 `System.Object`합니다.
   * 변수의 `E` 유효한 것으로 확인 됩니다. 경우 값 `E` 은 `null`, `System.NullReferenceException` throw 되 고 추가 단계 없이 실행 됩니다.
   * 호출 하는 함수 멤버 구현은 다음과 같이 결정 됩니다.
     * 에 바인딩 형식이 `E` 인터페이스를 호출 하는 함수 멤버의 구현인 `M` 에서 참조 하는 인스턴스의 런타임 형식에서 제공 `E`. 이 함수 멤버 인터페이스 매핑 규칙을 적용 하 여 결정 됩니다 ([인터페이스 매핑을](interfaces.md#interface-mapping)) 구현의 결정할 `M` 런타임 형식에서 참조 하는 인스턴스의 제공한 `E`.
     * 그렇지 않은 경우, `M` 멤버인 가상 함수를 호출 하는 함수 멤버의 구현인 `M` 에서 참조 하는 인스턴스의 런타임 형식에서 제공 `E`합니다. 이 함수 멤버는 가장 많이 파생 된 구현 결정 하는 것에 대 한 규칙을 적용 하 여 결정 됩니다 ([가상 메서드](classes.md#virtual-methods))의 `M` 런타임 형식에서 참조 하는 인스턴스의 관련 하 여 `E`입니다.
     * 그렇지 않으면 `M` 비가상 함수 멤버 이며를 호출 하는 함수 멤버 `M` 자체입니다.
   * 위의 단계에서 결정 함수 멤버 구현이 호출 됩니다. 참조 하는 개체가 `E` 가 참조 하는 개체가 `this`합니다.

#### <a name="invocations-on-boxed-instances"></a>Boxed 인스턴스에서 호출

구현 되는 함수 멤버를 *value_type* 의 boxed 인스턴스를 통해 호출할 수 있습니다 *value_type* 다음과 같은 경우에서:

*  함수 멤버의 경우는 `override` 형식에서 상속 된 메서드 `object` 형식의 인스턴스 식을 통해 호출 되 고 `object`입니다.
*  함수 멤버 인터페이스 함수 멤버의 구현인 시점과의 인스턴스 식을 통해 호출 되는 *interface_type*합니다.
*  대리자를 통해 함수 멤버를 호출할 때 표시 됩니다.

이러한 상황에서는 boxed 인스턴스 변수를 포함할 것으로 간주 합니다 *value_type*,이 변수에서 참조 하는 변수가 되며 `this` 함수 멤버 호출 내에서. 특히,이 함수 멤버 boxed 인스턴스에서 호출 되 면 수 있다는 것 boxed 인스턴스에 포함 된 값을 수정 하는 함수 멤버에 대 한 의미 합니다.

## <a name="primary-expressions"></a>기본 식

기본 식에는 가장 간단한 형태의 식 포함 됩니다.

```antlr
primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string_expression
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
```

기본 식 간에 나뉩니다 *array_creation_expression*s 및 *primary_no_array_creation_expression*s입니다. 이 방식으로 배열 만들기 식 처리, 다른 간단한 식 형태와 함께 나열 하는 대신 사용 하면와 같은 잠재적으로 혼란 스러운 코드를 허용 하지 않도록 문법
```csharp
object o = new int[3][1];
```
하는 것으로 해석 될
```csharp
object o = (new int[3])[1];
```

### <a name="literals"></a>리터럴

A *primary_expression* 으로 구성 된를 *리터럴* ([리터럴](lexical-structure.md#literals)) 값으로 분류 됩니다.


### <a name="interpolated-strings"></a>보간된 문자열

*interpolated_string_expression* 이루어져를 `$` 여기서 구멍을 구분 기호 뒤에 정기적으로 또는 축 자 문자열 리터럴 `{` 및 `}`, 식 및 서식 지정 사양입니다. 보간된 문자열 식의 결과인를 *interpolated_string_literal* 는 분할 된 개별 토큰에에 설명 된 대로 [보간된 문자열 리터럴을](lexical-structure.md#interpolated-string-literals)합니다.

```antlr
interpolated_string_expression
    : '$' interpolated_regular_string
    | '$' interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation (interpolated_regular_string_mid interpolation)*
    ;

interpolation
    : expression
    | expression ',' constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation (interpolated_verbatim_string_mid interpolation)+
    ;
```

합니다 *constant_expression* 보간을으로 암시적 변환이 있어야 합니다 `int`합니다.

*interpolated_string_expression* 값으로 분류 됩니다. 즉시 변환할 경우 `System.IFormattable` 또는 `System.FormattableString` 변환 하는 보간된 문자열의 암시적 변환을 사용 하 여 ([암시적 보간된 문자열 변환](conversions.md#implicit-interpolated-string-conversions)), 보간된 문자열 식은 해당 형식이 없습니다. 형식 그러지 `string`합니다.

보간된 문자열의 형식이 `System.IFormattable` 또는 `System.FormattableString`, 의미에 대 한 호출을는 `System.Runtime.CompilerServices.FormattableStringFactory.Create`합니다. 형식이 `string`, 식의 의미는 호출 `string.Format`합니다. 두 경우 모두 호출의 인수 목록 형식 문자열 리터럴을 각 보간에 대 한 자리 표시자 및 자리 표시자를 해당 하는 각 식에 대 한 인수로 사용 하 여 구성 됩니다.

형식 문자열 리터럴을 다음과 같이 생성 된 위치 `N` 보간의 수를 *interpolated_string_expression*:

*  경우는 *interpolated_regular_string_whole* 요소나 *interpolated_verbatim_string_whole* 따릅니다는 `$` 형식 문자열 리터럴에 해당 토큰에 서명.
*  그렇지 않은 경우 형식 문자열 리터럴을 이루어져 있습니다. 
   *  첫 번째는 *interpolated_regular_string_start* 또는 *interpolated_verbatim_string_start*
   *  각 숫자에 대 한 다음 `I` 에서 `0` 에 `N-1`: 
      * 소수 표현 `I`
      * 그런 다음 해당 *보간* 에 *constant_expression*, `,` 값의 소수 표현 뒤에 (쉼표)를 *constant_expression*
      * 그런 다음 *interpolated_regular_string_mid*를 *interpolated_regular_string_end*하십시오 *interpolated_verbatim_string_mid* 또는 *interpolated_ verbatim_string_end* 즉시 해당 보간을 수행 합니다.

이후 인수는 단순히 합니다 *식* 에서 합니다 *보간* (있는 경우), 순서로.

TODO: 예.


### <a name="simple-names"></a>단순 이름

A *simple_name* 식별자 형식 인수 목록 뒤에 선택적으로 이루어져 있습니다.

```antlr
simple_name
    : identifier type_argument_list?
    ;
```

A *simple_name* 형식 중 하나는 `I` 또는 양식의 `I<A1,...,Ak>`여기서 `I` 는 단일 식별자 및 `<A1,...,Ak>` 선택적 *type_argument_list*합니다. 없는 경우 *type_argument_list* 가 지정 하는 것이 좋습니다 `K` 0입니다. 합니다 *simple_name* 평가 되 고 다음과 같이 분류 됩니다.

*  경우 `K` 가 0 및 *simple_name* 내에 표시 되는 *블록* 경우에 *블록*의 (바깥쪽 또는 *블록*의) 로컬 변수 선언 공간 ([선언](basic-concepts.md#declarations)) 로컬 변수, 매개 변수 또는 상수 이름이 포함 `I`, 해당 *simple_name* 해당 로컬 변수 참조 매개 변수 또는 상수와 변수 또는 값으로 분류 합니다.
*  경우 `K` 0 및 *simple_name* 제네릭 메서드 선언의 본문 내에 표시 및 해당 선언 이름의 형식 매개 변수를 포함 하는 경우 `I`, 그런 다음 *simple_name*해당 형식 매개 변수를 가리킵니다.
*  각 인스턴스 유형에 대해이 고, 그렇지 `T` ([인스턴스 유형을](classes.md#the-instance-type)), 바로 바깥쪽 형식 선언의 인스턴스 형식을 사용 하 여 시작 하 고 각 바깥쪽 클래스 또는 구조체의 인스턴스 형식을 사용 하 여 계속 합니다. 선언 (있는 경우):
   *  하는 경우 `K` 0 이며 선언의 `T` 이름의 형식 매개 변수가 포함 `I`, 해당 *simple_name* 해당 형식 매개 변수를 가리킵니다.
   *  그렇지 않고 멤버 조회 ([멤버 조회](expressions.md#member-lookup))의 `I` 에서 `T` 사용 하 여 `K` 일치 하는 항목을 생성 하는 형식 인수:
      * 하는 경우 `T` 가 바로 바깥쪽 클래스 또는 구조체 형식의 인스턴스 유형 및 조회 하나를 식별 합니다. 또는 이상의 메서드를 결과 메서드 그룹의 연결 된 인스턴스 식이 있는 `this`합니다. 제네릭 메서드를 호출할 때 사용 되는 형식 인수 목록을 지정 하는 경우 ([메서드 호출](expressions.md#method-invocations)).
      * 그렇지 않은 경우, `T` 이며 바로 바깥쪽 클래스 또는 구조체 형식의 인스턴스 유형을 조회 인스턴스 멤버를 식별 하는 경우 참조는 인스턴스 생성자, 인스턴스 메서드 또는 인스턴스 접근자의 본문 내에서 발생 하는 경우는 결과 멤버 액세스가와 같습니다 ([me](expressions.md#member-access)) 형식의 `this.I`합니다. 만 발생할 수 있습니다 때 `K` 은 0입니다.
      * 그렇지 않으면 결과 멤버 액세스와 동일 ([me](expressions.md#member-access)) 형식의 `T.I` 또는 `T.I<A1,...,Ak>`합니다. 에 대 한 바인딩 시간 오류는 것이 경우에 *simple_name* 인스턴스 멤버를 가리킵니다.

*  각 네임 스페이스이 고, 그렇지 `N`네임 스페이스를 사용 하 여 시작 합니다 *simple_name* 발생 하는 다음 단계는 각 바깥쪽 네임 스페이스 (있는 경우) 및 전역 네임 스페이스를 사용 하 여 종료를 사용 하 여 계속 엔터티를 찾을 때까지 계산 합니다.
   *  경우 `K` 가 0 및 `I` 네임 스페이스의 이름은 `N`, 다음:
      * 경우 위치 위치는 *simple_name* 발생에 대 한 네임 스페이스 선언을 괄호로 묶여 `N` 네임 스페이스 선언을 포함 하는 *extern_alias_directive* 또는  *using_alias_directive* 이름을 연결 하는 `I` 형식 또는 네임 스페이스를 사용 하 여 해당 *simple_name* 모호 하 고 컴파일 시간 오류가 발생 합니다.
      * 이 고, 그렇지 합니다 *simple_name* 라는 네임 스페이스 참조 `I` 에서 `N`합니다.
   *  그렇지 않은 경우, `N` 이름의 액세스할 수 있는 형식이 포함 되어 `I` 및 `K` 다음 매개 변수를 입력 합니다.
      * 하는 경우 `K` 0 및 위치는 여기서는 *simple_name* 발생에 대 한 네임 스페이스 선언을 괄호로 묶여 `N` 네임 스페이스 선언을 포함 하 고는 *extern_alias_directive*또는 *using_alias_directive* 이름을 연결 하는 `I` 형식 또는 네임 스페이스를 사용 하 여 해당 *simple_name* 모호 하 고 컴파일 시간 오류가 발생 합니다.
      * 그렇지 않은 경우는 *namespace_or_type_name* 지정 된 형식 인수를 사용 하 여 생성 된 형식을 참조 합니다.
   *  그렇지 않은 경우, 위치 여기서 합니다 *simple_name* 발생에 대 한 네임 스페이스 선언을 괄호로 묶여 `N`:
      * 하는 경우 `K` 이 0이 고 네임 스페이스 선언에는 *extern_alias_directive* 또는 *using_alias_directive* 이름을 연결 하는 `I` 가져온된 네임 스페이스를 사용 하 여 또는 형식, 해당 *simple_name* 해당 네임 스페이스 또는 형식을 가리킵니다.
      * 네임 스페이스 및 형식 선언에서 가져온 경우는 *using_namespace_directive*s 및 *using_static_directive*네임 스페이스 선언 중 하나만 액세스할 수 있는 형식을 포함 하거나 에서 확장 되지 않은 정적 멤버 이름의 `I` 하 고 `K` 매개 변수를 입력 하면 *simple_name* 해당 형식 또는 지정 된 형식 인수를 사용 하 여 생성 하는 멤버를 가리킵니다.
      * 가져온 네임 스페이스 및 형식 그러지 합니다 *using_namespace_directive*둘 이상의 액세스할 수 있는 형식을 또는 이름의 확장 메서드가 아닌 정적 멤버의 네임 스페이스 선언 포함 `I` 및`K` 매개 변수를 입력 하면 *simple_name* 모호 합니다. 오류가 발생 합니다.

   이 단계는 정확 하 게 병렬 처리 하는 단계는 해당 하는 *namespace_or_type_name* ([Namespace 및 형식 이름](basic-concepts.md#namespace-and-type-names)).

*  이 고, 그렇지 합니다 *simple_name* 가 정의 되지 않은 하 고 컴파일 시간 오류가 발생 합니다.


### <a name="parenthesized-expressions"></a>괄호로 묶인 식

*parenthesized_expression* 이루어져는 *식* 괄호로 묶습니다.

```antlr
parenthesized_expression
    : '(' expression ')'
    ;
```

A *parenthesized_expression* 평가 하 여 평가 되는 *식* 괄호 안에 합니다. 경우는 *식* 괄호 안에 나타냅니다 네임 스페이스 또는 형식에는 컴파일 타임 오류가 발생 합니다. 이 고, 그렇지의 결과 *parenthesized_expression* 포함된 된 계산의 결과인 *식*합니다.

### <a name="member-access"></a>멤버 액세스

A *member_access* 이루어져 있습니다를 *primary_expression*, *predefined_type*, 또는 *qualified_alias_member*"뒤,`.`"토큰, 뒤에 *식별자*뒤에 선택적으로,는 *type_argument_list*합니다.

```antlr
member_access
    : primary_expression '.' identifier type_argument_list?
    | predefined_type '.' identifier type_argument_list?
    | qualified_alias_member '.' identifier
    ;

predefined_type
    : 'bool'   | 'byte'  | 'char'  | 'decimal' | 'double' | 'float' | 'int' | 'long'
    | 'object' | 'sbyte' | 'short' | 'string'  | 'uint'   | 'ulong' | 'ushort'
    ;
```

합니다 *qualified_alias_member* 프로덕션에 정의 된 [Namespace 별칭 한정자](namespaces.md#namespace-alias-qualifiers)합니다.

A *member_access* 형식 중 하나는 `E.I` 또는 양식의 `E.I<A1, ..., Ak>`여기서 `E` 은 기본 식 `I` 는 단일 식별자 및 `<A1, ..., Ak>` 선택적  *type_argument_list*합니다. 없는 경우 *type_argument_list* 가 지정 하는 것이 좋습니다 `K` 0입니다.

A *member_access* 사용 하 여를 *primary_expression* 형식의 `dynamic` 동적으로 바인딩된 ([동적 바인딩](expressions.md#dynamic-binding)). 컴파일러가 형식의 속성 액세스로 멤버 액세스를 분류 하는 예제의 `dynamic`합니다. 의미를 확인 하려면 아래의 규칙 합니다 *member_access* 런타임의 컴파일 타임 형식 대신 런타임 형식 사용 시 적용 되는 *primary_expression*합니다. 이 런타임 분류 메서드 그룹을 발생 시키는 경우 멤버 액세스 해야 합니다 *primary_expression* 의 *invocation_expression*합니다.

합니다 *member_access* 평가 되 고 다음과 같이 분류 됩니다.

*  하는 경우 `K` 가 0 및 `E` 네임 스페이스 및 `E` 이름의 중첩된 된 네임 스페이스를 포함 `I`, 결과 해당 네임 스페이스입니다.
*  그렇지 `E` 네임 스페이스 및 `E` 이름의 액세스할 수 있는 형식이 포함 되어 `I` 및 `K` 결과 지정 된 형식 인수를 사용 하 여 생성 된 해당 형식 매개 변수를 입력 합니다.
*  경우 `E` 되는 *predefined_type* 또는 *primary_expression* 경우 형식으로 분류 `E` 형식 매개 변수가 아닌 경우 멤버 조회 ([멤버 조회](expressions.md#member-lookup)) `I` 에 `E` 사용 하 여 `K` 형식 매개 변수에 일치 하는 항목을 다음 생성 `E.I` 평가 되 고 다음과 같이 분류 됩니다.
   *  경우 `I` 결과 지정 된 형식 인수를 사용 하 여 생성 하는 형식임을 유형을 식별 합니다.
   *  경우 `I` 결과 연결 된 인스턴스 식이 없는 메서드 그룹을 하나 이상의 메서드를 식별 합니다. 제네릭 메서드를 호출할 때 사용 되는 형식 인수 목록을 지정 하는 경우 ([메서드 호출](expressions.md#method-invocations)).
   *  경우 `I` 식별 하는 `static` 속성인 결과 연결 된 인스턴스 식이 없는 속성 액세스 합니다.
   *  하는 경우 `I` 식별 하는 `static` 필드:
      * 필드가 `readonly` 참조를 클래스 또는 구조체 필드 선언 되는 정적 생성자 외부에서 발생 하 고 결과 값, 즉 정적 필드의 값은 `I` 에서 `E`합니다.
      * 결과 변수, 즉 정적 필드가 고, 그렇지 `I` 에서 `E`합니다.
   *  하는 경우 `I` 식별 하는 `static` 이벤트:
      * 참조를 클래스 또는 구조체는 이벤트 선언 되 고 없이 선언 된 이벤트 내에서 발생 하는 경우 *event_accessor_declarations* ([이벤트](classes.md#events)), 다음 `E.I` 정확 하 게 처리 처럼 `I` 된 정적 필드입니다.
      * 그렇지 않으면 연결 된 인스턴스 식이 없는 이벤트 액세스 됩니다.
   *  경우 `I` 결과 값, 즉 해당 상수 값을 사용 하는 상수를 식별 합니다.
    * 경우 `I` 결과 값, 즉 해당 열거형 멤버의 값은 열거형 멤버를 식별 합니다.
    * 그렇지 않으면 `E.I` 는 잘못 된 멤버 참조 이며 컴파일 타임 오류가 발생 합니다.
*  하는 경우 `E` 속성 액세스, 인덱서 액세스, 변수 또는 값의 형식이 `T`, 및 멤버 조회 ([멤버 조회](expressions.md#member-lookup))의 `I` 에서 `T` 사용 하 여 `K` 형식 인수 그런 다음 일치 하는 항목을 생성 `E.I` 평가 되 고 다음과 같이 분류 됩니다.
   *  첫째, `E` 속성 또는 인덱서 액세스 속성의 값이 또는 인덱서 액세스 ([식의 값](expressions.md#values-of-expressions)) 및 `E` 는 값으로 다시 분류 됩니다.
   *  하는 경우 `I` 결과 메서드 그룹의 연결 된 인스턴스 식이 있는 하나 이상의 메서드를 식별 `E`합니다. 제네릭 메서드를 호출할 때 사용 되는 형식 인수 목록을 지정 하는 경우 ([메서드 호출](expressions.md#method-invocations)).
   *  경우 `I` 인스턴스 속성을 식별 합니다.
      * 경우 `E` 됩니다 `this`를 `I` 는 자동으로 구현 된 속성을 식별 ([자동으로 구현 된 속성](classes.md#automatically-implemented-properties)), setter 및 참조에 대 한 인스턴스 생성자 내에서 발생 하지 않고는 클래스 또는 구조체 형식인 `T`, 결과 변수, 즉 제공한 auto 속성에 대 한 숨겨진된 지원 필드 `I` 인스턴스의 `T` 여 `this`입니다.
      * 그렇지 않으면 결과 속성 액세스의 연결 된 인스턴스 식이 있는 `E`합니다.
   *  경우 `T` 되는 *class_type* 및 `I` 식별 하는 인스턴스 필드 *class_type*:
      * 경우 값 `E` 됩니다 `null`는 `System.NullReferenceException` throw 됩니다.
      * 필드가 그러지 `readonly` 참조, 필드 선언 되는 클래스의 인스턴스 생성자 외부에서 발생 하 고 결과 값, 필드의 값 즉 `I` 참조 하는 개체에서 `E`합니다.
      * 결과 변수, 즉 필드가 고, 그렇지 `I` 에서 참조 하는 개체가 `E`합니다.
   *  경우 `T` 되는 *struct_type* 및 `I` 식별 하는 인스턴스 필드 *struct_type*:
      * 하는 경우 `E` 값인 경우 필드 이면 `readonly` 참조 필드 선언 되는 구조체의 인스턴스 생성자 외부에서 발생 하 고 결과 값, 필드의 값 즉 `I` 제공한 구조체 인스턴스 `E`.
      * 결과 변수, 즉 필드가 고, 그렇지 `I` 제공한 구조체 인스턴스의 `E`합니다.
   *  경우 `I` 인스턴스 이벤트를 식별 합니다.
      * 참조를 클래스 또는 구조체는 이벤트 선언 되 고 없이 선언 된 이벤트 내에서 발생 하는 경우 *event_accessor_declarations* ([이벤트](classes.md#events)), 참조로 발생 하지 않습니다는 왼쪽에 있는 `+=` 또는 `-=` 연산자를 한 다음 `E.I` 정확 하 게 처리 됩니다 처럼 `I` 인스턴스 필드를 합니다.
      * 그렇지 않으면 결과의 연결 된 인스턴스 식이 있는 이벤트 액세스가 `E`합니다.
*  처리 하려고 할이 고, 그렇지 `E.I` 확장 메서드 호출으로 ([확장 메서드 호출](expressions.md#extension-method-invocations)). 이 작업이 실패 하면 `E.I` 는 잘못 된 멤버 참조 및 바인딩 시간에 발생 합니다.

#### <a name="identical-simple-names-and-type-names"></a>동일한 단순 이름 및 형식 이름

형태의 멤버 액세스에서 `E.I`이면 `E` 는 단일 식별자 경우의 의미 `E` 으로 *simple_name* ([단순 이름](expressions.md#simple-names)) 상수, 필드, 속성 지역 변수 또는의 의미와 동일한 형식 매개 변수 `E` 으로 *type_name* ([Namespace 및 형식 이름](basic-concepts.md#namespace-and-type-names)), 다음의 두 가지 의미 `E` 됩니다 사용할 수 있습니다. 두 가지 의미 `E.I` 는 이후 모호 하지 않습니다 `I` 형식의 멤버를 반드시 해야 `E` 두 경우 모두 합니다. 즉, 규칙 단순히 액세스를 허용 하 고 정적 멤버의 중첩된 형식 `E` 컴파일 시간 오류는이 고, 그렇지가 발생 합니다. 예를 들어:
```csharp
struct Color
{
    public static readonly Color White = new Color(...);
    public static readonly Color Black = new Color(...);

    public Color Complement() {...}
}

class A
{
    public Color Color;                // Field Color of type Color

    void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }

    static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
```

#### <a name="grammar-ambiguities"></a>문법 모호성

에 대 한 프로덕션 *simple_name* ([단순 이름](expressions.md#simple-names)) 및 *member_access* ([멤버 액세스](expressions.md#member-access))의 모호성을 낼 수 있습니다는 식 문법입니다. 예를 들어 문:
```
F(G<A,B>(7));
```
에 대 한 호출으로 해석 될 수 있었습니다 `F` 두 개의 인수를 사용 하 여 `G < A` 및 `B > (7)`합니다. 또는 호출으로 해석 될 수 있었습니다 `F` 제네릭 메서드를 호출은 하나의 인수를 사용 하 여 `G` 두 개의 형식 인수 및 일반 인수 하나를 사용 하 여 합니다.

경우 일련의 토큰으로 구문 분석할 수 (컨텍스트에서)를 *simple_name* ([단순 이름](expressions.md#simple-names)), *member_access* ([멤버 액세스](expressions.md#member-access)), 또는 *pointer_member_access* ([포인터 멤버 액세스](unsafe-code.md#pointer-member-access))로 끝나는 *type_argument_list* ([형식 인수](types.md#type-arguments)), 토큰 바로 뒤에 닫는 `>` 토큰을 검사 합니다. 중 하나인 경우
```csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```
그런 다음 *type_argument_list* 의 일부로 유지 됩니다 합니다 *simple_name*에 *member_access* 또는 *pointer_member_access* 및 토큰 시퀀스의 가능한 다른 구문 분석 삭제 됩니다. 그렇지 않은 경우는 *type_argument_list* 의 일부로 간주 되지 않습니다는 *simple_name*, *member_access* 또는 *pointer_member_access*토큰 시퀀스의 다른 가능한 parse 없는 경우에, 합니다. 구문 분석할 때 이러한 규칙은 하지는 적용을 *type_argument_list* 에 *namespace_or_type_name* ([Namespace 및 형식 이름](basic-concepts.md#namespace-and-type-names)). 다음 문은
```csharp
F(G<A,B>(7));
```
이 규칙에 따라 해석에 대 한 호출으로 `F` 제네릭 메서드를 호출은 하나의 인수를 사용 하 여 `G` 두 개의 형식 인수 및 일반 인수 하나를 사용 하 여 합니다. 문
```csharp
F(G < A, B > 7);
F(G < A, B >> 7);
```
각로 해석 됩니다에 대 한 호출 `F` 두 인수를 사용 합니다. 다음 문은
```csharp
x = F < A > +y;
```
문이 작성 되었습니다 했습니다 처럼를 보다 작음 연산자, 연산자 및 단항 더하기 연산자 보다 큰로 해석 됩니다 `x = (F < A) > (+y)`을 대신으로 *simple_name* 사용 하 여를 *type_argument_list* 이진 더하기 연산자 뒤에 있습니다. 문에서
```csharp
x = y is C<T> + z;
```
토큰 `C<T>` 로 해석 되는 *namespace_or_type_name* 사용 하 여를 *type_argument_list*합니다.

### <a name="invocation-expressions"></a>호출 식

*invocation_expression* 메서드를 호출 하는 데 사용 됩니다.

```antlr
invocation_expression
    : primary_expression '(' argument_list? ')'
    ;
```

*invocation_expression* 동적으로 바인딩된 ([동적 바인딩](expressions.md#dynamic-binding)) 다음 중 하나 이상 보유 하는 경우:

* 합니다 *primary_expression* 컴파일 시간 형식이 `dynamic`합니다.
* 선택적 인수가 하나 이상 *argument_list* 컴파일 시간 형식이 `dynamic` 하며 *primary_expression* 대리자 형식이 없습니다.

이 경우 컴파일러 분류 합니다 *invocation_expression* 형식의 값으로 `dynamic`입니다. 의미를 확인 하려면 아래의 규칙 합니다 *invocation_expression* 런타임에, 런타임 형식의의 컴파일 타임 형식 대신 사용 하 여 적용 되는 *primary_expression* 및 컴파일 타임 형식 인수 `dynamic`합니다. 경우는 *primary_expression* 컴파일 시간 형식이 없습니다 `dynamic`, 메서드 호출에 설명 된 대로 제한 된 컴파일 시간 검사를 거칩니다 그런 다음 [컴파일 타임 검사 동적 오버 로드 확인 ](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

합니다 *primary_expression* 의 *invocation_expression* 메서드 그룹 또는 값 이어야 합니다는 *delegate_type*합니다. 경우는 *primary_expression* 그룹인 메서드는 *invocation_expression* 은 메서드 호출 ([메서드 호출](expressions.md#method-invocations)). 경우는 *primary_expression* 의 값이를 *delegate_type*의 *invocation_expression* 은 대리자 호출 ([대리자 호출](expressions.md#delegate-invocations)). 경우는 *primary_expression* 이 메서드 그룹도 아니고 값을 *delegate_type*, 바인딩 시간 오류가 발생 하는 합니다.

선택적 *argument_list* ([인수 목록](expressions.md#argument-lists)) 메서드의 매개 변수 값 또는 변수 참조를 제공 합니다.

평가 결과 *invocation_expression* 다음과 같이 분류 됩니다.

*  경우는 *invocation_expression* 메서드 또는 대리자를 반환 하는 호출 `void`, 결과 아무 작업도 수행 합니다. 컨텍스트에서만에서 대체가 아무로 분류 되는 식을 *statement_expression* ([식 문은](statements.md#expression-statements)) 또는 본문을 *lambda_expression*([익명 함수 식](expressions.md#anonymous-function-expressions)). 그렇지 않으면 바인딩 시간 오류를 발생합니다.
*  그렇지 않으면 결과 메서드 또는 대리자를 반환한 형식의 값입니다.

#### <a name="method-invocations"></a>메서드 호출

메서드 호출에 대 한 합니다 *primary_expression* 의 합니다 *invocation_expression* 메서드 그룹 이어야 합니다. 메서드 그룹에는 하나의 메서드를 호출 하거나 호출할 특정 메서드를 선택할 수 있는 오버 로드 된 메서드 집합을 식별 합니다. 후자의 경우에 호출 하 고 특정 메서드의 결정은 컨텍스트를 기반으로 인수 형식에서 제공 합니다 *argument_list*합니다.

형식의 메서드 호출을 처리 하는 바인딩 시간 `M(A)`, 여기서 `M` 그룹인 메서드 (포함 될 수도 있습니다는 *type_argument_list*), 및 `A` 선택적 *argument_ 목록*, 다음 단계로 구성 됩니다.

*  메서드 호출에 대 한 후보 메서드 집합이 생성 됩니다. 각 메서드에 대 한 `F` 메서드 그룹과 연결 된 `M`:
   *  하는 경우 `F` 제네릭이 아닌 `F` 후보 경우:
      * `M` 형식 인수 목록이 없는 및
      * `F` 기준으로 적용 됩니다 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)).
   *  하는 경우 `F` 제네릭인 및 `M` 없습니다 형식 인수 목록이 `F` 후보 경우:
      * 형식 유추 ([형식 유추](expressions.md#type-inference))에 성공 하면 호출에 대해 형식 인수 목록이 유추 및
      * F의 모든 생성 된 형식 매개 변수 목록에서 해당 제약 조건을 충족할 유추 된 형식 인수가 해당 메서드 형식 매개 변수를 대체 되 면 ([제약 조건을 만족](types.md#satisfying-constraints)), 및 매개 변수 목록이 `F` 기준으로 적용 됩니다 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)).
   *  하는 경우 `F` 제네릭인 및 `M` 형식 인수 목록을 포함 `F` 후보 경우:
      * `F` 에 형식 인수 목록에 제공 된 동일한 개수의 메서드 형식 매개 변수 및
      * F의 모든 생성 된 형식 매개 변수 목록에서 해당 제약 조건을 충족할 형식 인수를 해당 메서드 형식 매개 변수를 대체 되 면 ([제약 조건을 만족](types.md#satisfying-constraints)), 및 매개 변수 목록이 `F` 기준으로 적용 됩니다 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)).
*  후보 메서드 집합을 가장 많이 파생 된 형식에서 메서드만 포함 하도록 줄어듭니다: 각 메서드에 대 한 `C.F` 집합에 있는 `C` 는 형식인 메서드 `F` 기본형식에서선언된모든메서드가선언된`C`집합에서 제거 됩니다. 또한 경우 `C` 이외의 클래스 형식인 `object`, 인터페이스 형식에 선언 된 모든 메서드 집합에서 제거 됩니다. (이 두 번째 규칙만에 영향을 메서드 그룹 결과 형식 매개 변수에 유효한 기본 클래스 개체 이외의 및 설정 하는 비어 있지 않은 유효한 인터페이스 멤버 조회의 경우)
*  중단 된 후 다음 단계를 따라 추가 처리 및 확장 메서드 호출으로 호출을 처리 하려고 할 대신 후보 메서드 결과 집합이 비어 있으면 ([확장 메서드 호출](expressions.md#extension-method-invocations)). 이 작업이 실패 하면, 해당 메서드가 없는 존재 하 고 바인딩 시간에 발생 합니다.
*  후보는 메서드의 집합의 최상의 방법을의 오버 로드 확인 규칙을 사용 하 여 식별 됩니다 [오버 로드 확인](expressions.md#overload-resolution)합니다. 단일 최상의 메서드를 식별할 수 없으면, 메서드 호출이 모호 합니다 및 바인딩 시간에 발생 합니다. 오버 로드 확인을 수행할 때 제네릭 메서드의 매개 변수를 해당 메서드 형식 매개 변수에 대해 형식 인수 (제공 되거나 유추 된)를 대체 한 후 간주 됩니다.
*  선택한 모범 메서드의 마지막 유효성 검사가 수행 됩니다.
   * 메서드를 메서드 그룹의 컨텍스트에서 유효성을 검사: 메서드 그룹에서 했 해야 최상의 방법을 정적 메서드인 경우는 *simple_name* 또는 *member_access* 형식을 통해. 메서드 그룹에서 했 해야 최상의 방법을 인스턴스 메서드인 경우는 *simple_name*, *member_access* 변수 또는 값을 통해 또는 *base_access*합니다. 이러한 요구 사항을 모두 true 인 경우 바인딩 시간 오류를 발생 합니다.
   * 형식 인수 (제공 되거나 유추)는 가장 좋은 방법은 제네릭 메서드 이면 제약 조건을 검사할지 ([제약 조건을 만족](types.md#satisfying-constraints)) 제네릭 메서드의 선언 합니다. 형식 인수가 형식 매개 변수에 해당 제약 조건은 개입니다를 충족 하지 않으면 바인딩 시간 오류가 발생 합니다.

실제 런타임 호출에서 설명 하는 함수 멤버 호출 규칙에 따라 처리 메서드를 선택 하 고 위의 단계에 따라 바인딩 시간에 유효성을 검사 된 후 [컴파일 타임 검사 동적 오버 로드 확인 ](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

위에서 설명한 해결 규칙을 직관적은 다음과 같습니다: 메서드 호출을 호출 하는 특정 메서드를 찾으려면 메서드 호출에 의해 지정 된 형식을 사용 하 여 시작 하 고 하나 이상의 해당 될 때까지 상속 체인을 진행 합니다. 액세스할 수 있는, 재정의 되지 않는 메서드 선언을 발견 됩니다. 형식 유추를 수행 및 오버 로드 확인에 해당 형식에서 선언 된 해당, 액세스할 수 있는, 재정의 되지 않는 메서드 집합에 고 따라서 선택한 메서드를 호출 합니다. 메서드가 없습니다 있으면 하려고 대신 확장 메서드 호출으로 호출을 처리 합니다.

#### <a name="extension-method-invocations"></a>확장 메서드 호출

메서드 호출에서 ([boxed 인스턴스에서 호출](expressions.md#invocations-on-boxed-instances)) 형식 중 하나
```csharp
expr . identifier ( )

expr . identifier ( args )

expr . identifier < typeargs > ( )

expr . identifier < typeargs > ( args )
```
해당 메서드가 없는 찾으면, 호출의 일반적인 처리는 확장 메서드 호출 구문을 처리 시도가 이루어집니다. 하는 경우 *expr* 또는 합니다 *args* 컴파일 시간 형식이 `dynamic`, 확장 메서드는 적용 되지 것입니다.

가장 찾을 목적은 *type_name* `C`해당 정적 메서드 호출이 수행 될 수 있도록 합니다.
```csharp
C . identifier ( expr )

C . identifier ( expr , args )

C . identifier < typeargs > ( expr )

C . identifier < typeargs > ( expr , args )
```

확장 메서드 `Ci.Mj` 됩니다 ***적격*** 경우:

*  `Ci` 제네릭이 아닌 비중첩 클래스
*  이름을 `Mj` 는 *식별자*
*  `Mj` 액세스할 수 있고 위에 표시 된 대로 정적 메서드로 인수에 적용 하는 경우에 적용
*  암시적 id, 참조 또는 boxing 변환이 존재 *expr* 의 첫 번째 매개 변수 형식으로 `Mj`입니다.

검색 `C` 다음과 같이 진행 됩니다.

*  가장 가까운 바깥쪽 네임 스페이스 선언, 각 바깥쪽 네임 스페이스 선언을 사용 하 여 계속 해 서 포함 된 컴파일 단위에 끝나는 연속 된 시도 확장 메서드의 후보 집합을 찾기 위해 수행 됩니다.
   * 제네릭이 아닌 형식을 선언에 지정 된 네임 스페이스 또는 컴파일 단위의 경우 직접 포함 `Ci` 적합 한 확장 메서드를 사용 하 여 `Mj`, 이러한 확장 메서드 집합을 후보 집합이 됩니다.
   * 경우 형식 `Ci` 에서 가져온 *using_static_declarations* 에서 가져온 네임 스페이스에서 선언 된 직접 *using_namespace_directive*지정 된 네임 스페이스 또는 컴파일 단위에 직접 s 적합 한 확장 메서드를 포함 `Mj`, 이러한 확장 메서드 집합을 후보 집합이 됩니다.
*  후보 집합이 없는 모든 바깥쪽 네임 스페이스 선언 또는 컴파일 단위에 컴파일 타임 오류가 발생 합니다.
*  에 설명 된 대로 설정 후보를 오버 로드 확인이 적용 하는 그렇지 않은 경우 ([오버 로드 확인](expressions.md#overload-resolution)). 최상의 방법에는 여러 있으면 컴파일 타임 오류가 발생 합니다.
*  `C` 가장 좋은 방법은 확장 메서드로 선언 된 형식이입니다.

사용 하 여 `C` 대상으로 메서드 호출은 정적 메서드 호출으로 처리 한 다음 ([동적 오버 로드 확인 검사 하는 컴파일 타임](expressions.md#compile-time-checking-of-dynamic-overload-resolution)).

인스턴스 메서드와 확장 메서드가 보다 우선적으로 적용 하는 내부 네임 스페이스 선언에서 사용할 수 있는 확장 메서드 우선 외부 네임 스페이스 선언 및 해당 확장에서 사용할 수 있는 확장 메서드, 이전 규칙 의미 네임 스페이스에 직접 선언 된 메서드를 사용 하 여 동일한 네임 스페이스를 가져올 확장 메서드 보다 우선적으로 적용 네임 스페이스 지시문입니다. 예를 들어:
```csharp
public static class E
{
    public static void F(this object obj, int i) { }

    public static void F(this object obj, string s) { }
}

class A { }

class B
{
    public void F(int i) { }
}

class C
{
    public void F(object obj) { }
}

class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F("hello");        // E.F(object, string)

        b.F(1);              // B.F(int)
        b.F("hello");        // E.F(object, string)

        c.F(1);              // C.F(object)
        c.F("hello");        // C.F(object)
    }
}
```

예에서 `B`의 메서드는 첫 번째 확장 메서드인 보다 우선 및 `C`의 메서드 두 확장 메서드보다 우선 합니다.

```csharp
public static class C
{
    public static void F(this int i) { Console.WriteLine("C.F({0})", i); }
    public static void G(this int i) { Console.WriteLine("C.G({0})", i); }
    public static void H(this int i) { Console.WriteLine("C.H({0})", i); }
}

namespace N1
{
    public static class D
    {
        public static void F(this int i) { Console.WriteLine("D.F({0})", i); }
        public static void G(this int i) { Console.WriteLine("D.G({0})", i); }
    }
}

namespace N2
{
    using N1;

    public static class E
    {
        public static void F(this int i) { Console.WriteLine("E.F({0})", i); }
    }

    class Test
    {
        static void Main(string[] args)
        {
            1.F();
            2.G();
            3.H();
        }
    }
}
```

이 예제의 출력은 다음과 같습니다.
```
E.F(1)
D.G(2)
C.H(3)
```
`D.G` 우선 `C.G`, 및 `E.F` 둘 다 보다 우선 `D.F` 및 `C.F`합니다.

#### <a name="delegate-invocations"></a>대리자 호출

대리자 호출에 대 한 합니다 *primary_expression* 의 *invocation_expression* 의 값 이어야 합니다는 *delegate_type*합니다. 또한 고려 합니다 *delegate_type* 같은 매개 변수 목록 사용 하 여 함수 멤버 여야 합니다 *delegate_type*, *delegate_type* 적용 (이어야 합니다 [적용 가능한 함수 멤버](expressions.md#applicable-function-member))을 기준으로 합니다 *argument_list* 의 합니다 *invocation_expression*합니다.

폼의 대리자 호출을 처리 하는 런타임 `D(A)`, 여기서 `D` 는 *primary_expression* 의 *delegate_type* 및 `A` 되는 선택적 *argument_list*, 다음 단계로 구성 됩니다.

*  `D` 평가 됩니다. 이 평가 예외를 발생 시키는 경우에 추가 단계 없이 실행 됩니다.
*  변수의 `D` 유효한 것으로 확인 됩니다. 경우 값 `D` 은 `null`, `System.NullReferenceException` throw 되 고 추가 단계 없이 실행 됩니다.
*  그렇지 않으면 `D` 대리자 인스턴스에 대 한 참조입니다. 멤버 호출 함수 ([컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 각 대리자의 호출 목록에서 호출할 엔터티에 대해 수행 됩니다. 구성 된 인스턴스 및 인스턴스 메서드를 호출할 엔터티에 대해 호출에 대 한 인스턴스는 호출 가능 엔터티에 포함 된 인스턴스입니다.

### <a name="element-access"></a>요소 액세스

*element_access* 이루어져 있습니다를 *primary_no_array_creation_expression*뒤를 "`[`" 토큰, 뒤에 *argument_list*뒤를 " `]`"토큰입니다. 합니다 *argument_list* 하나 이상의 구성 *인수*s, 쉼표로 구분 합니다.

```antlr
element_access
    : primary_no_array_creation_expression '[' expression_list ']'
    ;
```

합니다 *argument_list* 의 *element_access* 포함 되지 `ref` 또는 `out` 인수입니다.

*element_access* 동적으로 바인딩된 ([동적 바인딩](expressions.md#dynamic-binding)) 다음 중 하나 이상 보유 하는 경우:

* 합니다 *primary_no_array_creation_expression* 컴파일 시간 형식이 `dynamic`합니다.
* 하나 이상의 식입니다를 *argument_list* 컴파일 시간 형식이 `dynamic` 하며 *primary_no_array_creation_expression* 배열 형식이 없습니다.

이 경우 컴파일러 분류 합니다 *element_access* 형식의 값으로 `dynamic`입니다. 의미를 확인 하려면 아래의 규칙 합니다 *element_access* 런타임에, 런타임 형식의의 컴파일 타임 형식 대신 사용 하 여 적용 되는 *primary_no_array_creation_expression*하 고 *argument_list* 식은 컴파일 시간 형식이 `dynamic`합니다. 경우는 *primary_no_array_creation_expression* 컴파일 시간 형식이 없습니다 `dynamic`, 요소 액세스에 설명 된 대로 제한 된 컴파일 시간 검사를 거칩니다 그런 다음 [컴파일 타임 동적 검사 오버 로드 확인](expressions.md#compile-time-checking-of-dynamic-overload-resolution)합니다.

경우는 *primary_no_array_creation_expression* 의 *element_access* 의 값이를 *array_type*, *element_access* 는 배열 액세스 ([액세스 배열](expressions.md#array-access)). 이 고, 그렇지 합니다 *primary_no_array_creation_expression* 변수나 클래스, 구조체 또는 인터페이스 형식에 하나 이상의 인덱서 멤버가 있는 경우에 값 이어야 합니다 합니다 *element_access* 는 인덱서 액세스 ([인덱서 액세스](expressions.md#indexer-access)).

#### <a name="array-access"></a>배열 액세스

배열 액세스의 경우는 *primary_no_array_creation_expression* 의 *element_access* 의 값 이어야 합니다는 *array_type*합니다. 또한 합니다 *argument_list* 배열을 액세스가 명명 된 인수를 포함 하도록 허용 되지 않습니다. 식의 수를 *argument_list* 의 순위와 동일 해야 합니다 *array_type*, 각 식 형식 이어야 하 고 `int`, `uint`, `long`, `ulong`, 또는 이러한 형식 중 하나 이상의 암시적으로 변환할 수 있어야 합니다.

Namely에서 절입니다의 값으로 선택 배열 요소 배열의 요소 형식의 변수가 배열 액세스 평가의 결과 *argument_list*합니다.

형식의 배열 액세스를 처리 하는 런타임 `P[A]`여기서 `P` 되는 *primary_no_array_creation_expression* 의 *array_type* 및 `A` 되는 *argument_list*, 다음 단계로 구성 됩니다.

*  `P` 평가 됩니다. 이 평가 예외를 발생 시키는 경우에 추가 단계 없이 실행 됩니다.
*  인덱스 식의 *argument_list* 왼쪽에서 오른쪽 순서로 평가 됩니다. 각 인덱스 식의 암시적 변환이 평가 ([암시적 변환을](conversions.md#implicit-conversions)) 다음 형식 중 하나로 수행 됩니다: `int`, `uint`에 `long`, `ulong`합니다. 암시적 변환이 존재 하는이 목록의 첫 번째 형식이 선택 됩니다. 예를 들어 된 인덱스 식 형식의 경우 `short` 으로 암시적 변환이 다음 `int` 에서 암시적 변환이 수행 됩니다 `short` 를 `int` 들어오고 `short` 를 `long` 가능 합니다. 인덱스 식의 후속 암시적 변환 평가 예외를 발생 시키는 경우 다음 인덱스 식은 더 이상 계산 되 고 단계를 실행 하는 더 이상.
*  변수의 `P` 유효한 것으로 확인 됩니다. 경우 값 `P` 은 `null`, `System.NullReferenceException` throw 되 고 추가 단계 없이 실행 됩니다.
*  각 식의 값을 *argument_list* 과 비교 하는 각 차원에서 참조 하는 배열 인스턴스의 실제 범위는 `P`합니다. 하나 이상의 값 범위를 벗어나는 경우는 `System.IndexOutOfRangeException` throw 되 고 추가 단계 없이 실행 됩니다.
*  인덱스 식이 지정 된 배열 요소의 위치를 계산 하 고이 위치 배열 액세스의 결과가 됩니다.

#### <a name="indexer-access"></a>인덱서 액세스

인덱서 액세스의 경우는 *primary_no_array_creation_expression* 의 합니다 *element_access* 변수 또는 값 클래스, 구조체 또는 인터페이스 형식 이어야 합니다이 형식이 하나 이상 구현 해야 하 고 기준으로 적용 되는 인덱서를 *argument_list* 의 합니다 *element_access*합니다.

형식의 인덱서 액세스를 처리 하는 바인딩 시간 `P[A]`여기서 `P` 되는 *primary_no_array_creation_expression* 클래스, 구조체 또는 인터페이스 형식입니다 `T`, 및 `A` 는 *argument_list*, 다음 단계로 구성 됩니다.

*  집합에서 제공 하는 인덱서의 `T` 생성 됩니다. 집합은 구성에서 선언 된 모든 인덱서의 `T` 또는 기본 형식의 `T` 없는 `override` 선언과 현재 컨텍스트에서 액세스할 수 있습니다 ([멤버 액세스](basic-concepts.md#member-access)).
*  집합을 다른 인덱서에서 숨겨지지 않은 하 고 해당 되는 이러한 인덱서 줄어듭니다. 각 인덱서는 다음 규칙이 적용 됩니다 `S.I` 집합에 있는 `S` 는 형식이 인덱서 `I` 선언:
   * 하는 경우 `I` 기준으로 적용 되지 않습니다 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)), 다음 `I` 집합에서 제거 됩니다.
   * 하는 경우 `I` 기준으로 적용 됩니다 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)), 기본 형식의 모든 인덱서에 선언 `S` 집합에서 제거 됩니다.
   * 하는 경우 `I` 기준으로 적용 됩니다 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)) 및 `S` 이외의 클래스 형식인 `object`, 인터페이스에서 선언 된 모든 인덱서 집합에서 제거 됩니다.
*  후보 인덱서 결과 집합이 비어 있으면 다음 적용 가능한 인덱서가 없습니다 존재 및 바인딩 시간에 발생 합니다.
*  후보 인덱서의 집합의 최상의 인덱서의 오버 로드 확인 규칙을 사용 하 여 식별 됩니다 [오버 로드 확인](expressions.md#overload-resolution)합니다. 가장 하는 단일 인덱서를 식별할 수 없으면, 인덱서 액세스를 모호 하 게 되며 바인딩 시간 오류를 발생 합니다.
*  인덱스 식의 *argument_list* 왼쪽에서 오른쪽 순서로 평가 됩니다. 인덱서 액세스를 처리 하는 결과 인덱서 액세스로 분류 되는 식입니다. 인덱서 액세스 식 참조 하는 위의 단계에서 결정 된 인덱서 있고는 연결 된 인스턴스 식이 `P` 관련된 인수 목록과 `A`합니다.

사용 되는 컨텍스트에 따라 인덱서 액세스 하면 중 호출 된 *get 접근자* 또는 *set 접근자* 인덱서의. 인덱서 액세스는 할당 대상일 경우 합니다 *set 접근자* 새 값을 할당 하기 위해 호출 됩니다 ([단순 할당](expressions.md#simple-assignment)). 다른 모든 경우에는 *get 접근자* 가 현재 값을 얻기 위해 호출 됩니다 ([식의 값](expressions.md#values-of-expressions)).

### <a name="this-access"></a>이 액세스

A *this_access* 예약어 이루어져 `this`합니다.

```antlr
this_access
    : 'this'
    ;
```

*this_access* 에서만 허용 되는 *블록* 인스턴스 생성자, 인스턴스 메서드 또는 인스턴스 접근자입니다. 의미 중 하나 있습니다.

*  때 `this` 에 사용 되는 *primary_expression* 클래스의 인스턴스 생성자, 내 값으로 분류 합니다. 값의 형식은 인스턴스 형식 ([인스턴스 유형을](classes.md#the-instance-type))는 사용 된 하 고 값이 생성 되는 개체에 대 한 참조는 클래스의 합니다.
*  때 `this` 에 사용 되는 *primary_expression* 인스턴스 메서드 또는 클래스의 인스턴스 접근자에서 값으로 분류 합니다. 값의 형식은 인스턴스 형식 ([인스턴스 유형을](classes.md#the-instance-type))는 사용 된 하 고 값이 있는 메서드 또는 접근자가 호출에 대 한 참조는 클래스의 합니다.
*  때 `this` 에 사용 되는 *primary_expression* 구조체의 인스턴스 생성자, 내에서 변수로 분류 합니다. 변수의 형식은 인스턴스 형식 ([인스턴스 유형을](classes.md#the-instance-type))는 사용 된 및 변수 생성 되 고 있는 구조체를 나타내는 구조체의 합니다. 합니다 `this` 동일 하 게 동작 하는 구조체의 인스턴스 생성자의 변수는 `out` 구조체 형식의 매개 변수-특히 인스턴스에 대 한 모든 실행 경로에서 변수를 확실 하 게 할당 해야 함을 의미이 생성자입니다.
*  때 `this` 에 사용 되는 *primary_expression* 인스턴스 메서드 또는 인스턴스 접근자 구조체의에서 변수로 분류 합니다. 변수의 형식은 인스턴스 형식 ([인스턴스 유형을](classes.md#the-instance-type)) 사용량을 발생 하는 구조체의 합니다.
   * 메서드 또는 접근자는 반복기가 하는 경우 ([반복기](classes.md#iterators)), `this` 변수는 메서드 또는 접근자 호출 되었는지와 동일 하 게 동작 구조체를 나타냅니다는 `ref` 구조체 형식의 매개 변수입니다.
   * 메서드 또는 접근자가 반복기는 `this` 변수는 메서드 또는 접근자가 호출 됩니다 및 값 매개 변수는 구조체 형식의 정확히 동일 하 게 동작 하는 구조체의 복사본을 나타냅니다.

이용 `this` 에 *primary_expression* 위에 나열 된 것 이외의 컨텍스트에서 컴파일 시간 오류입니다. 참조할 수는 특히 `this` 또는 정적 메서드를 정적 속성 접근자에는 *variable_initializer* 필드 선언 합니다.

### <a name="base-access"></a>기본 액세스

A *base_access* 예약어 이루어져 `base` 뒤에 하나는 "`.`" 토큰 및 식별자 또는 *argument_list* 대괄호로:

```antlr
base_access
    : 'base' '.' identifier
    | 'base' '[' expression_list ']'
    ;
```

A *base_access* 현재 클래스 또는 구조체에서 비슷한 이름의 멤버가 숨겨져 있는 기본 클래스 멤버에 액세스 하는 데 사용 됩니다. *base_access* 에서만 허용 되는 *블록* 인스턴스 생성자, 인스턴스 메서드 또는 인스턴스 접근자입니다. 때 `base.I` 클래스 또는 구조체에서 발생 `I` 해당 클래스 또는 구조체의 기본 클래스의 멤버를 나타내야 합니다. 마찬가지로, `base[E]` 해당 인덱서는 기본 클래스에 있어야 합니다. 클래스에서 발생 합니다.

바인딩 시 *base_access* 형식의 식을 `base.I` 하 고 `base[E]` 작성 된 것 처럼 정확 하 게 평가 됩니다 `((B)this).I` 하 고 `((B)this)[E]`여기서 `B` 클래스의 기본 클래스인 또는 구문을 발생 하는 구조체입니다. 따라서 `base.I` 및 `base[E]` 에 해당 `this.I` 및 `this[E]`를 제외한 `this` 는 기본 클래스의 인스턴스로 간주 됩니다.

경우는 *base_access* 는 확인에 런타임 시 호출할 멤버 함수는 가상 함수 멤버 (메서드, 속성 또는 인덱서)을 참조 ([컴파일 타임 검사 동적 오버 로드 확인 ](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 변경 됩니다. 가장 많이 파생 된 구현을 찾아 확인 하는 호출 되는 함수 멤버 ([가상 메서드](classes.md#virtual-methods))의 기준으로 하는 함수 멤버 `B` (대신의 런타임 형식에 대해 `this`, 으로 것 기본이 아닌 액세스의 일반적인)입니다. 따라서 내는 `override` 의 `virtual` 함수 멤버를 *base_access* 함수 멤버의 상속된 된 구현 호출에 사용할 수 있습니다. 참조 하는 함수 멤버를 *base_access* 바인딩 시간 오류가 발생 하는 추상 클래스가 됩니다.

### <a name="postfix-increment-and-decrement-operators"></a>후 위 증가 및 감소 연산자

```antlr
post_increment_expression
    : primary_expression '++'
    ;

post_decrement_expression
    : primary_expression '--'
    ;
```

피연산자는 후 위 증가 또는 감소 작업 변수, 속성 액세스 또는 인덱서 액세스로 분류 되는 식 이어야 합니다. 작업의 결과 피연산자와 동일한 형식의 값입니다.

경우는 *primary_expression* 컴파일 시간 형식이 `dynamic` 연산자를 동적으로 바인딩되는 다음 ([동적 바인딩](expressions.md#dynamic-binding)), *post_increment_expression*나 *post_decrement_expression* 컴파일 시간 형식이 `dynamic` 의 런타임 형식을 사용 하 여 런타임 시 다음과 같은 규칙이 적용 됩니다는 *primary_expression*합니다.

피연산자는 후 위 증가 하는 경우 감소 작업은 속성 또는 인덱서 액세스, 속성 또는 인덱서 둘 다 있어야 합니다는 `get` 및 `set` 접근자입니다. 이 경우 바인딩 시간 오류가 발생 합니다.

단항 연산자 오버 로드 확인 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 미리 정의 된 `++` 하 고 `--` 연산자는 다음 형식에 대해 존재: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char` 를 `float`, `double`, `decimal`, 및 열거형 형식입니다. 미리 정의 된 `++` 연산자는 피연산자 및 미리 정의 된에 1을 추가 하 여 생성 한 값을 반환 `--` 연산자는 피연산자에서 1을 뺀 값으로 계산 된 값을 반환 합니다. 에 `checked` 컨텍스트를 결과 형식이 정수 계열 형식 또는 열거형 형식에는이 더하기 또는 빼기의 결과 결과 형식 범위를 벗어나는 경우는 `System.OverflowException` throw 됩니다.

후 위 증가 처리 하는 런타임 또는 폼의 작업 감소 `x++` 또는 `x--` 다음 단계로 구성 됩니다.

*   경우 `x` 변수로로 분류 됩니다.
    * `x` 변수를 생성 하기 위해 평가 됩니다.
    * 변수의 `x` 저장 됩니다.
    * 선택한 연산자의 저장된 된 값을 사용 하 여 호출 `x` 인수로 합니다.
    * 연산자로 반환 되는 값을 평가 하 여 지정 된 위치에 저장 됩니다 `x`합니다.
    * 저장된 된 값의 `x` 연산의 결과가 됩니다.
*   경우 `x` 속성 또는 인덱서에 액세스로 분류 됩니다.
    * 인스턴스 식 (하는 경우 `x` 아닙니다 `static`) 및 인수 목록을 (경우 `x` 인덱서 액세스할)와 연결 된 `x` 평가 결과에서 사용 하는 후속 `get` 및 `set` 접근자 호출입니다.
    * `get` 접근자의 `x` 가 호출 하 고 반환 된 값을 저장 합니다.
    * 선택한 연산자의 저장된 된 값을 사용 하 여 호출 `x` 인수로 합니다.
    * 합니다 `set` 의 접근자 `x` 으로 연산자로 반환 되는 값을 사용 하 여 호출 해당 `value` 인수입니다.
    * 저장된 된 값의 `x` 연산의 결과가 됩니다.

합니다 `++` 하 고 `--` 연산자에도 접두사 표기법 지원 ([전위 증가 및 감소 연산자](expressions.md#prefix-increment-and-decrement-operators)). 일반적으로 결과 `x++` 또는 `x--` 의 값인 `x` 작업 전에 반면 결과인 `++x` 또는 `--x` 의 값인 `x` 작업 후. 두 경우 모두 `x` 작업 후 같은 값을 가집니다.

`operator ++` 또는 `operator --` 구현 후 위 또는 접두사 표기법을 사용 하 여 호출할 수 있습니다. 두 표기법이 대 한 별도 연산자 구현이 하는 것이 불가능 합니다.

### <a name="the-new-operator"></a>new 연산자

`new` 연산자 형식의 새 인스턴스를 만드는 데 사용 됩니다.

세 가지 `new` 식:

*  개체 만들기 식은 클래스 형식 및 값 형식의 새 인스턴스를 만드는 데 사용 됩니다.
*  배열 만들기 식은 배열 형식의 새 인스턴스를 만드는 데 사용 됩니다.
*  대리자 생성 식 형식을 대리자의 새 인스턴스를 만드는 사용 됩니다.

`new` 연산자 형식의 인스턴스를 만들 것을 의미 하지만 반드시 메모리의 동적 할당을 의미 하지는 않습니다. 값 형식의 인스턴스는 주는지 및 없는 동적 할당이 발생 변수 이외의 추가 메모리가 필요 하는 특히 때 `new` 값 형식의 인스턴스를 만드는 데 사용 됩니다.

#### <a name="object-creation-expressions"></a>개체 만들기 식

*object_creation_expression* 의 새 인스턴스를 만드는 데 사용 되는 *class_type* 또는 *value_type*합니다.

```antlr
object_creation_expression
    : 'new' type '(' argument_list? ')' object_or_collection_initializer?
    | 'new' type object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
```

합니다 *형식* 의 *object_creation_expression* 이어야 합니다는 *class_type*, *value_type* 또는 *type_parameter* . 합니다 *형식* 일 수 없습니다는 `abstract` *class_type*합니다.

선택적 *argument_list* ([인수 목록](expressions.md#argument-lists)) 경우에 허용 됩니다는 *형식* 되는 *class_type* 또는 *struct_ 형식*합니다.

개체 생성 식을 생성자 인수 목록을 생략할 수 및 개체 이니셜라이저 또는 컬렉션 이니셜라이저를 포함 하는 제공 된 바깥쪽 괄호입니다. 생성자 인수 목록을 생략 하 고 괄호 빈 인수 목록에 지정 하는 것 같습니다.

먼저 인스턴스 생성자를 처리 하 고 개체 이니셜라이저 (지정된멤버또는요소초기화를처리하는다음개체이니셜라이저또는컬렉션이니셜라이저를포함하는개체생성식처리구성[ 개체 이니셜라이저](expressions.md#object-initializers)) 또는 컬렉션 이니셜라이저 ([컬렉션 이니셜라이저](expressions.md#collection-initializers)).

선택적 인수 중 하나가 되 면 *argument_list* 컴파일 시간 형식이 `dynamic` 하면 *object_creation_expression* 바인딩된 동적으로 ([동적바인딩](expressions.md#dynamic-binding)) 이러한 인수의 런타임 형식을 사용 하 여 런타임 시 다음과 같은 규칙이 적용 됩니다는 *argument_list* 컴파일 타임 형식에 있는 `dynamic`합니다. 에 설명 된 대로 개체 만들기를 제한 된 컴파일 시간 검사를 수행 하는 반면 [컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)합니다.

바인딩 시간 처리를 *object_creation_expression* 형식의 `new T(A)`여기서 `T` 는 *class_type* 또는 *value_type* 및 `A` 선택적 *argument_list*, 다음 단계로 구성 됩니다.

*   하는 경우 `T` 되는 *value_type* 및 `A` 없는:
    * 합니다 *object_creation_expression* 는 기본 생성자 호출 합니다. 결과 *object_creation_expression* 형식의 값은 `T`를 namely에 대 한 기본 값 `T` 에 정의 된 대로 [The System.ValueType 형식](types.md#the-systemvaluetype-type)합니다.
*   그렇지 `T` 되는 *type_parameter* 및 `A` 없는:
    * 값 형식 제약 조건 또는 생성자 제약 조건이 없는 경우 ([형식 매개 변수 제약 조건](classes.md#type-parameter-constraints))에 대 한 지정 된 `T`, 바인딩 시간에 발생 합니다.
    * 결과 *object_creation_expression* 런타임 형식에 바인딩된 형식 매개 변수 값은 해당 형식의 기본 생성자를 호출한 결과로 namely 합니다. 런타임 형식에는 참조 형식 또는 값 형식 수 있습니다.
*   그렇지 않고 `T` 되는 *class_type* 또는 *struct_type*:
    * 하는 경우 `T` 은 `abstract` *class_type*, 컴파일 타임 오류가 발생 합니다.
    * 호출할 인스턴스 생성자의 오버 로드 확인 규칙을 사용 하 여 결정 됩니다 [오버 로드 확인](expressions.md#overload-resolution)합니다. 후보 인스턴스 생성자의 집합은 구성에서 선언 된 모든 액세스 가능한 인스턴스 생성자 `T` 을 기준으로 적용할 수 있는 `A` ([적용 가능한 함수 멤버](expressions.md#applicable-function-member)). 후보 인스턴스 생성자의 집합이 비어 있는 경우, 단일 최상의 인스턴스 생성자를 식별할 수 없는 경우 바인딩을 타임 오류가 발생 합니다.
    * 결과 *object_creation_expression* 형식의 값은 `T`, 즉 위의 단계에서 결정 인스턴스 생성자를 호출 하 여 생성 한 값입니다.
*  이 고, 그렇지 합니다 *object_creation_expression* 유효 하지 않은 바인딩 시간 오류가 발생 합니다.

경우에 합니다 *object_creation_expression* 동적으로 바인딩된 컴파일 타임 형식은 여전히 `T`합니다.

런타임 처리를 *object_creation_expression* 양식의 `new T(A)`여기서 `T` 은 *class_type* 또는 *struct_type* 및 `A` 선택적 *argument_list*, 다음 단계로 구성 됩니다.

*   하는 경우 `T` 되는 *class_type*:
    * 클래스의 새 인스턴스를 `T` 할당 됩니다. 새 인스턴스를 할당할 수 있는 충분 한 메모리가 없을 경우는 `System.OutOfMemoryException` throw 되 고 추가 단계 없이 실행 됩니다.
    * 새 인스턴스의 모든 필드를 기본값으로 초기화 됩니다 ([기본값](variables.md#default-values)).
    * 함수 멤버 호출 규칙에 따라 인스턴스 생성자가 호출 됩니다 ([컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)). 새로 할당 된 인스턴스에 대 한 참조를 자동으로 인스턴스 생성자에 전달 하 고 해당 생성자 내에서 인스턴스를 액세스할 수 있습니다 `this`합니다.
*   하는 경우 `T` 되는 *struct_type*:
    * 형식의 인스턴스로 `T` 임시 로컬 변수를 할당 하 여 만들어집니다. 인스턴스 생성자를 이후를 *struct_type* 확실 하 게 임시 변수의 초기화가 반드시 생성 되는 인스턴스의 각 필드에 값을 할당 해야 합니다.
    * 함수 멤버 호출 규칙에 따라 인스턴스 생성자가 호출 됩니다 ([컴파일 타임 동적 오버 로드 확인 검사](expressions.md#compile-time-checking-of-dynamic-overload-resolution)). 새로 할당 된 인스턴스에 대 한 참조를 자동으로 인스턴스 생성자에 전달 하 고 해당 생성자 내에서 인스턴스를 액세스할 수 있습니다 `this`합니다.

#### <a name="object-initializers"></a>개체 이니셜라이저

***개체 이니셜라이저*** 0 개 이상의 필드, 속성 또는 개체의 인덱싱된 요소에 대 한 값을 지정 합니다.

```antlr
object_initializer
    : '{' member_initializer_list? '}'
    | '{' member_initializer_list ',' '}'
    ;

member_initializer_list
    : member_initializer (',' member_initializer)*
    ;

member_initializer
    : initializer_target '=' initializer_value
    ;

initializer_target
    : identifier
    | '[' argument_list ']'
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
```

개체 이니셜라이저로 묶인 멤버 이니셜라이저의 시퀀스로 구성 됩니다 `{` 고 `}` 토큰 및 쉼표로 구분 합니다. 각 *member_initializer* 초기화에 대 한 대상을 지정 합니다. *식별자* 반면는 액세스할 수 있는 필드 또는 속성 초기화 되는 개체의 이름을 지정 해야는 *argument_list* 묶인 대괄호에 액세스할 수 있는 인덱서 인수를 지정 해야 합니다 초기화 되는 개체입니다. 이 동일한 필드 또는 속성에 대해 둘 이상의 멤버 이니셜라이저를 포함 하도록 개체 이니셜라이저에 대 한 오류입니다.

각 *initializer_target* 등호 식, 개체 이니셜라이저 또는 컬렉션 이니셜라이저를 나옵니다. 개체 이니셜라이저를 초기화 하 고 새로 만든된 개체를 참조 하려면 내의 식에서 것이 불가능 합니다.

등호 기호 할당으로 동일한 방식으로 처리 된 후 식을 지정 하는 멤버 이니셜라이저 ([단순 할당](expressions.md#simple-assignment)) 대상으로 합니다.

등호 되 면 개체 이니셜라이저를 지정 하는 멤버 이니셜라이저는 ***중첩 된 개체 이니셜라이저***, 즉, 포함된 된 개체의 초기화 합니다. 필드 또는 속성에는 새 값을 할당 하는 대신 중첩된 개체 이니셜라이저에서 할당 필드 또는 속성의 멤버에 대 한 할당으로 처리 됩니다. 값 형식 사용 하 여 읽기 전용 필드 또는 속성으로 값 형식에 중첩 된 개체 이니셜라이저를 적용할 수 없습니다.

등호 기호 뒤 컬렉션 이니셜라이저를 지정 하는 멤버 이니셜라이저는 포함 된 컬렉션을 초기화 합니다. 새 컬렉션에는 대상 필드, 속성 또는 인덱서에를 할당 하는 대신 이니셜라이저에 지정 된 요소는 대상에서 참조 하는 컬렉션에 추가 됩니다. 대상에 지정 된 요구 사항을 충족 하는 컬렉션 형식 이어야 합니다 [컬렉션 이니셜라이저](expressions.md#collection-initializers)합니다.

인덱스 이니셜라이저에 대 한 인수는 정확히 한 번만 항상 평가 됩니다. 따라서 인수를 종료 하지 않습니다 (예: 중첩 된 빈 이니셜라이저)으로 인해 사용 시작 하는 경우에 해당 파생 작업에 대해 평가 됩니다.

다음 클래스는 두 개의 좌표를 나타냅니다.
```csharp
public class Point
{
    int x, y;

    public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
```

인스턴스의 `Point` 만들고 다음과 같이 초기화할 수 있습니다.
```csharp
Point a = new Point { X = 0, Y = 1 };
```
하는 것과 동일한 효과가 있습니까
```csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
```
여기서 `__a` 그렇지 않으면 보이지 않는 하 고 액세스할 수 없는 임시 변수입니다. 다음 클래스는 두 지점에서 생성 하는 사각형을 나타냅니다.
```csharp
public class Rectangle
{
    Point p1, p2;

    public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
```

인스턴스의 `Rectangle` 만들고 다음과 같이 초기화할 수 있습니다.
```csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
```
하는 것과 동일한 효과가 있습니까
```csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
```
여기서 `__r`, `__p1` 및 `__p2` 보이지 않는 및 액세스할 수 있는 임시 변수가 있습니다.

하는 경우 `Rectangle`의 생성자에 포함 된 두 할당 `Point` 인스턴스
```csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();

    public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
```
다음 구문은 수 포함 된 초기화 `Point` 새 인스턴스를 할당 하는 대신 인스턴스:
```csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
```
하는 것과 동일한 효과가 있습니까
```csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
```

다음 예제에서는 C의 적절 한 정의 지정 합니다.
```csharp
var c = new C {
    x = true,
    y = { a = "Hello" },
    z = { 1, 2, 3 },
    ["x"] = 5,
    [0,0] = { "a", "b" },
    [1,2] = {}
};
```
이 시리즈 할당의 결과가 같습니다.
```csharp
C __c = new C();
__c.x = true;
__c.y.a = "Hello";
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = "x";
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add("a");
__c[__i2,__i3].Add("b");
int __i4 = 1, __i5 = 2;
var c = __c;
```
여기서 `__c`등 보이지 않는 및 소스 코드에 액세스할 수 없게 되는 생성 된 변수입니다. 인수 `[0,0]` 평가 한 번만, 및에 대 한 인수는 `[1,2]` 사용 되지 않기에 한 번 평가 됩니다.

#### <a name="collection-initializers"></a>컬렉션 이니셜라이저

컬렉션 이니셜라이저를 컬렉션의 요소를 지정합니다.

```antlr
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression (',' expression)*
    ;
```

컬렉션 이니셜라이저를 묶어 요소 이니셜라이저의 시퀀스로 구성 됩니다 `{` 고 `}` 토큰 및 쉼표로 구분 합니다. 초기화 되는 컬렉션 개체에 추가할 요소를 지정 하 고로 묶인 식의 목록으로 구성 하는 각 요소 이니셜라이저 `{` 고 `}` 토큰 및 쉼표로 구분 합니다.  단일 식 요소 이니셜라이저를 괄호 없이 작성할 수 있지만 할당 식 멤버 이니셜라이저를 사용 하 여 모호성을 피하기 위해 됩니다 수 없습니다. 합니다 *non_assignment_expression* 프로덕션에 정의 된 [식](expressions.md#expression)합니다.

다음은 컬렉션 이니셜라이저를 포함 하는 개체 생성 식의 예입니다.
```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

컬렉션 이니셜라이저를 적용 되는 컬렉션 개체를 구현 하는 형식 이어야 합니다 `System.Collections.IEnumerable` 했거나 컴파일 타임 오류가 발생 합니다. 컬렉션 이니셜라이저를 호출 하는 순서로 지정 된 요소 각각에 대 한는 `Add` 대상 메서드 일반 멤버 조회 적용 인수 목록과 식 목록을 요소 이니셜라이저를 사용 하 여 개체 및 오버 로드를 호출할 때마다 확인 합니다. 따라서 컬렉션 개체는 해당 인스턴스 또는 확장 메서드 이름의 있어야 `Add` 각 요소 이니셜라이저에 대 한 합니다.

다음 클래스 이름과 전화 번호 목록을 사용 하 여 연락처를 나타냅니다.
```csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();

    public string Name { get { return name; } set { name = value; } }

    public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
```

`List<Contact>` 만들고 다음과 같이 초기화할 수 있습니다.
```csharp
var contacts = new List<Contact> {
    new Contact {
        Name = "Chris Smith",
        PhoneNumbers = { "206-555-0101", "425-882-8080" }
    },
    new Contact {
        Name = "Bob Harris",
        PhoneNumbers = { "650-555-0199" }
    }
};
```
하는 것과 동일한 효과가 있습니까
```csharp
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = "Chris Smith";
__c1.PhoneNumbers.Add("206-555-0101");
__c1.PhoneNumbers.Add("425-882-8080");
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = "Bob Harris";
__c2.PhoneNumbers.Add("650-555-0199");
__clist.Add(__c2);
var contacts = __clist;
```
여기서 `__clist`, `__c1` 및 `__c2` 보이지 않는 및 액세스할 수 있는 임시 변수가 있습니다.

#### <a name="array-creation-expressions"></a>배열 만들기 식

*array_creation_expression* 의 새 인스턴스를 만드는 데 사용 되는 *array_type*합니다.

```antlr
array_creation_expression
    : 'new' non_array_type '[' expression_list ']' rank_specifier* array_initializer?
    | 'new' array_type array_initializer
    | 'new' rank_specifier array_initializer
    ;
```

첫 번째 폼의 배열 만들기 식을 식 목록에서 삭제 하는 각 개별 식의 결과로 생성 되는 형식의 배열 인스턴스를 할당 합니다. 배열 생성 식 예를 들어 `new int[10,20]` 형식의 배열 인스턴스 생성 `int[,]`, 및 배열 만들기 식을 `new int[10][,]` 형식의 배열을 생성 `int[][,]`합니다. 식 목록에서 각 식 형식 이어야 합니다 `int`, `uint`를 `long`, 또는 `ulong`, 또는 이러한 형식 중 하나 이상의 암시적으로 변환할 수 있습니다. 각 식의 값을 새로 할당 된 배열 인스턴스에 해당 차원의 길이 결정합니다. 배열 차원의 길이 음수가 아니어야 합니다, 이므로 할는 컴파일 타임 오류를 *constant_expression* 식 목록에 음수 값을 사용 하 여 합니다.

안전 하지 않은 컨텍스트에서 제외 하 고 ([안전 하지 않은 컨텍스트](unsafe-code.md#unsafe-contexts)), 배열 레이아웃 지정 되지 않았습니다.

첫 번째 폼의 배열 만들기 식을 배열 이니셜라이저를 포함 하는 경우 식 목록에서 각 식에는 상수 여야 합니다. 및 식 목록으로 지정 된 순위 및 차원 길이 배열 이니셜라이저의 일치 해야 합니다.

두 번째 또는 세 번째 폼의 배열 만들기 식을 배열 이니셜라이저는 지정 된 배열 형식 또는 차수 지정자의 순위 일치 해야 합니다. 개별 차원 길이 각 배열 이니셜라이저의 해당 중첩 수준에 있는 요소의 수에서 유추 됩니다. 따라서, 다음 식은
```csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
```
다음과 같습니다.
```csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
```

세 번째 형식의 배열 생성 식 이라고 하는 ***배열 생성 식에 암시적으로 형식화***합니다. 배열의 요소 형식을 명시적으로 지정 하지 않으면 하지만 가장 일반적인 형식으로 결정 한다는 점을 제외 하면 두 번째 형태에서 유사한 것 ([가장 일반적인 유형의 식 집합을 찾는](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) 배열에 있는 식 집합의 이니셜라이저입니다. 다차원 배열에 대 한 곳, 즉 합니다 *rank_specifier* 하나 이상의 쉼표가 포함 되어이 모든 구성 *식*가 있는 중첩 *array_initializer*s입니다.

배열 이니셜라이저에 자세히 설명 되어 [배열 이니셜라이저](arrays.md#array-initializers)합니다.

배열 생성 식 평가의 결과 값을 namely 새로 할당 된 배열 인스턴스에 대 한 참조로 분류 됩니다. 배열 생성 식의 런타임 처리는 다음 단계로 구성 됩니다.

*  차원 길이 식 합니다 *expression_list* 왼쪽에서 오른쪽 순서로 평가 됩니다. 각 식의 암시적 변환이 평가 ([암시적 변환을](conversions.md#implicit-conversions)) 다음 형식 중 하나로 수행 됩니다: `int`를 `uint`를 `long`, `ulong`합니다. 암시적 변환이 존재 하는이 목록의 첫 번째 형식이 선택 됩니다. 평가 식의 후속 암시적 변환으로 인해 예외가 발생 하는 경우 다음 식은 더 이상 계산 되 고 더 이상 진행 되지 않습니다.
*  차원 길이가 계산 된 값은 다음과 같이 유효성이 검사 됩니다. 하나 이상의 값은 0 보다 작은 경우는 `System.OverflowException` throw 되 고 추가 단계 없이 실행 됩니다.
*  지정된 된 차원의 길이 사용 하 여 배열 인스턴스가 할당 됩니다. 새 인스턴스를 할당할 수 있는 충분 한 메모리가 없을 경우는 `System.OutOfMemoryException` throw 되 고 추가 단계 없이 실행 됩니다.
*  새 배열 인스턴스의 모든 요소를 기본값으로 초기화 됩니다 ([기본값](variables.md#default-values)).
*  배열 만들기 식을 배열 이니셜라이저를 포함 하는 경우 다음 배열 이니셜라이저에 각 식 평가 되 고 해당 하는 배열 요소에 할당 합니다. 평가 및 할당 식 배열 이니셜라이저에 기록 된 순서에서 수행 됩니다-즉, 요소가 오름차순 인덱스를 늘리면 먼저 오른쪽에 있는 차원입니다. 지정된 된 식의 후속 대입 해당 배열 요소에는 평가 예외를 발생 시키는 경우 더 이상 요소가 초기화 됩니다 (고 나머지 요소를 기본값으로 되지 것입니다).

배열 만들기 식을 배열 형식의 요소가 있는 배열을 인스턴스화할 수 있지만 이러한 배열의 요소를 수동으로 초기화 해야 합니다. 예를 들어, 다음 문
```csharp
int[][] a = new int[100][];
```
형식의 요소를 100 개를 사용 하 여 1 차원 배열을 만듭니다 `int[]`합니다. 각 요소의 초기 값은 `null`합니다. 또한 하위 배열과 문을 인스턴스화하기 위해 동일한 배열 생성 식에 대 한 불가능
```csharp
int[][] a = new int[100][5];        // Error
```
컴파일 타임 오류가 발생 합니다. 하위 배열의 인스턴스화는 수동으로 에서처럼 대신 수행 해야 합니다.
```csharp
int[][] a = new int[100][];
for (int i = 0; i < 100; i++) a[i] = new int[5];
```

배열의 배열에 하위 배열과 길이가 같은 모든 경우는 "사각형" 셰이프를 하는 경우에 다차원 배열을 사용 하는 것이 효율적입니다. 위의 예제에서는 배열의 배열 인스턴스화 101 개체를 만듭니다-하나의 외부 배열 및 100 개의 하위 배열입니다. 반면,
```csharp
int[,] = new int[100, 5];
```
단일 개체만, 2 차원 배열을 만들고 단일 문에서 할당을 수행 합니다.

다음은 암시적으로 형식화 된 배열 생성 식의 예입니다.
```csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]

var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]

var c = new[,] { { "hello", null }, { "world", "!" } };   // string[,]

var d = new[] { 1, "one", 2, "two" };                     // Error
```

마지막 식 때문에 컴파일 타임 오류가 발생 하지 않습니다 `int` 나 `string` 다른 암시적으로 변환할 수 없으므로 더 가장 일반적으로 입력 및 합니다. 명시적으로 형식화 된 배열 만들기 식을 사용 해야이 예제의 경우 예를 들어 형식이 되도록 지정 `object[]`합니다. 또는 일반적인 기본 형식으로 유추 요소 형식 다음 요소 중 하나를 캐스팅할 수 있습니다.

익명 개체 이니셜라이저를 사용 하 여 암시적으로 형식화 된 배열 만들기 식을 결합할 수 있습니다 ([익명 개체 생성 식을](expressions.md#anonymous-object-creation-expressions)) 익명으로 만들려면 데이터 구조를 입력 합니다. 예를 들어:
```csharp
var contacts = new[] {
    new {
        Name = "Chris Smith",
        PhoneNumbers = new[] { "206-555-0101", "425-882-8080" }
    },
    new {
        Name = "Bob Harris",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
```

#### <a name="delegate-creation-expressions"></a>대리자 생성 식

A *delegate_creation_expression* 의 새 인스턴스를 만드는 데 사용 되는 *delegate_type*합니다.

```antlr
delegate_creation_expression
    : 'new' delegate_type '(' expression ')'
    ;
```

대리자 생성 식의 인수는 메서드 그룹, 익명 함수 또는 컴파일 타임 형식 값 이어야 합니다 `dynamic` 또는 *delegate_type*합니다. 인수는 메서드 그룹 인 경우 메서드를 식별 및 인스턴스 메서드를 대리자를 만들 개체입니다. 익명 함수 인수가 직접 매개 변수 및 대리자 대상의 메서드 본문을 정의 합니다. 인수 값 이면의 복사본을 만드는 데 사용할 대리자 인스턴스를 식별 합니다.

경우는 *식* 컴파일 시간 형식이 `dynamic`의 *delegate_creation_expression* 바인딩된 동적으로 ([동적 바인딩](expressions.md#dynamic-binding)), 및 아래 규칙 런타임 형식을 사용 하 여 런타임 시 적용 되는 *식*합니다. 그렇지 않으면 컴파일 타임에 규칙이 적용 됩니다.

바인딩 시간 처리를 *delegate_creation_expression* 폼의 `new D(E)`여기서 `D` 는 *delegate_type* 및 `E` 는 *식* , 다음 단계로 구성 됩니다.

*  하는 경우 `E` 메서드 그룹은 대리자 생성 식 메서드 그룹 변환으로 동일한 방식으로 처리 됩니다 ([메서드 그룹 변환](conversions.md#method-group-conversions))에서 `E` 에 `D`입니다.
*  하는 경우 `E` 는 익명 함수 대리자 생성 식 동일한 방식으로 익명 함수 변환으로 처리 됩니다 ([익명 함수 변환](conversions.md#anonymous-function-conversions))에서 `E` 에 `D`입니다.
*  하는 경우 `E` 값인 `E` 호환 되어야 합니다 ([대리자 선언](delegates.md#delegate-declarations))와 `D`, 결과 형식의 새로 만든된 대리자에 대 한 참조 이며 `D` 동일한 호출을 참조 하는 목록 `E`합니다. 하는 경우 `E` 와 호환 되지 않습니다 `D`, 컴파일 시간 오류가 발생 합니다.

런타임 처리를 *delegate_creation_expression* 형식의 `new D(E)`여기서 `D` 는 *delegate_type* 및 `E` 가 *식* , 다음 단계로 구성 됩니다.

*   하는 경우 `E` 메서드 그룹은 대리자 생성 식 메서드 그룹 변환으로 평가 됩니다 ([메서드 그룹 변환](conversions.md#method-group-conversions))에서 `E` 에 `D`입니다.
*   하는 경우 `E` 는 익명 함수 대리자 만들기는 익명 함수 변환으로 평가 됩니다 `E` 하 `D` ([익명 함수 변환](conversions.md#anonymous-function-conversions)).
*   하는 경우 `E` 의 값을 *delegate_type*:
    * `E` 평가 됩니다. 이 평가 예외를 발생 시키는 경우에 추가 단계 없이 실행 됩니다.
    * 경우 값 `E` 은 `null`, `System.NullReferenceException` throw 되 고 추가 단계 없이 실행 됩니다.
    * 대리자 형식의 새 인스턴스를 `D` 할당 됩니다. 새 인스턴스를 할당할 수 있는 충분 한 메모리가 없을 경우는 `System.OutOfMemoryException` throw 되 고 추가 단계 없이 실행 됩니다.
    * 제공한 대리자 인스턴스와 같은 호출 목록을 가진 새 대리자 인스턴스가 초기화 되었음을 `E`합니다.

대리자의 호출 목록에는 대리자 인스턴스화되고 대리자의 전체 수명 동안 일정을 유지 하는 경우 결정 됩니다. 즉, 만들어진 후에 대리자의 대상 호출 가능 엔터티를 변경할 수 없습니다. 때 두 명의 대리자가 결합 되거나 다른 하나를 제거 ([대리자 선언](delegates.md#delegate-declarations)), 새 대리자를 되며 대리자가 변경 내용이 있습니다.

속성, 인덱서, 사용자 정의 연산자, 인스턴스 생성자, 소멸자 또는 정적 생성자를 참조 하는 대리자를 만들 수는 없습니다.

위에서 설명한 대로 경우 대리자는 메서드 그룹에 정식 매개 변수 목록에서 만들어지고 대리자의 반환 형식을 선택 하는 오버 로드 된 방법의 결정 합니다. 예제
```csharp
delegate double DoubleFunc(double x);

class A
{
    DoubleFunc f = new DoubleFunc(Square);

    static float Square(float x) {
        return x * x;
    }

    static double Square(double x) {
        return x * x;
    }
}
```
`A.f` 필드는 두 번째 참조 하는 대리자를 사용 하 여 초기화 `Square` 메서드는 메서드 형식 매개 변수 목록 및 반환 형식의 정확 하 게 일치 하기 때문에 `DoubleFunc`입니다. 두 번째 했습니다 `Square` 없으면 메서드는 컴파일 타임 오류가 발생 합니다.

#### <a name="anonymous-object-creation-expressions"></a>익명 개체 만들기 식

*anonymous_object_creation_expression* 무명 형식의 개체를 만드는 데 사용 됩니다.

```antlr
anonymous_object_creation_expression
    : 'new' anonymous_object_initializer
    ;

anonymous_object_initializer
    : '{' member_declarator_list? '}'
    | '{' member_declarator_list ',' '}'
    ;

member_declarator_list
    : member_declarator (',' member_declarator)*
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier '=' expression
    ;
```

익명 개체 이니셜라이저를 익명 형식을 선언 하 고 해당 형식의 인스턴스를 반환 합니다. 익명 형식은에서 직접 상속 하는 이름이 없는 클래스 형식 `object`합니다. 익명 형식의 멤버는 형식의 인스턴스를 만드는 데 익명 개체 이니셜라이저에서 유추 읽기 전용 속성의 시퀀스. 특히, 폼의 익명 개체 이니셜라이저
```csharp
new { p1 = e1, p2 = e2, ..., pn = en }
```
폼의 익명 형식 선언
```csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    ...
    private readonly Tn fn;

    public __Anonymous1(T1 a1, T2 a2, ..., Tn an) {
        f1 = a1;
        f2 = a2;
        ...
        fn = an;
    }

    public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    ...
    public Tn pn { get { return fn; } }

    public override bool Equals(object __o) { ... }
    public override int GetHashCode() { ... }
}
```
여기서 각 `Tx` 해당 식의 형식이 `ex`합니다. 사용 된 식에 *member_declarator* 형식이 있어야 합니다. 즉의 식에 대 한 컴파일 시간 오류를 *member_declarator* null 또는 익명 함수입니다. 형식이 안전 하지 않은 식에 대해 컴파일 시간 오류를 이기도 합니다.

무명 형식 및 매개 변수의 이름을 해당 `Equals` 메서드는 컴파일러에서 자동으로 생성 하 고 프로그램 텍스트에서 참조할 수 없습니다.

동일한 프로그램에서 동일한 순서로 동일한 이름 및 컴파일 타임 형식 속성의 순서를 지정 하는 두 명의 익명 개체 이니셜라이저는 동일한 익명 형식의 인스턴스를 생성 합니다.

예제
```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```
마지막 줄에서 할당 되지 않으므로 위 `p1` 및 `p2` 같은 익명 형식입니다.

`Equals` 및 `GetHashcode` 에서 상속 된 메서드를 재정의 하는 익명 형식에 메서드 `object`, 및의 측면에서 정의 됩니다는 `Equals` 및 `GetHashcode` 속성의 동일한 익명 형식의 두 인스턴스가 같은지를 경우 및 해당 속성이 모두 같은 경우에 합니다.

멤버 선언 자는 단순한 이름으로 축약할 수 있습니다 ([형식 유추](expressions.md#type-inference)), 멤버 액세스 ([동적 오버 로드 확인 검사 하는 컴파일 타임](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), 기본 액세스 ([액세스기반](expressions.md#base-access)) 또는 null 조건부 멤버 액세스 ([프로젝션 이니셜라이저 식이 Null 조건부](expressions.md#null-conditional-expressions-as-projection-initializers)). 이 호출 되는 ***프로젝션 이니셜라이저*** 축약형 선언 및 동일한 이름 가진 속성에 할당 되며. 폼의 특히 멤버 선언 자
```csharp
identifier
expr.identifier
```
각각은 다음을 정확 하 게 동일 합니다.
```csharp
identifier = identifier
identifier = expr.identifier
```

프로젝션 이니셜라이저에 따라서 합니다 *식별자* 값 및 필드 또는 값이 할당 된 속성 모두를 선택 합니다. 직관적으로 프로젝션 이니셜라이저를 프로젝트 뿐 아니라 값 뿐만 아니라 값의 이름입니다.

### <a name="the-typeof-operator"></a>Typeof 연산자

`typeof` 연산자를 가져오는 데 사용 되는 `System.Type` 개체 유형에 대 한.

```antlr
typeof_expression
    : 'typeof' '(' type ')'
    | 'typeof' '(' unbound_type_name ')'
    | 'typeof' '(' 'void' ')'
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier '::' identifier generic_dimension_specifier?
    | unbound_type_name '.' identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : '<' comma* '>'
    ;

comma
    : ','
    ;
```

첫 번째 형태 *typeof_expression* 이루어져를 `typeof` 키워드 뒤에 괄호로 묶고 *형식*합니다. 이 폼의 식의 결과 `System.Type` 표시 된 형식에 대 한 개체입니다. 하나만 `System.Type` 임의의 형식에 대 한 개체입니다. 형식에 대 한 즉 `T`, `typeof(T) == typeof(T)` 는 항상 true입니다. 합니다 *형식* 일 수 없습니다 `dynamic`합니다.

두 번째 형태 *typeof_expression* 이루어져를 `typeof` 키워드 뒤에 괄호로 묶고 *unbound_type_name*합니다. *unbound_type_name* 매우 비슷합니다는 *type_name* ([Namespace 및 형식 이름](basic-concepts.md#namespace-and-type-names)) 점을 제외 하 고는 *unbound_type_name* 포함 *generic_dimension_specifier*s 여기서는 *type_name* 포함 *type_argument_list*s입니다. 때의 피연산자는 *typeof_expression* 둘 다의 문법에 맞는 토큰의 순서가 *unbound_type_name* 및 *type_name*, 즉 포함 되어 있을 때는 모두를 *generic_dimension_specifier* 또는 *type_argument_list*, 일련의 토큰으로 간주 됩니다는 *type_name*합니다. 의미는 *unbound_type_name* 다음과 같이 결정 됩니다.

*  토큰을 시퀀스로 변환를 *type_name* 각 바꿔 *generic_dimension_specifier* 사용 하 여를 *type_argument_list* 쉼표 동일한 수 및 키워드 `object` 각 *type_argument*합니다.
*  평가 결과 *type_name*, 모든 형식 매개 변수 제약 조건을 무시 하 고 있습니다.
*  합니다 *unbound_type_name* 결과로 생성 된 형식과 사용 하 여 연결 하는 언바운드 제네릭 형식으로 확인 ([바인딩되며 형식에 바인딩되지 않은](types.md#bound-and-unbound-types)).

결과 *typeof_expression* 는 `System.Type` 제네릭 형식에 바인딩되지 않은 결과 대 한 개체입니다.

세 번째 형태의 *typeof_expression* 이루어져를 `typeof` 키워드 뒤에 괄호로 묶고 `void` 키워드. 이 폼의 식의 결과 `System.Type` 형식의 없음을 나타내는 개체입니다. 반환 된 형식 개체 `typeof(void)` 모든 형식에 대해 반환 되는 형식 개체와에서 다릅니다. 이러한 메서드는 수의 인스턴스를 사용 하 여 void 메서드를 포함 하 여 모든 메서드의 반환 형식을 나타내는 하려는 메서드에 리플렉션을 언어에서 허용 하는 클래스 라이브러리의이 특별 한 형식 개체는 유용한 `System.Type`합니다.

`typeof` 형식 매개 변수에서 연산자를 사용할 수 있습니다. 결과 `System.Type` 형식 매개 변수에 바인딩된 런타임 형식에 대 한 개체입니다. 합니다 `typeof` 연산자는 언바운드 제네릭 형식 또는 생성된 된 형식을 사용할 수도 있습니다 ([바인딩되며 형식에 바인딩되지 않은](types.md#bound-and-unbound-types)). `System.Type` 바인딩되지 않은 제네릭 형식이 동일 하지 않습니다 개체는 `System.Type` 인스턴스 형식의 개체입니다. 인스턴스 형식이 항상 런타임 시 폐쇄형된 생성된 형식 이므로 해당 `System.Type` 언바운드 제네릭 형식에 형식 인수 없이 개체 사용에 런타임에 형식 인수에 따라 다릅니다.

이 예제에서
```csharp
using System;

class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>>),
            typeof(X<>)
        };
        for (int i = 0; i < t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}

class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
```
다음 출력이 생성 됩니다.
```
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X`1[System.Int32]
X`1[X`1[System.Int32]]
X`1[T]
```

사실은 `int` 및 `System.Int32` 같은 형식입니다.

또한 결과인 `typeof(X<>)` 종속 되지 않는 형식 인수가 있지만 결과 `typeof(X<T>)` 않습니다.

### <a name="the-checked-and-unchecked-operators"></a>Checked 및 unchecked 연산자

합니다 `checked` 및 `unchecked` 연산자는 제어 하는 데 사용 되는 ***오버플로 검사 컨텍스트에*** 정수 형식 산술 연산 및 변환에 대 한 합니다.

```antlr
checked_expression
    : 'checked' '(' expression ')'
    ;

unchecked_expression
    : 'unchecked' '(' expression ')'
    ;
```

합니다 `checked` 연산자 확인 된 컨텍스트에서 포함 된 식 및 `unchecked` 연산자 unchecked 컨텍스트에서 포함 된 식을 계산 합니다. A *checked_expression* 하거나 *unchecked_expression* 정확히 일치를 *parenthesized_expression* ([괄호로 묶인 식](expressions.md#parenthesized-expressions))에 지정 된 오버플로 검사 컨텍스트에 포함 된 식이 계산 되는 점을 제외 하 고 있습니다.

오버플로 검사 컨텍스트를 통해 제어할 수도 있습니다는 `checked` 하 고 `unchecked` 문 ([checked 및 unchecked 문](statements.md#the-checked-and-unchecked-statements)).

다음 작업은 오버플로 검사 하 여 설정 하는 컨텍스트에 영향을 받지 합니다 `checked` 고 `unchecked` 연산자와 문을:

*  미리 정의 된 `++` 하 고 `--` 단항 연산자 ([후 위 증가 및 감소 연산자](expressions.md#postfix-increment-and-decrement-operators) 하 고 [전위 증가 및 감소 연산자](expressions.md#prefix-increment-and-decrement-operators)) 정수 계열 피연산자가 하는 경우 형식입니다.
*  미리 정의 된 `-` 단항 연산자 ([단항 빼기 연산자](expressions.md#unary-minus-operator)), 피연산자가 정수 계열 형식입니다.
*  미리 정의 된 `+`, `-`를 `*`, 및 `/` 이항 연산자 ([산술 연산자](expressions.md#arithmetic-operators)), 두 피연산자 모두 정수 계열 형식의 경우.
*  명시적 숫자 변환 ([명시적 숫자 변환](conversions.md#explicit-numeric-conversions)) 또는 다른 정수 계열 형식으로 한 정수 계열 형식에서 `float` 또는 `double` 정수 계열 형식입니다.

경우에 너무 커서 대상 유형에 컨텍스트는 작업을 수행된 하는 컨트롤 결과 동작을 나타낼 수 있는 결과 생성 하면 위 작업 중 하나:

*  에 `checked` 컨텍스트, 작업에는 상수 식 ([상수 식](expressions.md#constant-expressions)), 컴파일 타임 오류가 발생 합니다. 실행 시 작업을 수행할 때 그러지는 `System.OverflowException` throw 됩니다.
*  에 `unchecked` 컨텍스트를 결과 대상 형식에 맞지 않는 상위 비트가 삭제 되어 잘립니다.

상수가 아닌 식 (런타임 시 계산 되는 식)는 포함 되지 않는 모든 `checked` 또는 `unchecked` 기본 오버플로 검사 컨텍스트에 연산자, 문 `unchecked` 외부 (예: 컴파일러 고려 하지 않으면 스위치 및 실행 환경 구성은)에 대 한 호출 `checked` 평가 합니다.

상수 식 (컴파일 타임에 완벽 하 게 평가할 수 있는 식)에 대 한 기본 오버플로 검사 컨텍스트에 항상 `checked`합니다. 상수 식에 명시적으로 배치 됩니다 하지 않는 한는 `unchecked` 컨텍스트를 항상 식의 컴파일 타임 확인 하는 동안 발생 하는 오버플로 컴파일 타임 오류가 발생 합니다.

익명 함수의 본문에서 영향을 받지 `checked` 또는 `unchecked` 익명 함수 발생 하는 컨텍스트.

예제
```csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    static int F() {
        return checked(x * y);      // Throws OverflowException
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Depends on default
    }
}
```
식의 어느 컴파일 타임에 평가할 수 있으므로 컴파일 타임 오류가 보고 되지 않습니다. 실행 시 합니다 `F` 메서드가 throw를 `System.OverflowException`, 및 `G` -727379968 (범위를 벗어난 결과의 하위 32 비트)를 반환 합니다. 동작을 `H` 메서드 기본 오버플로 검사 컨텍스트를 컴파일하는 경우에 따라 달라 지지만 동일 하거나 것 `F` 또는 같은 `G`합니다.

예제
```csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;

    static int F() {
        return checked(x * y);      // Compile error, overflow
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Compile error, overflow
    }
}
```
상수 식을 계산할 때 발생 하는 오버플로 `F` 및 `H` 식의 평가 되기 때문에 보고 되어야 하도록 컴파일 타임 오류가 발생을 `checked` 컨텍스트. 상수 식을 계산 하는 경우에 오버플로가 발생 `G`, 평가 수행 되기 때문 이지만 `unchecked` 컨텍스트에 오버플로 보고 되지 않습니다.

합니다 `checked` 하 고 `unchecked` 연산자는 오버플로 검사 컨텍스트 내에서 텍스트가 포함 된 이러한 작업에 영향을 줍니다는 "`(`"및"`)`" 토큰입니다. 연산자에 포함 된 식을 평가 결과로 호출 되는 함수 멤버 효과가 없습니다. 예제
```csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }

    static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
```
사용 `checked` 에 `F` 평가 하는 데 영향을 주지 않습니다 `x * y` 에서 `Multiply`이므로 `x * y` 기본 오버플로 검사 컨텍스트에에서 계산 됩니다.

`unchecked` 연산자는 16 진수 표기법의 부호 있는 정수 계열 형식의 상수를 작성 하는 경우에 편리 합니다. 예를 들어:
```csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);

    public const int HighBit = unchecked((int)0x80000000);
}
```

위의 16 진수 상수에 모두 형식의 `uint`합니다. 상수 외부 되므로 합니다 `int` 없이 범위를 `unchecked` 연산자, 캐스트를 `int` 컴파일 타임 오류가 생성 됩니다.

합니다 `checked` 및 `unchecked` 연산자와 문을 프로그래머에 게 몇 가지 숫자 계산의 특정 측면을 제어할 수 있도록 합니다. 그러나 일부 숫자 연산자의 동작 해당 피연산자의 데이터 형식에 따라 달라 집니다. 예를 들어 항상 두 자리를 곱한 결과 오버플로 예외가 내 에서도 명시적으로 `unchecked` 생성 합니다. 마찬가지로, 두 개를 곱한 부동 되지 결과 오버플로 예외가 내 에서도 명시적으로 `checked` 생성 합니다. 다른 연산자 검사 모드의 영향을 받지 않습니다 또한, 기본 여부 또는 명시적입니다.

### <a name="default-value-expressions"></a>기본 값 식

기본 값 식의 기본값을 가져오는 데 사용 됩니다 ([기본값](variables.md#default-values)) 형식입니다. 일반적으로 확인할 수 없는 경우 형식 매개 변수 값 형식 또는 참조 형식 이므로 형식 매개 변수에 대해 기본값 식을 사용 됩니다. (변환 된 항목이 없고에서 `null` 형식 매개 변수는 참조 형식으로 알려져 경우가 아니면 형식 매개 변수에 리터럴.)

```antlr
default_value_expression
    : 'default' '(' type ')'
    ;
```

경우는 *형식* 에 *default_value_expression* 평가 런타임 참조 형식으로 결과 `null` 해당 형식으로 변환 합니다. 경우는 *형식* 에 *default_value_expression* 평가 결과 런타임에 값 형식에 *value_type*의 기본값 ([기본 생성자](types.md#default-constructors)).

A *default_value_expression* 상수 식입니다 ([상수 식을](expressions.md#constant-expressions)) 형식이 참조 형식 또는 참조 형식으로 알려진 형식 매개 변수 ([형식 매개 변수 제약 조건](classes.md#type-parameter-constraints)). 또한를 *default_value_expression* 형식을 사용 하면 다음과 같은 값 형식 중 하나인 경우에 상수 식: `sbyte`, `byte`를 `short`를 `ushort`를 `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`를 `decimal`, `bool`, 또는 열거형 형식입니다.


### <a name="nameof-expressions"></a>Nameof 식

A *nameof_expression* 상수 문자열로 프로그램 엔터티의 이름을 가져오는 데 사용 됩니다.

```antlr
nameof_expression
    : 'nameof' '(' named_entity ')'
    ;

named_entity
    : simple_name
    | named_entity_target '.' identifier type_argument_list?
    ;

named_entity_target
    : 'this'
    | 'base'
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
```

문법적으로 말하자면 합니다 *named_entity* 피연산자는 항상 식입니다. 때문에 `nameof` 는 예약된 키워드가 아닙니다 nameof 식은 단순한 이름 호출을 사용 하 여 구문상 모호한 항상 `nameof`합니다. 호환성을 위해, 이름 조회 하는 경우 ([단순 이름](expressions.md#simple-names)) 이름의 `nameof` 성공 하면 식으로 처리 됩니다는 *invocation_expression* 호출 인지 여부에 관계 없이- 법률. 그렇지 않으면이 생성자는 *nameof_expression*합니다.

의미는 *named_entity* 의 *nameof_expression* ; 식으로의 의미으로 즉, 하나는 *simple_name*, *base_access*  또는 *member_access*합니다. 그러나 여기서 조회에 설명 된 [단순 이름](expressions.md#simple-names) 및 [멤버 액세스](expressions.md#member-access) 정적 컨텍스트에서 인스턴스 멤버를 찾을 수 없어서 오류가 발생 한 *nameof_expression*이러한 오류가 발생 합니다.

에 대 한 컴파일 시간 오류를 *named_entity* 있어야 하는 메서드 그룹을 지정을 *type_argument_list*합니다. 에 대 한 컴파일 시간 오류가 발생 한 *named_entity_target* 형식을 갖도록 `dynamic`합니다.

A *nameof_expression* 형식의 상수 식 `string`, 런타임 시 효과가 없습니다. 특히, 해당 *named_entity* 계산 되지 않습니다 및 한정 된 할당 분석을 위해 무시 됩니다 ([단순 식에 대 한 일반 규칙](variables.md#general-rules-for-simple-expressions)). 해당 값은 마지막 식별자를 *named_entity* 선택적 최종 전에 *type_argument_list*같은 방식으로 변환 된:

* 접두사 "`@`"를 사용 하는 경우 제거 됩니다.
* 각 *unicode_escape_sequence* 해당 유니코드 문자로 변환 됩니다.
* 모든 *formatting_characters* 제거 됩니다.

에 적용 되는 동일한 변형 이들은 [식별자](lexical-structure.md#identifiers) 식별자 같은지를 테스트 하는 경우.

TODO: 예제

### <a name="anonymous-method-expressions"></a>무명 메서드 식

*anonymous_method_expression* 익명 함수를 정의 하는 두 가지 중 하나입니다. 에 설명 된 추가 이러한 [익명 함수 식](expressions.md#anonymous-function-expressions)합니다.

## <a name="unary-operators"></a>단항 연산자

`?`, `+`, `-`, `!`를 `~`를 `++`, `--`캐스팅, 및 `await` 연산자는 단항 연산자 라고 합니다.

```antlr
unary_expression
    : primary_expression
    | null_conditional_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    | '~' unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
```

하는 경우의 피연산자는 *unary_expression* 컴파일 시간 형식이 `dynamic`, 동적으로 바인딩되어 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 타임 유형의 합니다 *unary_expression* 는 `dynamic`, 및 아래에 설명 된 해결 방법을 피연산자의 런타임 형식을 사용 하 여 런타임 시 수행 됩니다.

### <a name="null-conditional-operator"></a>Null 조건부 연산자

Null 조건부 연산자는 피연산자가 null이 아닌 경우에 해당 피연산자에 작업 목록이 적용 됩니다. 그렇지 않으면 연산자를 적용 한 결과 `null`합니다.

```antlr
null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? '?' '.' identifier type_argument_list?
    | null_conditional_operations? '?' '[' argument_list ']'
    | null_conditional_operations '.' identifier type_argument_list?
    | null_conditional_operations '[' argument_list ']'
    | null_conditional_operations '(' argument_list? ')'
    ;
```

작업 목록에는 호출 뿐만 아니라 멤버 액세스 및 요소 액세스 작업 (null 조건부 자체 일 수 있음)를 포함할 수 있습니다.

예를 들어 식 `a.b?[0]?.c()` 되는 *null_conditional_expression* 사용 하 여를 *primary_expression* `a.b` 및 *null_conditional_operations* `?[0]` (null 조건부 요소 액세스)를 `?.c` (null 조건부 멤버 액세스) 및 `()` (호출).

에 대 한는 *null_conditional_expression* `E` 사용 하 여를 *primary_expression* `P`let, `E0` 텍스트가 앞에 오는 를제거하여얻은식일`?`각 합니다 *null_conditional_operations* 의 `E` 하나 있는 합니다. 개념적으로 `E0` 를 나타내는 null 검사를 하나도 경우 평가할 식 합니다 `?`s 검색 하려면를 `null`합니다.

또한 `E1` 텍스트가 앞에 오는 제거 하 여 얻은 식일 `?` 만에서 첫 번째는 *null_conditional_operations* 에서 `E`합니다. 이로 인해 발생할 수 있습니다는 *기본 식을* (하나만 있으면 `?`) 또는 다른 *null_conditional_expression*합니다.

예를 들어 경우 `E` 식 `a.b?[0]?.c()`, 한 다음 `E0` 식 `a.b[0].c()` 및 `E1` 식 `a.b[0]?.c()`합니다.

하는 경우 `E0` 한 후 아무 것도로 분류 됩니다 `E` nothing으로 분류 됩니다. 그렇지 않으면 전자를 값으로 분류 됩니다.

`E0` 및 `E1` 의 의미를 확인 하는 데 사용 됩니다 `E`:

*  하는 경우 `E` 으로 발생 한 *statement_expression* 의 의미를 `E` 문과 동일

   ```csharp
   if ((object)P != null) E1;
   ```

   제외 하 고 P가 한 번만 계산 됩니다.

*  그렇지 않은 경우, `E0` 컴파일 타임 오류가 발생 하는 것으로 분류 됩니다.

*  수이 고, 그렇지 `T0` 가 형식의 `E0`합니다.

   *  경우 `T0` 는 컴파일 타임 오류가 발생 하는 참조 형식 또는 nullable이 아닌 값 형식 이어야 알려지지 않은 형식 매개 변수입니다.

   *  경우 `T0` 가 null이 아닌 값 형식 유형의 `E` 은 `T0?`, 및의 의미를 `E` 같습니다

      ```csharp
      ((object)P == null) ? (T0?)null : E1
      ```

      점을 제외 하 고 `P` 한 번만 평가 됩니다.

   *  그렇지 않으면 E 형식이 T0, 이며 E의 의미와 동일

      ```csharp
      ((object)P == null) ? null : E1
      ```

      점을 제외 하 고 `P` 한 번만 평가 됩니다.

경우 `E1` 자체는 *null_conditional_expression*, 그런 다음 이러한 규칙은 다시에 대 한 테스트를 중첩 `null` 없을 때까지 더 이상 `?`의 식 아래로 줄었습니다 및 기본 식 `E0`합니다.

예를 들어 경우 식 `a.b?[0]?.c()` 문-식으로 문에서 발생 합니다.
```csharp
a.b?[0]?.c();
```
해당 의미는 다음과 같습니다.
```csharp
if (a.b != null) a.b[0]?.c();
```
다시 같습니다.
```csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
```
한다는 `a.b` 고 `a.b[0]` 한 번만 평가 됩니다.

경우는 해당 값이 사용에서 같이 컨텍스트에서 발생 합니다.
```csharp
var x = a.b?[0]?.c();
```
및 해당 의미에 해당 하는 마지막 호출의 형식이 nullable이 아닌 값 형식이 아닌를 가정 합니다.
```csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
```
한다는 `a.b` 고 `a.b[0]` 한 번만 평가 됩니다.

#### <a name="null-conditional-expressions-as-projection-initializers"></a>Null 조건부 식을 프로젝션 이니셜라이저

Null 조건부 식 으로만 사용할 수는 *member_declarator* 에 *anonymous_object_creation_expression* ([익명 개체 생성 식을](expressions.md#anonymous-object-creation-expressions)) 하는 경우 (필요에 따라 null 조건부) 멤버 액세스를 사용 하 여 종료 됩니다. 문법적으로,이 요구 사항으로 표현할 수 있습니다.

```antlr
null_conditional_member_access
    : primary_expression null_conditional_operations? '?' '.' identifier type_argument_list?
    | primary_expression null_conditional_operations '.' identifier type_argument_list?
    ;
```

에 대 한 문법의 특별 한 경우 이것이 *null_conditional_expression* 위에 있습니다. 에 대 한 프로덕션 *member_declarator* 에 [익명 개체 생성 식을](expressions.md#anonymous-object-creation-expressions) 만 포함 됩니다 *null_conditional_member_access*합니다.

#### <a name="null-conditional-expressions-as-statement-expressions"></a>Null 조건부 식 문의 식으로

Null 조건부 식 으로만 사용할 수는 *statement_expression* ([식 문은](statements.md#expression-statements)) 호출으로 끝나는 경우. 문법적으로,이 요구 사항으로 표현할 수 있습니다.

```antlr
null_conditional_invocation_expression
    : primary_expression null_conditional_operations '(' argument_list? ')'
    ;
```

에 대 한 문법의 특별 한 경우 이것이 *null_conditional_expression* 위에 있습니다. 에 대 한 프로덕션 *statement_expression* 에 [식 문은](statements.md#expression-statements) 만 포함 됩니다 *null_conditional_invocation_expression*합니다.


### <a name="unary-plus-operator"></a>단항 더하기 연산자

폼의 작업에 대 한 `+x`, 단항 연산자 오버 로드 확인 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 및 결과의 형식은 연산자의 반환 형식입니다. 미리 정의 된 단항 더하기 연산자는 다음과 같습니다.

```csharp
int operator +(int x);
uint operator +(uint x);
long operator +(long x);
ulong operator +(ulong x);
float operator +(float x);
double operator +(double x);
decimal operator +(decimal x);
```

이러한 연산자의 각각에 대 한 결과 단순히 피연산자의 값입니다.

### <a name="unary-minus-operator"></a>단항 빼기 연산자

폼의 작업에 대 한 `-x`, 단항 연산자 오버 로드 확인 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 및 결과의 형식은 연산자의 반환 형식입니다. 미리 정의 된 부정 연산자는 다음과 같습니다.

*  정수 부정:

   ```csharp
   int operator -(int x);
   long operator -(long x);
   ```

   빼는 방식으로 결과가 `x` 0에서. 하는 경우의 값 `x` 피연산자 형식의 표현할 수 있는 가장 작은 값 (-2 ^31에 대 한 `int` -2 ^63에 대 한 `long`)의 산술 부정 다음 `x` 피연산자 형식 내에서 표현할 수 없는 합니다. 내에서이 문제가 발생 하면를 `checked` 컨텍스트에 `System.OverflowException` 예외가; 내에서 발생 하는 경우는 `unchecked` 컨텍스트는 결과 피연산자의 값 및 오버플로 보고 되지 않습니다.

   부정 연산자의 피연산자는 형식입니다 `uint`, 형식으로 변환 됩니다 `long`, 및 결과의 형식은 `long`합니다. 예외는 허용 하는 규칙을 `int` -2147483648 값 (-2 ^31) 리터럴 10 진수 정수로 쓸 ([정수 리터럴](lexical-structure.md#integer-literals)).

   부정 연산자의 피연산자는 형식입니다 `ulong`, 컴파일 시간 오류가 발생 합니다. 예외는 허용 하는 규칙을 `long` -9223372036854775808 값 (-2 ^63) 10 진수 정수 리터럴로 작성 ([정수 리터럴](lexical-structure.md#integer-literals)).

*  부동 소수점 부정:

   ```csharp
   float operator -(float x);
   double operator -(double x);
   ```

   결과의 값인 `x` 의 부호를 반전 합니다. 경우 `x` 가 NaN 결과가 NaN 이기도 합니다.

*  10 진수 부정:

   ```csharp
   decimal operator -(decimal x);
   ```

   빼는 방식으로 결과가 `x` 0에서. 10 진수 부정 연산을 사용 하는 단항 빼기 연산자 형식의 `System.Decimal`합니다.

### <a name="logical-negation-operator"></a>논리 부정 연산자

폼의 작업에 대 한 `!x`, 단항 연산자 오버 로드 확인 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 및 결과의 형식은 연산자의 반환 형식입니다. 미리 정의 된 논리 부정 연산자를 하나만 있습니다.
```csharp
bool operator !(bool x);
```

이 연산자는 피연산자의 논리 부정을 계산: 피연산자가 `true`, 결과 `false`합니다. 피연산자가 `false`, 결과 `true`합니다.

### <a name="bitwise-complement-operator"></a>비트 보수 연산자

폼의 작업에 대 한 `~x`, 단항 연산자 오버 로드 확인 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 및 결과의 형식은 연산자의 반환 형식입니다. 미리 정의 된 비트 보수 연산자는 다음과 같습니다.
```csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
```

이러한 연산자의 각각에 대 한 작업의 결과의 비트 보수 `x`합니다.

모든 열거형 형식 `E` 암시적으로 다음 비트 보수 연산자를 제공 합니다.

```csharp
E operator ~(E x);
```

평가 결과 `~x`, 여기서 `x` 열거형 형식의 식이 `E` 기본 형식을 사용 하 여 `U`, 같습니다 정확 하 게 평가 `(E)(~(U)x)`점을 제외 하 고로 변환 `E` 는 으로 항상 수행의 경우는 `unchecked` 컨텍스트 ([checked 및 unchecked 연산자](expressions.md#the-checked-and-unchecked-operators)).

### <a name="prefix-increment-and-decrement-operators"></a>전위 증가 및 감소 연산자

```antlr
pre_increment_expression
    : '++' unary_expression
    ;

pre_decrement_expression
    : '--' unary_expression
    ;
```

피연산자 전위 증가 또는 감소 작업 변수, 속성 액세스 또는 인덱서 액세스로 분류 되는 식 이어야 합니다. 작업의 결과 피연산자와 동일한 형식의 값입니다.

접두사의 피연산자가 증가 하는 경우 감소 작업은 속성 또는 인덱서 액세스, 속성 또는 인덱서 둘 다 있어야 합니다는 `get` 및 `set` 접근자입니다. 이 경우 바인딩 시간 오류가 발생 합니다.

단항 연산자 오버 로드 확인 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 미리 정의 된 `++` 하 고 `--` 연산자는 다음 형식에 대해 존재: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char` 를 `float`, `double`, `decimal`, 및 열거형 형식입니다. 미리 정의 된 `++` 연산자는 피연산자 및 미리 정의 된에 1을 추가 하 여 생성 한 값을 반환 `--` 연산자는 피연산자에서 1을 뺀 값으로 계산 된 값을 반환 합니다. 에 `checked` 컨텍스트를 결과 형식이 정수 계열 형식 또는 열거형 형식에는이 더하기 또는 빼기의 결과 결과 형식 범위를 벗어나는 경우는 `System.OverflowException` throw 됩니다.

접두사 증가 처리 하는 런타임 또는 폼의 작업 감소 `++x` 또는 `--x` 다음 단계로 구성 됩니다.

*   경우 `x` 변수로로 분류 됩니다.
    * `x` 변수를 생성 하기 위해 평가 됩니다.
    * 선택한 연산자의 값을 사용 하 여 호출 `x` 인수로 합니다.
    * 연산자로 반환 되는 값을 평가 하 여 지정 된 위치에 저장 됩니다 `x`합니다.
    * 연산자에서 반환 된 값에는 작업의 결과 됩니다.
*   경우 `x` 속성 또는 인덱서에 액세스로 분류 됩니다.
    * 인스턴스 식 (하는 경우 `x` 아닙니다 `static`) 및 인수 목록을 (경우 `x` 인덱서 액세스할)와 연결 된 `x` 평가 결과에서 사용 하는 후속 `get` 및 `set` 접근자 호출입니다.
    * 합니다 `get` 접근자의 `x` 가 호출 됩니다.
    * 선택한 연산자에서 반환 된 값을 사용 하 여 호출 되는 `get` 인수로 접근자입니다.
    * 합니다 `set` 의 접근자 `x` 으로 연산자로 반환 되는 값을 사용 하 여 호출 해당 `value` 인수입니다.
    * 연산자에서 반환 된 값에는 작업의 결과 됩니다.

합니다 `++` 하 고 `--` 연산자는 후 위 기능도 표기법 ([후 위 증가 및 감소 연산자](expressions.md#postfix-increment-and-decrement-operators)). 일반적으로 결과 `x++` 또는 `x--` 의 값인 `x` 작업 전에 반면 결과인 `++x` 또는 `--x` 의 값인 `x` 작업 후. 두 경우 모두 `x` 작업 후 같은 값을 가집니다.

`operator++` 또는 `operator--` 구현 후 위 또는 접두사 표기법을 사용 하 여 호출할 수 있습니다. 두 표기법이 대 한 별도 연산자 구현이 하는 것이 불가능 합니다.

### <a name="cast-expressions"></a>캐스트 식

A *cast_expression* 식이 지정된 된 형식으로 명시적으로 변환 하는 데 사용 됩니다.

```antlr
cast_expression
    : '(' type ')' unary_expression
    ;
```

*cast_expression* 양식의 `(T)E`여기서 `T` 는 *형식* 및 `E` 는 *unary_expression*, 명시적인 수행 변환 ([명시적 변환](conversions.md#explicit-conversions))의 값 `E` 형식으로 `T`입니다. 명시적 변환이 없는 경우 `E` 에 `T`, 바인딩 시간에 발생 합니다. 그렇지 않으면 결과 명시적 변환에 의해 생성 값입니다. 결과 항상 값으로 분류 됩니다. 경우에 `E` 변수를 나타냅니다.

에 대 한 문법을 *cast_expression* 특정 구문 모호성이 발생 합니다. 예를 들어 식 `(x)-y` 하거나로 해석 될 수는 *cast_expression* (캐스트 `-y` 형식으로 `x`) 또는 *additive_expression* 함께 *parenthesized_expression* (값을 계산 하는 `x - y)`합니다.

해결 하려면 *cast_expression* 모호성이 있으면 다음과 같은 규칙이 존재: 하나 이상의 시퀀스 *토큰*s ([공백](lexical-structure.md#white-space)) 묶인 괄호 안에 있는 것으로 간주 됩니다 시작 한 *cast_expression* 다음 중 하나 이상에 해당할 경우에:

*  토큰의 순서가 올바른 문법에 대 한는 *형식*, 아니라는 *식*합니다.
*  토큰의 순서가 올바른 문법에 대 한는 *형식*, 닫는 괄호 바로 다음에 오는 토큰은 토큰 및 "`~`", 토큰 "`!`", 토큰 "`(`",  *식별자* ([유니코드 문자 이스케이프 시퀀스인](lexical-structure.md#unicode-character-escape-sequences)), *리터럴* ([리터럴](lexical-structure.md#literals)), 또는 *키워드*([키워드](lexical-structure.md#keywords))를 제외한 `as` 고 `is`입니다.

용어 "올바른 문법" 위에 특정 문법 프로덕션 토큰 시퀀스를 따라야 한다는 것을 의미 합니다. 구체적으로 구성 하는 식별자의 실제 의미를 고려 하지 않습니다. 예를 들어 경우 `x` 및 `y` 있다면 식별자 `x.y` 형식에 대 한 올바른 문법은 경우에 `x.y` 실제로 형식을 나타내지.

경우 따릅니다는 명확성 규칙에서 `x` 및 `y` 가 식별자 인 `(x)y`, `(x)(y)`, 및 `(x)(-y)` 됩니다 *cast_expression*s, 하지만 `(x)-y` 그렇지 않을 경우에 `x` 형식을 식별 합니다. 그러나 경우 `x` 미리 정의 된 형식을 식별 하는 키워드 (같은 `int`), 다음 4 가지 형태가 모두 *cast_expression*s (이러한 키워드 수 있는 수 없으므로 식 자체).

### <a name="await-expressions"></a>Await 식

Await 연산자는 피연산자를 나타내는 비동기 작업이 완료 될 때까지 바깥쪽 비동기 함수를 일시 중단 됩니다.

```antlr
await_expression
    : 'await' unary_expression
    ;
```

*await_expression* 비동기 함수의 본문 에서만 허용 됩니다 ([반복기](classes.md#iterators)). 가장 가까운 바깥쪽 내 비동기 함수는 *await_expression* 이러한 위치에서 발생 하지 않을 수 있습니다.

*  중첩 된 (비동기가 아닌) 익명 함수 내에서
*  블록을 *lock_statement*
*  안전 하지 않은 컨텍스트에서

*await_expression* 내에서 대부분의 위치에 사용할 수 없습니다는 *query_expression*이므로 해당 구문이 비동기 람다 식을 사용 하 여 변환 됩니다.

비동기 함수 내에서 `await` 식별자로 사용할 수 없습니다. Await 식 및 식별자를 포함 하는 다양 한 식 사이 없는 구문 모호성이 되므로 합니다. 비동기 함수 외부에서 `await` 일반 식별자 역할을 합니다.

피연산자는 *await_expression* 라고 합니다 ***태스크***합니다. 되었거나 완전 하지 않을 경우에는 비동기 작업을 나타내므로 합니다 *await_expression* 평가 됩니다. Await 연산자의 목적은 대기 중인된 작업이 완료 될 때까지 바깥쪽 비동기 함수의 실행을 중단 하 고 그런 다음 해당 결과 가져옵니다.

#### <a name="awaitable-expressions"></a>대기 가능 식

Await 식이 작업 되어야 할 ***awaitable***합니다. 식을 `t` 비동기로 다음 중 하나를 보유 하는 경우:

*  `t` 컴파일 시간 형식입니다. `dynamic`
*  `t` 호출 액세스할 수 있는 인스턴스 또는 확장 메서드를 포함 `GetAwaiter` 매개 변수 없이 없는 형식 매개 변수 및 반환 형식을 `A` 저장한 다음이 모두는:
   * `A` 인터페이스를 구현 `System.Runtime.CompilerServices.INotifyCompletion` (이 이라고 `INotifyCompletion` 간략하게 표현 하기 위해)
   * `A` 에 액세스할 수 있는 읽을 수 있는 인스턴스 속성 `IsCompleted` 형식 `bool`
   * `A` 에 액세스할 수 있는 인스턴스 메서드가 `GetResult` 매개 변수 없이와 없는 형식 매개 변수

용도 `GetAwaiter` 가져오려고 메서드는는 ***awaiter*** 작업에 대 한 합니다. 형식 `A` 라고 합니다 ***awaiter 형식*** await 식에 대 한 합니다.

용도 `IsCompleted` 속성 작업은 이미 완료 하는 경우를 결정 하는 것입니다. 따라서 있는지 평가 일시 중단할 필요가 없습니다.

목적은 `INotifyCompletion.OnCompleted` 방법은 태스크; "continuation" 등록 하는 대리자, 즉 (형식의 `System.Action`) 작업이 완료 되 면 호출 되는.

용도 `GetResult` 메서드는 완료 되 면 작업의 결과 가져오려고 합니다. 이 결과 결과 값을 사용 하 여 성공적으로 완료 되었거나 예외가 throw 되는 것은 `GetResult` 메서드.

#### <a name="classification-of-await-expressions"></a>Await 식 분류

식을 `await t` 식과 동일한 방식으로 분류 됩니다 `(t).GetAwaiter().GetResult()`합니다. 따라서의 반환 형식이 `GetResult` 됩니다 `void`의 *await_expression* nothing으로 분류 됩니다. Void가 아닌 반환 형식이 있을 경우 `T`서 *await_expression* 형식의 값으로 분류 됩니다 `T`합니다.

#### <a name="runtime-evaluation-of-await-expressions"></a>런타임 평가 await 식

런타임에 식 `await t` 다음과 같이 평가 됩니다.

*  Awaiter `a` 식을 평가 하 여 가져온 `(t).GetAwaiter()`합니다.
*  A `bool` `b` 식을 평가 하 여 가져온 `(a).IsCompleted`합니다.
*  경우 `b` 됩니다 `false` 을 평가 하는지에 따라 다릅니다 `a` 인터페이스를 구현 `System.Runtime.CompilerServices.ICriticalNotifyCompletion` (이 이라고 `ICriticalNotifyCompletion` 간략하게 표현 하기 위해). 이 확인은 바인딩 시간;에서 수행 됩니다. 즉, 런타임에 경우 `a` 컴파일 시간 형식이 `dynamic`, 그렇지 않으면 컴파일 시간입니다. 수 있도록 `r` 다시 시작 대리자를 나타냅니다 ([반복기](classes.md#iterators)):
    * 경우 `a` 를 구현 하지 않습니다 `ICriticalNotifyCompletion`, 다음 식은 `(a as (INotifyCompletion)).OnCompleted(r)` 평가 됩니다.
    * 경우 `a` 는 구현 `ICriticalNotifyCompletion`, 다음 식은 `(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)` 평가 됩니다.
    * 평가 후 일시 중단 하 고 컨트롤이 비동기 함수의 현재 호출자에 게 반환 됩니다.
*  하거나 직후 (하는 경우 `b` 되었습니다 `true`), 또는 나중에 다시 시작 대리자의 호출 시 (경우 `b` 되었습니다 `false`), 식 `(a).GetResult()` 평가 됩니다. 값이 결과 값을 반환 하는 경우는 *await_expression*합니다. 그렇지 않으면 결과 아무 작업도 수행 합니다.

인터페이스 메서드의 awaiter 구현 `INotifyCompletion.OnCompleted` 및 `ICriticalNotifyCompletion.UnsafeOnCompleted` 대리자 시키는 `r` 한 번만 호출할 수 있습니다. 그렇지 않은 경우 바깥쪽 비동기 함수의 동작이 정의 되지 않습니다.

## <a name="arithmetic-operators"></a>산술 연산자

`*`, `/`를 `%`, `+`, 및 `-` 연산자는 산술 연산자 라고 합니다.

```antlr
multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;
```

산술 연산자의 피연산자는 컴파일 시간 형식에 있는지 `dynamic`, 다음 식이 동적으로 바인딩 되었는지 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 시간 식의 형식이 `dynamic`, 아래에 설명 된 해결 방법을 컴파일 시간 형식이 해당 피연산자의 런타임 형식을 사용 하 여 런타임 시 수행 됩니다 및 `dynamic`합니다.

### <a name="multiplication-operator"></a>곱하기 연산자

폼의 작업에 대 한 `x * y`, 이항 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 곱하기 연산자는 다음과 같습니다. 모든 연산자의 곱을 계산 합니다 `x` 고 `y`입니다.

*  정수 곱하기

   ```csharp
   int operator *(int x, int y);
   uint operator *(uint x, uint y);
   long operator *(long x, long y);
   ulong operator *(ulong x, ulong y);
   ```

   에 `checked` 제품 결과 형식 범위를 벗어난 경우 컨텍스트는 `System.OverflowException` throw 됩니다. 에 `unchecked` 컨텍스트에 오버플로 보고 되지 않으며 결과 형식 범위 밖에 있는 경우 중요 한 모든 상위 비트는 무시 됩니다.


*  부동 소수점 곱셈:

   ```csharp
   float operator *(float x, float y);
   double operator *(double x, double y);
   ```

   IEEE 754 산술 규칙에 따라 계산 됩니다. 다음 표에서 한정 된 0이 아닌 값의 가능한 모든 조합, 0으로, 무한대 및 NaN의 결과 나열합니다. 표에 `x` 고 `y` 유한 값이 양수입니다. `z` 결과인 `x * y`합니다. 결과가 너무 커서 대상 유형에 적합 이면 `z` 무한대 됩니다. 결과 대상 형식에 대해 너무 작으면 `z` 은 0입니다.

   |      |      |      |     |     |      |      |     |
   |:----:|-----:|:----:|:---:|:---:|:----:|:----:|:----|
   |      | + y   | -y   | +0  | -0  | +inf | -inf | NaN | 
   | + x   | + z   | -z   | +0  | -0  | +inf | -inf | NaN | 
   | -x   | -z   | + z   | -0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | -0   | +0  | -0  | NaN  | NaN  | NaN | 
   | -0   | -0   | +0   | -0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | 

*  10 진수 곱하기.

   ```csharp
   decimal operator *(decimal x, decimal y);
   ```

   결과 값이 너무 커서에 나타낼 수 없는 경우는 `decimal` 형식으로는 `System.OverflowException` throw 됩니다. 결과 값이 너무 작아서 나타낼 수 없는 경우는 `decimal` 형식으로 결과 0입니다. 모든 반올림 하기 전에 결과의 배율은 두 피연산자의 눈금의 합계입니다.

   곱하기 10 진수 형식의 곱하기 연산자를 사용 하 여 동일 `System.Decimal`합니다.


### <a name="division-operator"></a>나누기 연산자

폼의 작업에 대 한 `x / y`, 이항 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 나누기 연산자는 다음과 같습니다. 모든 연산자의 몫을 계산 `x` 고 `y`입니다.

*  정수 나누기의 경우:

   ```csharp
   int operator /(int x, int y);
   uint operator /(uint x, uint y);
   long operator /(long x, long y);
   ulong operator /(ulong x, ulong y);
   ```

   오른쪽 피연산자의 값이 0 인 경우는 `System.DivideByZeroException` throw 됩니다.

   나누기 0으로 반올림 합니다. 따라서 결과의 절대값은 두 피연산자의 몫의 절대 값 보다 작거나는 가장 큰 정수입니다. 결과 두 피연산자와 동일한 로그인이 있고 0 또는 음수 기호가 두 피연산자의 경우 0 또는 양수입니다.

   왼쪽된 피연산자가 가장 작은 표현할 수 있는 경우 `int` 나 `long` 값과 오른쪽 피연산자는 `-1`, 오버플로가 발생 합니다. 에 `checked` 컨텍스트, 이렇게 하면를 `System.ArithmeticException` (또는 그 하위 클래스) throw 됩니다. 에 `unchecked` 컨텍스트에 것 여부에 대 한 구현 시 정의 `System.ArithmeticException` (또는 그 하위 클래스)이 throw 됩니다 결과 왼쪽된 피연산자의 값을 사용 하 여 오버플로 보고 되지 않은 이동 또는 합니다.

*  부동 소수점 나누기의 경우:

   ```csharp
   float operator /(float x, float y);
   double operator /(double x, double y);
   ```

   몫 산술 IEEE 754 규칙에 따라 계산 됩니다. 다음 표에서 한정 된 0이 아닌 값의 가능한 모든 조합, 0으로, 무한대 및 NaN의 결과 나열합니다. 표에 `x` 고 `y` 유한 값이 양수입니다. `z` 결과인 `x / y`합니다. 결과가 너무 커서 대상 유형에 적합 이면 `z` 무한대 됩니다. 결과 대상 형식에 대해 너무 작으면 `z` 은 0입니다.

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | + x   | + z   | -z   | +inf | -inf | +0   | -0   | NaN  | 
   | -x   | -z   | + z   | -inf | +inf | -0   | +0   | NaN  | 
   | +0   | +0   | -0   | NaN  | NaN  | +0   | -0   | NaN  | 
   | -0   | -0   | +0   | NaN  | NaN  | -0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  10 진수 나누기의 경우:

   ```csharp
   decimal operator /(decimal x, decimal y);
   ```

   오른쪽 피연산자의 값이 0 인 경우는 `System.DivideByZeroException` throw 됩니다. 결과 값이 너무 커서에 나타낼 수 없는 경우는 `decimal` 형식으로는 `System.OverflowException` throw 됩니다. 결과 값이 너무 작아서 나타낼 수 없는 경우는 `decimal` 형식으로 결과 0입니다. 결과의 소수 자릿수가 유지 하는 결과 같은 가장 작은 눈금을 표현할 수 있는 10 진수 값을 true 수학 결과 가장 가까운 합니다.

   10 진수 나누기 형식의 나누기 연산자를 사용 하 여 동일 `System.Decimal`합니다.


### <a name="remainder-operator"></a>나머지 연산자

폼의 작업에 대 한 `x % y`, 이항 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 나머지 연산자는 다음과 같습니다. 모든 연산자 간 나누기의 나머지를 계산 `x` 고 `y`입니다.

*  정수 나머지:

   ```csharp
   int operator %(int x, int y);
   uint operator %(uint x, uint y);
   long operator %(long x, long y);
   ulong operator %(ulong x, ulong y);
   ```

   결과인 `x % y` 값으로 생성 `x - (x / y) * y`합니다. 하는 경우 `y` 가 0 이면는 `System.DivideByZeroException` throw 됩니다.

   왼쪽된 피연산자가 가장 작은 `int` 또는 `long` 값 이며 오른쪽 피연산자 `-1`, `System.OverflowException` throw 됩니다. 없는 경우에는 `x % y` 예외를 throw 여기서 `x / y` 은 예외를 throw 하지 않습니다.

*  부동 소수점 나머지:

   ```csharp
   float operator %(float x, float y);
   double operator %(double x, double y);
   ```

   다음 표에서 한정 된 0이 아닌 값의 가능한 모든 조합, 0으로, 무한대 및 NaN의 결과 나열합니다. 표에 `x` 고 `y` 유한 값이 양수입니다. `z` 결과인 `x % y` 로 계산 됩니다 `x - n * y`, 여기서 `n` 보다 작거나 같은 가장 큰 정수는 `x / y`합니다. 나머지 컴퓨팅이 메서드는 정수 피연산자에 사용 되는 것과 유사 하지만 IEEE 754 정의에서 다릅니다 (나타나는 `n` 정수를 가장 가까운 `x / y`).

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | + x   | + z   | + z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | -0   | -0   | -0   | NaN  | NaN  | -0   | -0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  10 진수 나머지:

   ```csharp
   decimal operator %(decimal x, decimal y);
   ```

   오른쪽 피연산자의 값이 0 인 경우는 `System.DivideByZeroException` throw 됩니다. 모든 반올림 하기 전에 결과의 소수 자릿수가 두 피연산자 중 확장 중 더 큰 이며 결과의 기호를 0이 아닌 경우와 동일한 `x`입니다.

   나머지 10 진수 형식의 나머지 연산자를 사용 하 여 동일 `System.Decimal`합니다.


### <a name="addition-operator"></a>더하기 연산자

폼의 작업에 대 한 `x + y`, 이항 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 더하기 연산자는 다음과 같습니다. 숫자 및 열거형 형식에 대 한 미리 정의 된 더하기 연산자는 두 피연산자의 합계를 계산 합니다. 피연산자 하나 또는 둘 다 문자열 형식의 경우 미리 정의 된 더하기 연산자는 피연산자의 문자열 표현을 연결 합니다.

*  정수 추가:

   ```csharp
   int operator +(int x, int y);
   uint operator +(uint x, uint y);
   long operator +(long x, long y);
   ulong operator +(ulong x, ulong y);
   ```

   에 `checked` 합계 결과 형식 범위를 벗어난 경우 컨텍스트는 `System.OverflowException` throw 됩니다. 에 `unchecked` 컨텍스트에 오버플로 보고 되지 않으며 결과 형식 범위 밖에 있는 경우 중요 한 모든 상위 비트는 무시 됩니다.

*  부동 소수점 더하기의 경우:

   ```csharp
   float operator +(float x, float y);
   double operator +(double x, double y);
   ```

   합계는 산술 IEEE 754 규칙에 따라 계산 됩니다. 다음 표에서 한정 된 0이 아닌 값의 가능한 모든 조합, 0으로, 무한대 및 NaN의 결과 나열합니다. 표에 `x` 및 `y` 유한 값이 0이 아닌, 및 `z` 결과인 `x + y`합니다. 경우 `x` 하 고 `y` 동일한 크기가 있는 하지만 부호가 반대 `z` 양의 0. 하는 경우 `x + y` 너무 커서 대상 형식에 나타낼 `z` 같은 부호를 사용 하 여 무한대 인지 `x + y`합니다.

   |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | y    | +0   | -0   | +inf | -inf | NaN  | 
   | x    | z    | x    | x    | +inf | -inf | NaN  | 
   | +0   | y    | +0   | +0   | +inf | -inf | NaN  | 
   | -0   | y    | +0   | -0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  10 진수 추가:

   ```csharp
   decimal operator +(decimal x, decimal y);
   ```

   결과 값이 너무 커서에 나타낼 수 없는 경우는 `decimal` 형식으로는 `System.OverflowException` throw 됩니다. 모든 반올림 하기 전에 결과의 소수 자릿수가 두 피연산자의 확장 중 큰 값입니다.

   10 진수 추가 사용 하는 형식의 더하기 연산자 `System.Decimal`합니다.

*  열거형을 추가 합니다. 모든 열거형 형식은 다음 미리 정의 된 연산자를 암시적으로 제공 위치 `E` 은 열거형 형식 및 `U` 의 기본 형식인 `E`:

   ```csharp
   E operator +(E x, U y);
   E operator +(U x, E y);
   ```

   런타임 시 이러한 연산자와 동일 하 게 계산 됩니다 `(E)((U)x + (U)y)`합니다.

*  문자열 연결:

   ```csharp
   string operator +(string x, string y);
   string operator +(string x, object y);
   string operator +(object x, string y);
   ```

   이러한 오버 로드 된 이진 파일의 `+` 연산자 문자열 연결을 수행 합니다. 피연산자 문자열 연결의 경우 `null`, 빈 문자열은 대체 됩니다. 가상 호출 하 여 해당 문자열 표현으로 문자열이 아닌 인수가 변환 되는 고, 그렇지 `ToString` 형식에서 상속 된 메서드 `object`합니다. 하는 경우 `ToString` 반환 `null`, 빈 문자열은 대체 됩니다.

   ```csharp
   using System;
   
   class Test
   {
       static void Main() {
           string s = null;
           Console.WriteLine("s = >" + s + "<");        // displays s = ><
           int i = 1;
           Console.WriteLine("i = " + i);               // displays i = 1
           float f = 1.2300E+15F;
           Console.WriteLine("f = " + f);               // displays f = 1.23E+15
           decimal d = 2.900m;
           Console.WriteLine("d = " + d);               // displays d = 2.900
       }
   }
   ```

   문자열 연결 연산자의 결과 오른쪽 피연산자의 문자 뒤에 왼쪽된 피연산자의 문자로 구성 된 문자열입니다. 문자열 연결 연산자는 반환 하지 않습니다는 `null` 값입니다. `System.OutOfMemoryException` 결과 문자열에 할당할 수 있는 충분 한 메모리가 없을 경우에 throw 될 수 있습니다.

*  대리자 결합 합니다. 다음 미리 정의 된 연산자를 암시적으로 제공 하는 모든 대리자 형식 여기서 `D` 대리자 형식입니다.

   ```csharp
   D operator +(D x, D y);
   ```

   이진 `+` 연산자는 피연산자가 모두 대리자 일종의 경우 대리자 결합을 수행 `D`합니다. (피연산자가 서로 다른 대리자 형식에 있으면 바인딩 시간 오류를 발생 합니다.) 첫 번째 피연산자가 `null`, 작업의 결과 두 번째 피연산자의 값 (이기도 하는 경우에 `null`). 그렇지 않으면 두 번째 피연산자가 `null`, 작업의 결과 첫 번째 피연산자의 값입니다. 이 고, 그렇지 연산의 결과 새 대리자 인스턴스가 호출, 첫 번째 피연산자를 호출 하 고, 다음 두 번째 피연산자를 호출 하는 경우. 대리자 결합의 예제를 참조 하세요 [빼기 연산자](expressions.md#subtraction-operator) 하 고 [대리자 호출](delegates.md#delegate-invocation)합니다. 이후 `System.Delegate` 대리자 형식이 아닙니다 `operator` `+` 에 대 한 정의 되지 않았습니다.

### <a name="subtraction-operator"></a>빼기 연산자

폼의 작업에 대 한 `x - y`, 이항 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 빼기 연산자는 다음과 같습니다. 모든 빼기 연산자 `y` 에서 `x`합니다.

*  정수 빼기

   ```csharp
   int operator -(int x, int y);
   uint operator -(uint x, uint y);
   long operator -(long x, long y);
   ulong operator -(ulong x, ulong y);
   ```

   에 `checked` 차이 결과 형식 범위를 벗어난 경우 컨텍스트는 `System.OverflowException` throw 됩니다. 에 `unchecked` 컨텍스트에 오버플로 보고 되지 않으며 결과 형식 범위 밖에 있는 경우 중요 한 모든 상위 비트는 무시 됩니다.

*  부동 소수점 빼기

   ```csharp
   float operator -(float x, float y);
   double operator -(double x, double y);
   ```

   차이점은 산술 IEEE 754 규칙에 따라 계산 됩니다. 다음 표에서 한정 된 0이 아닌 값의 가능한 모든 조합, 0으로, 무한대 및 Nan 결과 나열합니다. 표에 `x` 및 `y` 유한 값이 0이 아닌, 및 `z` 결과인 `x - y`합니다. 하는 경우 `x` 하 고 `y` 같지 `z` 양의 0입니다. 하는 경우 `x - y` 너무 커서 대상 형식에 나타낼 `z` 같은 부호를 사용 하 여 무한대 인지 `x - y`합니다.

   |      |      |      |      |      |      |     |
   |:----:|:----:|:----:|:----:|:----:|:----:|:---:|
   | NaN  | y    | +0   | -0   | +inf | -inf | NaN | 
   | x    | z    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | -0   | -y   | -0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | 

*  10 진수 빼기의 경우:

   ```csharp
   decimal operator -(decimal x, decimal y);
   ```

   결과 값이 너무 커서에 나타낼 수 없는 경우는 `decimal` 형식으로는 `System.OverflowException` throw 됩니다. 모든 반올림 하기 전에 결과의 소수 자릿수가 두 피연산자의 확장 중 큰 값입니다.

   10 진수 빼기 형식의 빼기 연산자를 사용 하 여 동일 `System.Decimal`합니다.

*  열거형 빼기입니다. 모든 열거형은 다음과 같은 미리 정의 된 연산자를 암시적으로 제공 위치 `E` 은 열거형 형식 및 `U` 의 기본 형식인 `E`:

   ```csharp
   U operator -(E x, E y);
   ```

   이 연산자는 대로 정확 하 게 계산 됩니다 `(U)((U)x - (U)y)`합니다. 연산자의 서 수 값 간의 차이 계산 하는, 즉 `x` 및 `y`, 고 결과의 형식 열거형의 기본 형식입니다.

   ```csharp
   E operator -(E x, U y);
   ```

   이 연산자는 대로 정확 하 게 계산 됩니다 `(E)((U)x - y)`합니다. 즉, 연산자는 열거형의 값이 구해지 기 열거형의 내부 형식에서 값을 뺍니다.

*  제거를 위임 합니다. 다음 미리 정의 된 연산자를 암시적으로 제공 하는 모든 대리자 형식 여기서 `D` 대리자 형식입니다.

   ```csharp
   D operator -(D x, D y);
   ```

   이진 `-` 연산자는 피연산자가 모두 대리자 일종의 경우 대리자 제거를 수행 `D`합니다. 피연산자가 서로 다른 대리자 형식 바인딩 시간 오류가 발생 합니다. 첫 번째 피연산자가 `null`, 작업의 결과 `null`합니다. 그렇지 않으면 두 번째 피연산자가 `null`, 작업의 결과 첫 번째 피연산자의 값입니다. 두 피연산자의 호출 목록을 나타내는 고, 그렇지 ([대리자 선언](delegates.md#delegate-declarations)) 하나 이상의 항목을 선택한 결과 것이 첫 번째 피연산자의 목록에서 제거 하는 두 번째 피연산자의 항목으로 구성 된 새 호출 목록 두 번째 피연산자의 목록을 제공 하는 첫 번째의 적절 한 연속 하위 목록입니다.     (하위 목록 같은지를 확인 하려면 해당 항목을 대리자 같음 연산자와 비교 ([같음 연산자를 대리자](expressions.md#delegate-equality-operators)).) 그렇지 않으면 결과 왼쪽된 피연산자의 값입니다. 모두 피연산자 목록은 과정에서 변경 됩니다. 두 번째 피연산자의 목록에 여러 하위 목록의 첫 번째 피연산자의 목록에서 인접 한 항목의 일치 하는 경우 인접 한 항목의 가장 오른쪽에 일치 하는 하위 목록 제거 됩니다. 결과 빈 목록에서 제거 결과 경우 `null`합니다. 예를 들어:

   ```csharp
   delegate void D(int x);
   
   class C
   {
       public static void M1(int i) { /* ... */ }
       public static void M2(int i) { /* ... */ }
   }

   class Test
   {
       static void Main() { 
           D cd1 = new D(C.M1);
           D cd2 = new D(C.M2);
           D cd3 = cd1 + cd2 + cd2 + cd1;   // M1 + M2 + M2 + M1
           cd3 -= cd1;                      // => M1 + M2 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd2;                // => M2 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd2;                // => M1 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd1;                // => M1 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd1;                // => M1 + M2 + M2 + M1
       }
   }
   ```

## <a name="shift-operators"></a>시프트 연산자

합니다 `<<` 고 `>>` 연산자는 비트 시프트 연산을 수행 하는 데 사용 됩니다.

```antlr
shift_expression
    : additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression right_shift additive_expression
    ;
```

경우의 피연산자는 *shift_expression* 컴파일 시간 형식이 `dynamic`, 다음 식이 동적으로 바인딩 되었는지 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 시간 식의 형식이 `dynamic`, 아래에 설명 된 해결 방법을 컴파일 시간 형식이 해당 피연산자의 런타임 형식을 사용 하 여 런타임 시 수행 됩니다 및 `dynamic`합니다.

폼의 작업에 대 한 `x << count` 또는 `x >> count`, 이항 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

오버 로드 된 시프트 연산자를 선언할 때 첫 번째 피연산자의 형식은 항상 이어야 클래스 또는 구조체 연산자 선언에 포함 된 하며 두 번째 피연산자의 형식은 항상 해야 `int`합니다.

미리 정의 된 시프트 연산자는 다음과 같습니다.

*  왼쪽으로 이동 합니다.

   ```csharp
   int operator <<(int x, int count);
   uint operator <<(uint x, int count);
   long operator <<(long x, int count);
   ulong operator <<(ulong x, int count);
   ```

   합니다 `<<` 연산자 shifts `x` 비트 수 만큼 왼쪽 아래에 설명 된 대로 계산 합니다.

   결과 형식 범위 밖에 있는 경우 상위 비트 `x` 는 삭제, 나머지 비트를 왼쪽으로 시프트는 및 낮은 빈 비트 위치가 0으로 설정 됩니다.

*  오른쪽으로 이동 합니다.

   ```csharp
   int operator >>(int x, int count);
   uint operator >>(uint x, int count);
   long operator >>(long x, int count);
   ulong operator >>(ulong x, int count);
   ```

   합니다 `>>` 연산자 shifts `x` 비트 수 만큼 오른쪽 아래에 설명 된 대로 계산 합니다.

   때 `x` 형식입니다 `int` 또는 `long`의 하위 비트로 `x` 는 무시 나머지 비트는 오른쪽으로 시프트 하 고 높은 차수의 빈 비트 위치는 0으로 설정 됩니다 `x` 이며 음수가 아닌 설정 중 하나를 `x` 음수입니다.

   때 `x` 유형의 `uint` 또는 `ulong`의 낮은 순서 비트 `x` 는 상위 빈 비트 위치는 0으로 설정 및 삭제 하 고, 나머지 비트는 오른쪽으로 시프트 합니다.

미리 정의 된 연산자에 대 한 이동할 비트 수는 다음과 같이 계산 됩니다.

*  때 유형의 `x` 됩니다 `int` 또는 `uint`의 하위 5 비트로 시프트 수가 지정 됩니다 `count`합니다. 시프트 수가 계산 되는 즉, `count & 0x1F`합니다.
*  때 유형의 `x` 됩니다 `long` 또는 `ulong`의 하위 6 비트로 시프트 수가 지정 됩니다 `count`합니다. 시프트 수가 계산 되는 즉, `count & 0x3F`합니다.

시프트 연산자의 값을 단순히 반환 결과 시프트 수가 0 인 경우 `x`합니다.

오버플로 일으키지 및에서 동일한 결과 생성 하지 시프트 연산을 `checked` 고 `unchecked` 컨텍스트.

때의 왼쪽된 피연산자는 `>>` 연산자는 부호 있는 정수 형식, 연산자는 산술 오른쪽 시프트는 피연산자의 가장 중요 한 비트 (부호 비트)의 값이 전파 됩니다 여기서 상위 빈 비트 위치로 수행 합니다. 때의 왼쪽된 피연산자는 `>>` 연산자는 부호 없는 정수 형식, 연산자는 논리 시프트 수행 바로 여기서 상위 빈 비트 위치는 항상 0으로 설정 합니다. 피연산자 형식에서 유추 되는 연산의 반대 작업을 수행 하려면 명시적 캐스트를 사용할 수 있습니다. 예를 들어 경우 `x` 형식의 변수가 `int`, 작업 `unchecked((int)((uint)x >> y))` 오른쪽 논리 시프트를 수행 `x`합니다.

## <a name="relational-and-type-testing-operators"></a>관계형 및 형식 테스트 연산자

`==`, `!=`, `<`, `>`를 `<=`를 `>=`를 `is` 및 `as` 연산자는 관계형 및 형식 테스트 연산자 라고 합니다.

```antlr
relational_expression
    : shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    | relational_expression 'is' type
    | relational_expression 'as' type
    ;

equality_expression
    : relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;
```

합니다 `is` 연산자에 설명 되어 [는 연산자가](expressions.md#the-is-operator) 및 `as` 연산자에 설명 되어 [As 연산자](expressions.md#the-as-operator)합니다.

`==`, `!=`, `<`, `>`, `<=` 하 고 `>=` 연산자는 ***비교 연산자***합니다.

비교 연산자의 피연산자는 컴파일 시간 형식에 있는지 `dynamic`, 다음 식이 동적으로 바인딩 되었는지 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 시간 식의 형식이 `dynamic`, 아래에 설명 된 해결 방법을 컴파일 시간 형식이 해당 피연산자의 런타임 형식을 사용 하 여 런타임 시 수행 됩니다 및 `dynamic`합니다.

폼의 작업에 대 한 `x` *op* `y`여기서 *op* 는 비교 연산자를 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution))는 특정 연산자 구현 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 비교 연산자는 다음 섹션에서 설명 됩니다. 형식의 결과 반환 하는 모든 미리 정의 된 비교 연산자 `bool`다음 표에 설명 된 대로 합니다.


| __작업__ | __결과__                                                       |
|---------------|------------------------------------------------------------------|
| `x == y`      | `true` 하는 경우 `x` 값과 같음 `y`, `false` 그렇지 않은 경우                 | 
| `x != y`      | `true` 하는 경우 `x` 같지 `y`, `false` 그렇지 않은 경우             | 
| `x < y`       | `true` 하는 경우 `x` 는 보다 작은 `y`, `false` 그렇지 않은 경우                | 
| `x > y`       | `true` 하는 경우 `x` 보다 크면 `y`, `false` 그렇지 않은 경우             | 
| `x <= y`      | `true` 하는 경우 `x` 보다 작거나 같음 `y`, `false` 그렇지 않은 경우    | 
| `x >= y`      | `true` 하는 경우 `x` 보다 크거나 같음 `y`, `false` 그렇지 않은 경우 | 

### <a name="integer-comparison-operators"></a>정수 비교 연산자

미리 정의 된 정수 비교 연산자는 다음과 같습니다.
```csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);

bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);

bool operator <(int x, int y);
bool operator <(uint x, uint y);
bool operator <(long x, long y);
bool operator <(ulong x, ulong y);

bool operator >(int x, int y);
bool operator >(uint x, uint y);
bool operator >(long x, long y);
bool operator >(ulong x, ulong y);

bool operator <=(int x, int y);
bool operator <=(uint x, uint y);
bool operator <=(long x, long y);
bool operator <=(ulong x, ulong y);

bool operator >=(int x, int y);
bool operator >=(uint x, uint y);
bool operator >=(long x, long y);
bool operator >=(ulong x, ulong y);
```

두 정수 피연산자와 반환의 숫자 값을 비교 하 여 이러한 각 연산자는 `bool` 특정 관계 인지 여부를 나타내는 값 `true` 또는 `false`합니다.

### <a name="floating-point-comparison-operators"></a>부동 소수점 비교 연산자

미리 정의 된 부동 소수점 비교 연산자는 다음과 같습니다.
```csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);

bool operator !=(float x, float y);
bool operator !=(double x, double y);

bool operator <(float x, float y);
bool operator <(double x, double y);

bool operator >(float x, float y);
bool operator >(double x, double y);

bool operator <=(float x, float y);
bool operator <=(double x, double y);

bool operator >=(float x, float y);
bool operator >=(double x, double y);
```

연산자는 IEEE 754 표준 규칙에 따라 피연산자를 비교 합니다.

*  결과 피연산자 중 하나가 NaN 이면 `false` 제외한 모든 연산자에 대 한 `!=`, 결과 인 `true`합니다. 모든 두 피연산자에 대 한 `x != y` 와 동일한 결과가 항상 `!(x == y)`합니다. 그러나 하나 혹은 두 피연산자로 경우 NaN 합니다 `<`, `>`를 `<=`, 및 `>=` 연산자 반대 연산자의 논리 부정으로 동일한 결과 생성 하지. 예를 들어 경우의 `x` 및 `y` NaN 이면 `x < y` 됩니다 `false`, 하지만 `!(x >= y)` 는 `true`합니다.
*  연산자를 순서 대로 부동 소수점 두 피연산자의 값을 비교 피연산자가 모두 NaN,

   ```
   -inf < -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +inf
   ```

   여기서 `min` 및 `max` 최소 및 최대 양수 유한 값은 지정 된 부동 소수점 형식으로 표현할 수 있습니다. 이렇게 순서를 지정 하는 주목할 만한 미치는 다음과 같습니다.
   * 양수 및 음수 0으로 간주 됩니다.
   * 음의 무한대는 다른 모든 값 보다는 같지만 다른 음의 무한대로 작을 간주 됩니다.
   * 다른 모든 값을 초과 하지만 다른 양의 무한대와 양의 무한대로 간주 됩니다.

### <a name="decimal-comparison-operators"></a>10 진수 비교 연산자

미리 정의 된 10 진수 비교 연산자는 다음과 같습니다.
```csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator <(decimal x, decimal y);
bool operator >(decimal x, decimal y);
bool operator <=(decimal x, decimal y);
bool operator >=(decimal x, decimal y);
```

두 개의 10 진수 피연산자와 반환의 숫자 값을 비교 하 여 이러한 각 연산자는 `bool` 특정 관계 인지 여부를 나타내는 값 `true` 또는 `false`합니다. 10 진수 각 비교는 해당 관계 나 형식의 같음 연산자를 사용 하 여 `System.Decimal`입니다.

### <a name="boolean-equality-operators"></a>부울 같음 연산자

미리 정의 된 부울 같음 연산자는 다음과 같습니다.
```csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
```

결과 `==` 는 `true` 둘 다 `x` 및 `y` 됩니다 `true` 둘 다 또는 `x` 및 `y` 는 `false`합니다. 그렇지 않으면 결과 `false`합니다.

결과 `!=` 는 `false` 둘 다 `x` 및 `y` 됩니다 `true` 둘 다 또는 `x` 및 `y` 는 `false`합니다. 그렇지 않으면 결과 `true`합니다. 형식의 피연산자가 하는 경우 `bool`는 `!=` 연산자와 동일한 결과 생성 합니다 `^` 연산자입니다.

### <a name="enumeration-comparison-operators"></a>열거형 비교 연산자

모든 열거형에는 다음 미리 정의 된 비교 연산자를 암시적으로 제공합니다.
```csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator <(E x, E y);
bool operator >(E x, E y);
bool operator <=(E x, E y);
bool operator >=(E x, E y);
```

평가 결과 `x op y`여기서 `x` 하 고 `y` 열거형 형식의 식이 `E` 기본 형식을 사용 하 여 `U`, 및 `op` 는 비교 연산자 중 하나를 정확 하 게 동일 평가 `((U)x) op ((U)y)`합니다. 즉, 열거형 형식 비교 연산자는 단순히 두 피연산자의 기본 정수 값을 비교합니다.

### <a name="reference-type-equality-operators"></a>참조 형식이 같음 연산자

미리 정의 된 참조 형식이 같음 연산자는 다음과 같습니다.
```csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
```

연산자는 두 참조 같음 또는 같지 않은지 비교의 결과 반환 합니다.

미리 정의 된 참조 형식이 같음 연산자 형식의 피연산자를 사용할 수 있으므로 `object`를 선언 하지 마십시오. 해당 하는 모든 형식에 적용 `operator ==` 고 `operator !=` 멤버입니다. 반대로, 모든 적용 가능한 사용자 정의 같음 연산자는 효과적으로 미리 정의 된 참조 형식이 같음 연산자를 숨깁니다.

미리 정의 된 참조 형식이 같음 연산자에는 다음 중 하나 필요합니다.

*  두 피연산자가 모두 것으로 알려진 형식의 값을 *reference_type* 또는 리터럴 `null`합니다. 또한 명시적 참조 변환이 ([명시적 참조 변환을](conversions.md#explicit-reference-conversions)) 두 피연산자의 형식에서 다른 피연산자의 형식으로 존재 합니다.
*  한 피연산자가 형식의 값입니다 `T` 여기서 `T` 는 *type_parameter* 이 고 다른 피연산자가 리터럴 `null`합니다. 또한 `T` 값 형식 제약 조건이 없습니다.

이러한 조건 중 하나가 true 인 경우가 아니면 바인딩 시간 오류를 발생 합니다. 이러한 규칙의 주목할 만한 영향 다음과 같습니다.

*  이 미리 정의 된 참조 형식이 같음 연산자를 사용 하 여 바인딩 시간에 다른 것으로 알려져 있는 두 개의 참조를 비교할에 바인딩 시간 오류입니다. 예를 들어 바인딩 시간에 대 한 유형의 피연산자가 두 클래스 형식인 경우 `A` 및 `B`, 경우 모두 `A` 도 `B` 는 것이 불가능 동일한 개체를 참조 하는 두 피연산자에 대 한 다음 다른에서 파생 됩니다. 따라서 작업 바인딩 시간 오류로 간주 됩니다.
*  미리 정의 된 참조 형식이 같음 연산자 값 형식 피연산자 비교할 허용 하지 않습니다. 따라서 구조체 형식이 고유한 같음 연산자를 선언 하지 않으면 수 없는 해당 구조체 형식의 값을 비교 합니다.
*  미리 정의 된 참조 형식이 같음 연산자는 피연산자에 대 한 되려면 boxing 작업을 일으키지 않습니다. 새로 할당 된 boxed 인스턴스에 대 한 참조는 다른 모든 참조에서 다를 반드시 하므로 이러한 boxing 작업을 수행 하는 의미 없는 것입니다.
*  경우 형식 매개 변수 형식의 피연산자 `T` 비교할 `null`, 및 런타임 유형의 `T` 형식인 값 비교의 결과 `false`.

다음 예제에서는 제한 되지 않은 형식 매개 변수 형식의 인수 인지 확인 `null`합니다.
```csharp
class C<T>
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
```

합니다 `x == null` 구문도 허용 됩니다 `T` 결과 단순히 되도록 정의 및 값 형식에 나타낼 수 있습니다 `false` 때 `T` 값 형식인 합니다.

폼의 작업에 대 한 `x == y` 또는 `x != y`해당 하는 경우 `operator ==` 또는 `operator !=` 존재 연산자 오버 로드 확인 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 하는 규칙 선택 미리 정의 된 참조 형식의 같음 연산자 대신 연산자입니다. 그러나 것이 항상 미리 정의 된 참조 형식의 같음 연산자의 피연산자는 형식 중 하나 또는 모두를 명시적으로 캐스팅 하 여 선택할 수 `object`입니다. 이 예제에서
```csharp
using System;

class Test
{
    static void Main() {
        string s = "Test";
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
```
는 출력을 생성합니다.
```
True
False
False
False
```

`s` 하 고 `t` 별개의 두 변수 참조 `string` 같은 문자가 포함 되는 인스턴스. 첫 번째 비교 출력 `True` 때문에 미리 정의 된 문자열 같음 연산자 ([문자열 같음 연산자](expressions.md#string-equality-operators)) 형식의 두 피연산자가 선택 됩니다 `string`합니다. 나머지 모든 비교 출력 `False` 미리 정의 된 참조 형식의 같음 연산자는 피연산자 중 하나 이상이 유형이 면 선택한 없기 때문에 `object`입니다.

참고에서 위의 방법을 값 형식에 대해 의미가 없습니다. 이 예제에서
```csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
```
출력 `False` 캐스팅의 두 가지 별도 인스턴스에 대 한 참조를 만들기 때문에 boxed `int` 값입니다.

### <a name="string-equality-operators"></a>문자열 같음 연산자

미리 정의 된 문자열 같음 연산자는 다음과 같습니다.
```csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
```

두 `string` 값 중 하나가 true 인 경우 같다고 간주 됩니다.

*  값이 모두 `null`합니다.
*  두 값은 null이 아닌 각 문자 위치에 동일한 길이 및 똑같은 문자가 있는 문자열 인스턴스에 대 한 참조입니다.

문자열 같음 연산자는 문자열 참조가 아닌 문자열 값을 비교합니다. 동일한 일련의 문자를 포함 하는 두 개의 별도 문자열 인스턴스를 하는 경우 문자열의 값이 같으면 하지만 참조는 다릅니다. 에 설명 된 대로 [참조 형식이 같음 연산자](expressions.md#reference-type-equality-operators), 참조 형식이 같음 연산자를 사용 하 여 문자열 값 대신 문자열 참조를 비교할 수 있습니다.

### <a name="delegate-equality-operators"></a>대리자 같음 연산자

모든 대리자 형식에는 다음과 같은 미리 정의 된 비교 연산자를 암시적으로 제공합니다.

```csharp
bool operator ==(System.Delegate x, System.Delegate y);
bool operator !=(System.Delegate x, System.Delegate y);
```

두 명의 대리자 인스턴스가 동일한 지 다음과 같습니다.

*  대리자 인스턴스 중 하나에 해당 하는 경우 `null`, 경우에 둘 다 같은지 `null`합니다.
*  대리자는 항상 서로 다른 런타임 형식이 있으면 합니다.
*  대리자 인스턴스 둘 다 호출 목록이 있으면 ([대리자 선언](delegates.md#delegate-declarations)), 경우에 해당 호출 목록이 동일한 길이 되며 호출 목록의 각 항목은 같은 (아래 정의)은 해당 인스턴스가 같으면 해당 항목에 다른의 호출 목록에서 주문 합니다.

호출 목록 항목의 일치 여부를 제어 하는 다음 규칙:

*  두 개의 호출 목록 항목이 모두 동일한 정적 참조 이면 메서드 다음 항목은 같습니다.
*  (정의 된 대로 참조 같음 연산자) 두 개의 호출 목록 항목이 모두 동일한 대상 개체 동일한 비정적 메서드를 참조 하는 경우 다음 항목은 같습니다.
*  호출 목록 항목과 의미상 동일 평가에서 생성 된 *anonymous_method_expression*s 또는 *lambda_expression*캡처된 외부 변수 (비어 있을 수 있는) 집합이 함께 인스턴스는 허용 (하지만 필요 하지 않습니다)과 같아야 합니다.

### <a name="equality-operators-and-null"></a>같음 연산자 및 null

합니다 `==` 및 `!=` 연산자를 nullable 형식 및 다른 값으로 피연산자 하나를 허용 합니다 `null` 리터럴, 미리 정의 되거나 사용자 정의 연산자 (에서 unlifted 또는 폼 리프트) 작업에 대해 존재 하는 경우에 합니다.

작업의 형식 중 하나
```csharp
x == null
null == x
x != null
null != x
```
여기서 `x` 연산자 오버 로드를 확인 하는 경우는 nullable 형식의 식 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution))를 해당 연산자의 결과 찾지 못한에서 대신 계산 되는 `HasValue` 속성의 `x`합니다. 먼저 두 가지 형식으로 변환 됩니다 특히 `!x.HasValue`, 마지막으로 두 가지 형식으로 변환 됩니다 및 `x.HasValue`합니다.

### <a name="the-is-operator"></a>여는 연산자

`is` 연산자는 동적으로 개체의 런타임 형식을 지정 된 형식과 호환 되는지 확인 하는 데 사용 됩니다. 작업의 결과 `E is T`, 여기서 `E` 식 및 `T` 형식인 부울을 나타내는 값 여부를 `E` 형식으로 성공적으로 변환 될 수 있습니다 `T` 참조 변환을 boxing 하 여 변환 또는 unboxing 변환 합니다. 모든 형식 매개 변수에 대해 형식 인수 대체 된 후 작업을 다음과 같이 평가 됩니다.

*  경우 `E` 는 컴파일 타임 오류가 발생 하는 익명 함수
*  경우 `E` 는 메서드 그룹 또는 `null` 경우 리터럴 형식의 `E` 참조 형식 또는 nullable 형식 및 값 `E` 가 null 이면 결과 false입니다.
*  수이 고, 그렇지 `D` 의 동적 형식을 나타내는 `E` 다음과 같습니다.
   * 경우 유형의 `E` 참조 형식인 `D` 하 여 인스턴스 참조의 런타임 형식인 `E`합니다.
   * 경우 유형의 `E` nullable 형식인 `D` 는 nullable 형식의 기본 형식입니다.
   * 경우 유형의 `E` nullable이 아닌 값 형식인 `D` 유형의 `E`합니다.
*  작업의 결과에 따라 달라 집니다 `D` 및 `T` 다음과 같습니다.
   * 하는 경우 `T` 참조 형식인 결과가 true 인 경우 `D` 및 `T` 는 동일한 형식인 경우 `D` 는 및 참조 형식에서 암시적 참조 변환이 `D` 에 `T` 가 이거나 `D` 값 형식과 boxing 변환 `D` 에 `T` 존재 합니다.
   * 하는 경우 `T` nullable 형식인 결과가 true 인 경우 `D` 의 기본 형식인 `T`합니다.
   * 하는 경우 `T` nullable이 아닌 값 형식인 결과가 true 인 경우 `D` 및 `T` 같은 형식입니다.
   * 그렇지 않으면 결과 false입니다.

사용자 정의 변환으로 간주 되지 않습니다 참고는 `is` 연산자입니다.

### <a name="the-as-operator"></a>As 연산자

`as` 연산자는 지정 된 참조 형식 또는 nullable 형식과 값을 명시적으로 변환를 사용 합니다. Cast 식과 달리 ([캐스트 식](expressions.md#cast-expressions)), `as` 연산자 절대 예외를 throw 합니다. 대신, 표시 된 변환이 가능 하지 않은 경우 결과 값은 `null`합니다.

폼의 작업에서 `E as T`, `E` 식 이어야 하 고 `T` 참조 형식 또는 nullable 형식을 알려진 형식 매개 변수는 참조 형식 이어야 합니다. 또한 다음 중 하나 이상의 true 이거나 그렇지 않으면 컴파일 타임 오류가 발생 하는:

*  Id ([Id 변환을](conversions.md#identity-conversion)), 암시적 null을 허용 ([암시적 nullable 변환](conversions.md#implicit-nullable-conversions))에 대 한 암시적 참조가 ([암시적 참조 변환](conversions.md#implicit-reference-conversions)), boxing ([ Boxing 변환](conversions.md#boxing-conversions)) 명시적 nullable ([명시적 nullable 변환](conversions.md#explicit-nullable-conversions))를 명시적으로 참조 ([명시적 참조 변환을](conversions.md#explicit-reference-conversions)), unboxing 또는 ([Unboxing 변환](conversions.md#unboxing-conversions))에서 변환이 존재 `E` 에 `T`입니다.
*  유형의 `E` 또는 `T` 은 개방형 형식입니다.
*  `E` 가 `null` 리터럴.

형식이 컴파일 타임 `E` 아닙니다 `dynamic`, 작업 `E as T` 와 동일한 결과 생성 합니다.
```csharp
E is T ? (T)(E) : (T)null
```
단, `E`가 한 번만 계산됩니다. 컴파일러 최적화를 사용할 수 `E as T` 위의 확장 사용 권한에 포함 된 두 개의 동적 형식 검사와 달리 최대 하나의 동적 형식 검사를 수행 합니다.

컴파일 타임의 형식이 `E` 됩니다 `dynamic`, 캐스트 연산자와 달리 합니다 `as` 연산자를 동적으로 바인딩되지 않은 ([동적 바인딩](expressions.md#dynamic-binding)). 따라서 확장이 예제의 경우:
```csharp
E is T ? (T)(object)(E) : (T)null
```

사용자 정의 변환 등의 일부 변환에서 사용할 수 없는 참고는 `as` 연산자 대신 cast 식을 사용 하 여 수행 해야 합니다.

예제
```csharp
class X
{

    public string F(object o) {
        return o as string;        // OK, string is a reference type
    }

    public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }

    public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
```
형식 매개 변수 `T` 의 `G` 클래스 제약 조건이 있기 때문에 참조 형식일 것으로 알려져 있습니다. 그러나 형식 매개 변수 `U` 의 `H` 없습니다 되므로 사용 하는 것은 `as` 연산자 `H` 허용 되지 않습니다.

## <a name="logical-operators"></a>논리 연산자

합니다 `&`, `^`, 및 `|` 연산자는 논리 연산자 라고 합니다.

```antlr
and_expression
    : equality_expression
    | and_expression '&' equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression '^' and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;
```

논리 연산자의 피연산자는 컴파일 시간 형식에 있는지 `dynamic`, 다음 식이 동적으로 바인딩 되었는지 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 시간 식의 형식이 `dynamic`, 아래에 설명 된 해결 방법을 컴파일 시간 형식이 해당 피연산자의 런타임 형식을 사용 하 여 런타임 시 수행 됩니다 및 `dynamic`합니다.

폼의 작업에 대 한 `x op y`, 여기서 `op` 논리 연산자를 오버 로드 확인 중 하나입니다 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 특정 연산자 구현을 선택에 적용 됩니다. 피연산자는 선택한 연산자의 매개 변수 형식으로 변환 됩니다 하 고 결과의 형식은 연산자의 반환 형식입니다.

미리 정의 된 논리 연산자는 다음 섹션에서 설명 됩니다.

### <a name="integer-logical-operators"></a>정수 논리 연산자

미리 정의 된 정수 논리 연산자는 다음과 같습니다.
```csharp
int operator &(int x, int y);
uint operator &(uint x, uint y);
long operator &(long x, long y);
ulong operator &(ulong x, ulong y);

int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);

int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
```

`&` 연산자는 비트를 계산 논리 `AND` 두 피연산자 중 합니다 `|` 연산자는 비트를 계산 논리 `OR` 는 두 피연산자의 및 `^` 연산자 계산 논리 배타적 비트 `OR` 두 피연산자의 합니다. 이러한 작업에서 없습니다 오버플로 있을 수 있습니다.

### <a name="enumeration-logical-operators"></a>열거형 논리 연산자

모든 열거형 형식 `E` 암시적으로 다음 미리 정의 된 논리 연산자를 제공 합니다.

```csharp
E operator &(E x, E y);
E operator |(E x, E y);
E operator ^(E x, E y);
```

평가 결과 `x op y`여기서 `x` 하 고 `y` 열거형 형식의 식이 `E` 기본 형식을 사용 하 여 `U`, 및 `op` 는 논리 연산자 중 하나를 정확 하 게 동일 평가 `(E)((U)x op (U)y)`합니다. 즉, 열거형 형식 논리 연산자는 단순히 두 피연산자의 내부 형식에 논리 연산을 수행 합니다.

### <a name="boolean-logical-operators"></a>부울 논리 연산자

논리 연산자는 미리 정의 된 부울 값:
```csharp
bool operator &(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
```

결과 `x & y` 는 `true` 둘 다 `x` 하 고 `y` 는 `true`합니다. 그렇지 않으면 결과 `false`합니다.

결과인 `x | y` 됩니다 `true` 경우 `x` 또는 `y` 는 `true`합니다. 그렇지 않으면 결과 `false`합니다.

결과 `x ^ y` 는 `true` 경우 `x` 는 `true` 및 `y` 됩니다 `false`, 또는 `x` 는 `false` 및 `y` 는 `true`합니다. 그렇지 않으면 결과 `false`합니다. 형식의 피연산자가 하는 경우 `bool`는 `^` 연산자와 동일한 결과 계산 합니다 `!=` 연산자입니다.

### <a name="nullable-boolean-logical-operators"></a>Null 허용 부울 논리 연산자

Nullable 부울 형식 `bool?` 세 가지 값을 나타낼 수 있습니다 `true`, `false`, 및 `null`, SQL의 부울 식에 사용 되는 세 개의 값 형식을 개념적으로 유사 합니다. 생성 되는 결과 보장 하는 `&` 및 `|` 연산자에 대 한 `bool?` 피연산자는 SQL의 세 개의 값 논리를 사용 하 여 일관성이 다음 미리 정의 된 연산자가 제공 됩니다.

```csharp
bool? operator &(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
```

다음 표에서 값의 모든 조합에 대 한 이러한 연산자에서 생성 되는 결과 `true`, `false`, 및 `null`합니다.

| `x`     | `y`     | `x & y` | <code>x &#124; y</code> |
|:-------:|:-------:|:-------:|:-------:|
| `true`  | `true`  | `true`  | `true`  | 
| `true`  | `false` | `false` | `true`  | 
| `true`  | `null`  | `null`  | `true`  | 
| `false` | `true`  | `false` | `true`  | 
| `false` | `false` | `false` | `false` | 
| `false` | `null`  | `false` | `null`  | 
| `null`  | `true`  | `null`  | `true`  | 
| `null`  | `false` | `false` | `null`  | 
| `null`  | `null`  | `null`  | `null`  | 

## <a name="conditional-logical-operators"></a>조건부 논리 연산자

합니다 `&&` 및 `||` 연산자에는 조건부 논리 연산자 라고 합니다. "단락" 논리 연산자 에서도 호출 됩니다.

```antlr
conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression '&&' inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression
    ;
```

합니다 `&&` 하 고 `||` 연산자는 조건부 버전의는 `&` 및 `|` 연산자:

*  작업이 `x && y` 작업에 해당 `x & y`점을 제외 하 고 `y` 경우에 평가 됩니다 `x` 아닙니다 `false`합니다.
*  작업이 `x || y` 작업에 해당 `x | y`점을 제외 하 고 `y` 경우에 평가 됩니다 `x` 아닙니다 `true`합니다.

조건부 논리 연산자의 피연산자는 컴파일 시간 형식에 있는지 `dynamic`, 다음 식이 동적으로 바인딩 되었는지 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 시간 식의 형식이 `dynamic`, 아래에 설명 된 해결 방법을 컴파일 시간 형식이 해당 피연산자의 런타임 형식을 사용 하 여 런타임 시 수행 됩니다 및 `dynamic`합니다.

폼의 작업 `x && y` 나 `x || y` 오버 로드 확인을 적용 하 여 처리 됩니다 ([이항 연산자 오버 로드 확인에](expressions.md#binary-operator-overload-resolution)) 작업 작성 된 것 처럼 `x & y` 또는 `x | y`합니다. 그런 다음

*  오버 로드 확인 최상의 single 연산자를 찾지 못하면 또는 오버 로드 확인 미리 정의 된 정수 논리 연산자 중 하나를 선택 하는 경우 바인딩 시간 오류를 발생 합니다.
*  그렇지 않으면 선택한 연산자가 미리 정의 된 부울 논리 연산자 중 하나 ([부울 논리 연산자](expressions.md#boolean-logical-operators)) 또는 null 허용 부울 논리 연산자 ([Nullable 부울 논리 연산자](expressions.md#nullable-boolean-logical-operators)), 에 설명 된 대로 작업이 처리 됩니다 [조건부 논리 연산자를 부울](expressions.md#boolean-conditional-logical-operators)합니다.
*  그렇지 않으면 선택한 연산자가 사용자 정의 연산자를 하 고에 설명 된 대로 작업이 처리 됩니다 [사용자 정의 조건부 논리 연산자](expressions.md#user-defined-conditional-logical-operators)합니다.

직접 조건부 논리 연산자를 오버 로드 하는 것이 불가능 합니다. 그러나 일반 논리 연산자를 기준으로 조건부 논리 연산자를 평가 하기 때문에 일반 논리 연산자의 오버 로드를 특정 제한 사항으로 간주 됩니다 조건부 논리 연산자의 오버 로드. 이에서 더 자세히 설명 [사용자 정의 조건부 논리 연산자](expressions.md#user-defined-conditional-logical-operators)합니다.

### <a name="boolean-conditional-logical-operators"></a>부울 조건부 논리 연산자

때의 피연산자 `&&` 또는 `||` 형식의 `bool`, 해당를 정의 하지 않은 형식의 피연산자가 하는 경우 또는 `operator &` 또는 `operator |`로 암시적으로 정의지 않습니다 하지만 `bool`, 작업이 다음과 같이 처리 합니다.

*  작업이 `x && y` 로 평가 됩니다 `x ? y : false`합니다. 다시 말해 `x` 먼저 평가 되 고 형식으로 변환할 `bool`합니다. 그런 다음 경우 `x` 는 `true`, `y` 평가 되 고 형식으로 변환할 `bool`, 작업의 결과이 고 합니다. 작업의 결과 그러지 `false`합니다.
*  작업이 `x || y` 로 평가 됩니다 `x ? true : y`합니다. 다시 말해 `x` 먼저 평가 되 고 형식으로 변환할 `bool`합니다. 그런 다음 경우 `x` 됩니다 `true`, 작업의 결과 `true`합니다. 이 고, 그렇지 `y` 평가 되 고 형식으로 변환할 `bool`, 작업의 결과이 고 합니다.

### <a name="user-defined-conditional-logical-operators"></a>사용자 정의 조건부 논리 연산자

때의 피연산자 `&&` 또는 `||` 되는 해당 선언 된 형식의 사용자 정의 `operator &` 또는 `operator |`, 다음 두 가지 true 여야 여기서 `T` 는 선택한 연산자 선언 되는 형식:

*  반환 형식 및 선택한 연산자의 각 매개 변수의 형식이 있어야 `T`합니다. 즉, 연산자 논리 계산 해야 합니다 `AND` 또는 논리 `OR` 형식의 두 피연산자의 `T`, 형식의 결과 반환 해야 하 고 `T`.
*  `T` 선언이 있어야 `operator true` 고 `operator false`입니다.

이러한 요구 사항을 하나라도 충족 되지 않으면 바인딩 시간 오류가 발생 합니다. 이 고, 그렇지 합니다 `&&` 하거나 `||` 작업은 사용자 정의 결합 하 여 평가 됩니다 `operator true` 또는 `operator false` 선택한 사용자 정의 연산자를 사용 하 여:

*  작업 `x && y` 로 평가 됩니다 `T.false(x) ? x : T.&(x, y)`여기서 `T.false(x)` 호출 되는 `operator false` 에 선언 된 `T`, 및 `T.&(x, y)` 는 선택한 호출 `operator &`. 즉, `x` 먼저 평가 됩니다 및 `operator false` 여부를 확인 하려면 결과에서 호출 되는 `x` false 확실 하 게 됩니다. 그런 다음 if `x` 확실 하 게 false 연산의 결과 대해 이전에 계산 된 값입니다 `x`합니다. 이 고, 그렇지 `y` 계산과 선택한 `operator &` 에 대해 이전에 계산 된 값에 호출 됩니다 `x` 의 값을 계산 `y` 작업의 결과 생성 하 합니다.
*  작업 `x || y` 로 평가 됩니다 `T.true(x) ? x : T.|(x, y)`여기서 `T.true(x)` 호출 되는 `operator true` 에 선언 된 `T`, 및 `T.|(x,y)` 는 선택한 호출 `operator|`. 즉, `x` 먼저 평가 됩니다 및 `operator true` 여부를 확인 하려면 결과에서 호출 되는 `x` 분명히 그렇습니다. 그런 다음 if `x` 확실 하 게 true 이면 작업의 결과 이전에 계산한 값 `x`. 이 고, 그렇지 `y` 계산과 선택한 `operator |` 에 대해 이전에 계산 된 값에 호출 됩니다 `x` 의 값을 계산 `y` 작업의 결과 생성 하 합니다.

지정 된 식이 이러한 작업 중 하나로 `x` 이며 한 번 계산만에서 지정 된 식이 `y` 이 없거나 계산 또는 정확히 한 번 계산 합니다.

구현 하는 형식의 예 `operator true` 및 `operator false`를 참조 하십시오 [데이터베이스 부울 유형](structs.md#database-boolean-type)합니다.

## <a name="the-null-coalescing-operator"></a>Null 병합 연산자

`??` 연산자는 null 병합 연산자 라고 합니다.

```antlr
null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression '??' null_coalescing_expression
    ;
```

null 병합 식 형식의 `a ?? b` 필요 `a` nullable 형식 또는 참조 형식 이어야 합니다. 경우 `a` 가 null이 아닌 결과인 `a ?? b` 됩니다 `a`이 고, 그렇지 않으면 결과 `b`합니다. 평가 하는 작업 `b` 경우에만 `a` null입니다.

Null 병합 연산자는 오른쪽 결합성 작업은 오른쪽에서 왼쪽으로 그룹화 되어 있음을 의미 합니다. 예를 들어, 폼의 식을 `a ?? b ?? c` 로 평가 됩니다 `a ?? (b ?? c)`합니다. 일반적으로 조건에 식 형식의 `E1 ?? E2 ?? ... ?? En` null이 아닌 경우 또는 모든 피연산자가 null 인 경우 null 첫 번째 피연산자를 반환 합니다.

식의 형식은 `a ?? b` 는 암시적 변환이 피연산자에 사용할 수에 따라 달라 집니다. 유형의 기본 설정 순서에 `a ?? b` 는 `A0`, `A`, 또는 `B`여기서 `A` 의 형식인 `a` (제공한 `a` 형식이), `B` 유형의 `b` ( 제공한 `b` 형식이), 및 `A0` 의 기본 형식인 `A` 경우 `A` 이 nullable 형식이 또는 `A` 그렇지 않은 경우. 특히 `a ?? b` 다음과 같이 처리 됩니다.

*  경우 `A` 있는지 그리고 nullable 형식 또는 참조 형식에서 컴파일 타임 오류가 발생 합니다.
*  하는 경우 `b` 는 동적 식이 결과 형식은 `dynamic`합니다. 실행 시 `a` 먼저 평가 됩니다. 하는 경우 `a` null이 아니면 `a` 를 동적으로 변환 하는이 결과가 됩니다. 이 고, 그렇지 `b` 평가 결과가이 됩니다.
*  그렇지 않은 경우, `A` 존재이 nullable 형식이 고에서 암시적 변환이 존재 `b` 하 `A0`, 결과 형식은 `A0`합니다. 실행 시 `a` 먼저 평가 됩니다. 하는 경우 `a` null이 아니면 `a` 입력 래핑이 해제 되어 `A0`,이 결과가 됩니다. 이 고, 그렇지 `b` 평가 되 고 형식으로 변환할 `A0`에이 결과가 됩니다.
*  그렇지 않은 경우, `A` 존재에서 암시적 변환이 존재 하 고 `b` 하 `A`, 결과 형식은 `A`합니다. 실행 시 `a` 먼저 평가 됩니다. 하는 경우 `a` null이 아니면 `a` 결과가 됩니다. 이 고, 그렇지 `b` 평가 되 고 형식으로 변환할 `A`에이 결과가 됩니다.
*  그렇지 않은 경우, `b` 형식이 `B` 에서 암시적 변환이 존재 하 고 `a` 하 `B`, 결과 형식은 `B`합니다. 실행 시 `a` 먼저 평가 됩니다. 하는 경우 `a` null이 아니면 `a` 입력 래핑이 해제 되어 `A0` (경우 `A` 존재 이며 null을 허용) 형식으로 변환 하 고 `B`,이 결과가 됩니다. 그렇지 않으면 `b` 평가 되 고 결과가 됩니다.
*  그렇지 않으면 `a` 고 `b` 는 호환 되지 않으며 및 컴파일 타임 오류가 발생 합니다.

## <a name="conditional-operator"></a>조건 연산자

`?:` 연산자 조건부 연산자 라고 합니다. 또한 때때로 삼진 연산자를 라고 합니다.

```antlr
conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression '?' expression ':' expression
    ;
```

형식의 조건식 `b ? x : y` 먼저 조건을 평가 `b`합니다. 그런 다음 if `b` 은 `true`, `x` 평가 되 고 작업의 결과가 됩니다. 그렇지 않으면 `y` 평가 되 고 작업의 결과가 됩니다. 조건부 식을 모두 것도 계산 하지 않습니다 `x` 고 `y`입니다.

조건 연산자는 오른쪽 결합성 작업은 오른쪽에서 왼쪽으로 그룹화 되어 있음을 의미 합니다. 예를 들어, 폼의 식을 `a ? b : c ? d : e` 로 평가 됩니다 `a ? b : (c ? d : e)`합니다.

첫 번째 피연산자는 `?:` 연산자를 암시적으로 변환할 수 있는 식 이어야 합니다. `bool`, 또는 구현 하는 형식의 식을 `operator true`합니다. 이러한 요구 사항을 모두 충족 되는 경우 컴파일 타임 오류가 발생 합니다.

두 번째와 세 번째 피연산자 `x` 하 고 `y`의 `?:` 연산자 조건식의 형식을 제어 합니다.

*  하는 경우 `x` 형식이 `X` 하 고 `y` 형식이 `Y` 다음
   * 암시적으로 변환 하는 경우 ([암시적 변환을](conversions.md#implicit-conversions))에서 존재 `X` 를 `Y`에서 아니라 `Y` 를 `X`, 다음 `Y` 조건식의 형식입니다.
   * 암시적으로 변환 하는 경우 ([암시적 변환을](conversions.md#implicit-conversions))에서 존재 `Y` 를 `X`에서 아니라 `X` 를 `Y`, 다음 `X` 조건식의 형식입니다.
   * 이 고, 그렇지 확인할 수 없는 식 형식이 없는 및 컴파일 타임 오류가 발생 합니다.
*  경우에 중 하나 `x` 및 `y` 있고 형식 둘 다 `x` 및 `y`의 형식으로 암시적으로 변환할 수 있으면이 조건식의 형식을 합니다.
*  이 고, 그렇지 확인할 수 없는 식 형식이 없는 및 컴파일 타임 오류가 발생 합니다.

폼의 조건 식의 런타임 처리 `b ? x : y` 다음 단계로 구성 됩니다.

*  먼저 `b` 계산 및 `bool` 의 값 `b` 결정 됩니다.
   * 경우의 형식에서 암시적 변환을 `b` 하 `bool` 가 생성이 암시적 변환은 수행 됩니다는 `bool` 값입니다.
   * 이 고, 그렇지는 `operator true` 의 형식에 의해 정의 된 `b` 생성 하기 위해 호출 되는 `bool` 값입니다.
*  경우는 `bool` 위의 단계에서 생성 하는 값이 `true`, 다음 `x` 평가 되 고 조건부 식의 형식으로 변환할 조건 식의 결과이 고 합니다.
*  이 고, 그렇지 `y` 평가 되 고 조건부 식의 형식으로 변환 및 조건 식의 결과 이것이 합니다.

## <a name="anonymous-function-expressions"></a>익명 함수 식

***익명 함수*** "인라인" 메서드 정의 나타내는 식입니다. 익명 함수 형식 또는 값 자체에 없지만 호환 되는 대리자 또는 식 트리 형식으로 변환 될 수 있습니다. 변환의 대상 형식에는 익명 함수 변환의 평가 따라 달라 집니다: 대리자 형식이 인 경우 변환 익명 함수를 정의 하는 메서드를 참조 하는 대리자 값으로 계산 되는 것입니다. 식 트리 형식을 인 경우 변환 개체 구조와 메서드의 구조를 나타내는 식 트리를 평가 합니다.

기록을 위해 가지 익명 함수에 두 가지 구문 버전 namely *lambda_expression*s 및 *anonymous_method_expression*s입니다. 거의 모든 용도로 *lambda_expression*가 더 간결 하 고 보다 표현 *anonymous_method_expression*언어에 대 한 이전 버전과 호환성 유지 되는 s입니다.

```antlr
lambda_expression
    : anonymous_function_signature '=>' anonymous_function_body
    ;

anonymous_method_expression
    : 'delegate' explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : '(' explicit_anonymous_function_parameter_list? ')'
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter (',' explicit_anonymous_function_parameter)*
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? type identifier
    ;

anonymous_function_parameter_modifier
    : 'ref'
    | 'out'
    ;

implicit_anonymous_function_signature
    : '(' implicit_anonymous_function_parameter_list? ')'
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter (',' implicit_anonymous_function_parameter)*
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
```

합니다 `=>` 연산자가 할당 우선 순위가 (`=`)와 같으며 오른쪽 결합성 합니다.

사용 하 여 익명 함수는 `async` 한정자는 비동기 함수 및에 설명 된 규칙을 따릅니다 [반복기](classes.md#iterators)합니다.

형식의 익명 함수의 매개 변수를 *lambda_expression* 명시적 또는 암시적으로 입력할 수 있습니다. 명시적으로 형식화 된 매개 변수 목록의 각 매개 변수의 형식은 명시적으로 지정 됩니다. 익명 함수 발생 하는 컨텍스트에서 유추는 매개 변수의 형식을 암시적으로 형식화 된 매개 변수 목록의-특히 익명 함수 변환 되 면 호환 되는 대리자 형식 또는 형식에서 제공 하는 식 트리 형식 매개 변수 형식 ([익명 함수 변환](conversions.md#anonymous-function-conversions)).

단일, 암시적으로 형식화 된 매개 변수를 사용 하 여 익명 함수에서 매개 변수 목록 괄호를 생략할 수 있습니다. 즉, 폼의 익명 함수
```csharp
( param ) => expr
```
로 축약할 수 있습니다.
```csharp
param => expr
```

매개 변수 목록이 형식의 익명 함수는 *anonymous_method_expression* 는 선택 사항. 주어진 경우 매개 변수를 명시적으로 형식화 되어야 합니다. 익명 함수는 매개 변수를 사용 하 여 대리자 변환할 그렇지 않은 경우 포함 되지 않은 목록 `out` 매개 변수입니다.

A *블록* 익명 함수의 본문에 연결할 수 ([끝점 및 연결 가능성](statements.md#end-points-and-reachability)) 익명 함수는 연결할 수 없는 문 내에서 발생 하지 않는 한 합니다.

익명 함수의 몇 가지 예가 아래 수행합니다.

```csharp
x => x + 1                              // Implicitly typed, expression body
x => { return x + 1; }                  // Implicitly typed, statement body
(int x) => x + 1                        // Explicitly typed, expression body
(int x) => { return x + 1; }            // Explicitly typed, statement body
(x, y) => x * y                         // Multiple parameters
() => Console.WriteLine()               // No parameters
async (t1,t2) => await t1 + await t2    // Async
delegate (int x) { return x + 1; }      // Anonymous method expression
delegate { return 1 + 1; }              // Parameter list omitted
```

동작은 *lambda_expression*s 및 *anonymous_method_expression*가 다음 사항을 제외 하 고 동일 합니다.

*  *anonymous_method_expression*s 허용 매개 변수 목록을 완전히 생략 대리자 매개 변수 값의 모든 목록 형식으로 변환 가능성을 생성 합니다.
*  *lambda_expression*s 허용 매개 변수 형식을 생략 되어 있지만 유추 *anonymous_method_expression*s 필요한 매개 변수 형식을 명시적으로 지정 되어야 합니다.
*  본문을 *lambda_expression* 반면 식이나 문 블록을 수 있습니다의 본문을 *anonymous_method_expression* 문 블록 이어야 합니다.
*  만 *lambda_expression*호환 식 트리 형식으로의 변환 있습니다 ([식 트리 형식](types.md#expression-tree-types)).

### <a name="anonymous-function-signatures"></a>익명 함수 시그니처

선택적 *anonymous_function_signature* 익명 함수는 이름 및 필요에 따라 익명 함수에 대 한 정식 매개 변수의 형식을 정의 합니다. 익명 함수의 매개 변수 범위는 *anonymous_function_body*합니다. ([범위](basic-concepts.md#scopes)) 매개 변수 목록 (제공 된 경우)와 함께 익명 메서드 본문 구성 선언 공간 ([선언](basic-concepts.md#declarations)). 따라서는 지역 변수, 지역 상수 또는 해당 범위에 포함 하는 매개 변수 이름과 일치 하는 익명 함수 매개 변수의 이름에 대 한 컴파일 시간 오류를 *anonymous_method_expression* 또는 *lambda_ 식*합니다.

익명 함수에는 *explicit_anonymous_function_signature*, 식 트리 형식과 호환 되는 대리자 형식 집합이 동일한 순서로 동일한 매개 변수 형식 및 한정자에 있는 원하는 언어로 제한 됩니다. 메서드 그룹 변환 달리 ([메서드 그룹 변환](conversions.md#method-group-conversions)), 익명 함수 매개 변수 형식의 반 공변성은 지원 되지 않습니다. 익명 함수에 없는 경우는 *anonymous_function_signature*, 식 트리 형식과 호환 되는 대리자 형식 집합이 없는 것으로 제한 됩니다 `out` 매개 변수입니다.

한 *anonymous_function_signature* 특성 또는 매개 변수 배열에 포함할 수 없습니다. 그럼에도 불구 하 고는 *anonymous_function_signature* 매개 변수 목록을 가진 매개 변수 배열에 포함 된 대리자 형식과 호환 수 있습니다.

호환 되는, 컴파일 시간에 실패할 수 있습니다 하는 경우에는 식 트리 형식으로 변환 하는 또한 ([식 트리 형식](types.md#expression-tree-types)).

### <a name="anonymous-function-bodies"></a>익명 함수 본문

본문 (*식* 하거나 *블록*)는 다음 규칙에 따라 익명 함수입니다.

*  익명 함수 시그니처를 포함 하는 경우에 서명에 지정 된 매개 변수가 본문에서 사용할 수 있습니다. 대리자 형식 또는 매개 변수 식 형식을 변환할 수 익명 함수 서명이 없는 경우 ([익명 함수 변환](conversions.md#anonymous-function-conversions)), 하지만 매개 변수를 본문에 액세스할 수 없습니다.
*  제외 하 고 `ref` 또는 `out` 바로 바깥쪽의 시그니처 (있는 경우)에 지정 된 매개 변수는 본문의 액세스에 대 한 컴파일 시간 오류 것 익명 함수는 `ref` 또는 `out` 매개 변수입니다.
*  때 유형의 `this` 구조체 형식인 본문에 액세스 하려면 컴파일 시간 오류 `this`합니다. 이 true 인지 여부입니다 액세스 명시적 (에서처럼 `this.x`) 또는 암시적 (에서처럼 `x` 여기서 `x` 구조체의 인스턴스 멤버입니다). 이 규칙은 단순히 이러한 액세스를 금지 하 구조체의 멤버에서 멤버 조회 결과 여부에 영향을 주지 않습니다.
*  본문이 외부 변수에 액세스할 수 있습니다 ([외부 변수](expressions.md#outer-variables)) 익명 함수입니다. 외부 변수의 액세스는 시점에 활성 상태인 변수의 인스턴스를 참조 합니다 *lambda_expression* 또는 *anonymous_method_expression* 계산 됩니다 ([평가 익명 함수 식](expressions.md#evaluation-of-anonymous-function-expressions)).
*  포함 하도록 본문에 대 한 컴파일 시간 오류가 발생을 `goto` 문을 `break` 문 또는 `continue` 문이 포함 된 익명 함수의 본문 내에서 또는 본문 외부를 대상으로 합니다.
*  `return` 가장 가까운 바깥쪽 호출에서 제어를 반환 하는 본문에는 문을 바깥쪽 함수 멤버를 제외할 익명 함수입니다. 에 지정 된 식을 `return` 문은 암시적으로 대리자 형식 또는 식 트리 형식의 반환 형식 이어야 합니다. 가장 가까운 바깥쪽 *lambda_expression* 또는 *anonymous_ method_expression* 변환 됩니다 ([익명 함수 변환](conversions.md#anonymous-function-conversions)).

평가 및 호출을 통해 익명 함수 보다 다른 블록을 실행 하는 모든 방법은 여부를 명시적으로 지정 되지 않습니다 합니다 *lambda_expression* 또는 *anonymous_method_expression*. 특히, 컴파일러가 하나를 취합 하 여 익명 함수를 구현 하도록 선택할 수 또는 이상의 명명 된 메서드 또는 형식입니다. 이러한 합성 된 요소의 이름은 컴파일러 사용 하도록 예약 된 양식의 여야 합니다.

### <a name="overload-resolution-and-anonymous-functions"></a>오버 로드 확인 및 익명 함수

익명 함수는 인수 목록의 형식 유추에 참여 하 고 오버 로드를 확인 합니다. 참조 하십시오 [형식 유추](expressions.md#type-inference) 하 고 [오버 로드 확인](expressions.md#overload-resolution) 정확한 규칙에 대 한 합니다.

다음 예제에서는 익명 함수 오버 로드 확인에서 효과를 보여 줍니다.

```csharp
class ItemList<T>: List<T>
{
    public int Sum(Func<T,int> selector) {
        int sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }

    public double Sum(Func<T,double> selector) {
        double sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }
}
```

합니다 `ItemList<T>` 클래스에는 두 개의 `Sum` 메서드. 각각을 `selector` 목록 항목에서 합계를 통해 값을 추출 하는 인수입니다. 추출 된 값을 `int` 또는 `double` 결과 성이 합계와 마찬가지로 하나는 `int` 또는 `double`합니다.

`Sum` 순서로 세부 선의 목록의 합계를 계산 하려면 메서드 예를 들어 사용할 수 있습니다.

```csharp
class Detail
{
    public int UnitCount;
    public double UnitPrice;
    ...
}

void ComputeSums() {
    ItemList<Detail> orderDetails = GetOrderDetails(...);
    int totalUnits = orderDetails.Sum(d => d.UnitCount);
    double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount);
    ...
}
```

첫 번째 호출에서 `orderDetails.Sum`모두 `Sum` 방법이 적합 하므로 익명 함수 `d => d. UnitCount` 둘 다와 호환 되 `Func<Detail,int>` 및 `Func<Detail,double>`합니다. 그러나 오버 로드 확인의 첫 번째 선택 `Sum` 메서드 때문에 변환 `Func<Detail,int>` 변환 보다 나은 `Func<Detail,double>`합니다.

두 번째 호출에서 `orderDetails.Sum`, 두 번째만 `Sum` 메서드를 적용할 수 있으므로 익명 함수 `d => d.UnitPrice * d.UnitCount` 형식의 값을 생성 `double`합니다. 따라서 오버 로드 확인에는 두 번째 선택 `Sum` 메서드는 호출에 대 한 합니다.

### <a name="anonymous-functions-and-dynamic-binding"></a>익명 함수 및 동적 바인딩

익명 함수는 받는 사람, 인수 또는 동적으로 바인딩된 연산의 피연산자 일 수 없습니다.

### <a name="outer-variables"></a>외부 변수

모든 로컬 변수, 값 매개 변수 또는 매개 변수 배열 범위가 포함 된 *lambda_expression* 또는 *anonymous_method_expression* 라고는 ***외부 변수*** 익명 함수입니다. 클래스의 인스턴스 멤버 함수에에서는 `this` 값 매개 변수 값으로 간주 됩니다 및 함수 멤버 내에 포함 된 익명 함수는 외부 변수입니다.

#### <a name="captured-outer-variables"></a>캡처된 외부 변수

외부 변수를 익명 함수에서 참조 하는 외부 변수 라고 되었습니다 ***캡처된*** 익명 함수에 의해 합니다. 일반적으로 로컬 변수의 수명은와 연관 된 문이나 블록의 실행 제한 됩니다 ([지역 변수](variables.md#local-variables)). 그러나 대리자까지 캡처된 외부 변수의 수명은 이상 확장 또는 익명 함수에서 생성 하는 식 트리 가비지 수집 대상이 됩니다.

예제
```csharp
using System;

delegate int D();

class Test
{
    static D F() {
        int x = 0;
        D result = () => ++x;
        return result;
    }

    static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
```
지역 변수 `x` 의 수명과 익명 함수에 의해 캡처된 `x` 대리자에서 반환 될 때까지 적어도 확장은 `F` (맨 끝까지 발생 하지 않은 가비지 수집 대상이 될 프로그램)입니다. 익명 함수를 호출할 때마다 동일한 인스턴스에서 작동 하므로 `x`, 예제의 출력은:
```
1
2
3
```

지역 변수 또는 값 매개 변수는 익명 함수에 의해 캡처된 지역 변수 또는 매개 변수를 더 이상 것으로 간주 됩니다 고정된 변수 이어야 합니다 ([고정 및 고정 되지 않은 변수](unsafe-code.md#fixed-and-moveable-variables)), 대신 것으로 간주 됩니다는 moveable 하지만 변수입니다. 따라서 모든 `unsafe` 캡처된 외부 변수의 주소를 사용 하는 코드를 먼저 사용 해야는 `fixed` 문을 변수를 수정 합니다.

Uncaptured 변수는 달리, 캡처된 지역 변수는 다중 스레드 방식의 실행을 동시에 노출 될 수 있습니다.

#### <a name="instantiation-of-local-variables"></a>지역 변수의 인스턴스화

지역 변수 것으로 간주 됩니다 ***인스턴스화할*** 실행에서 변수의 범위를 입력 하는 경우. 예를 들어 다음 메서드를 호출 하는 경우, 지역 변수 `x` 인스턴스화되고 세 번 초기화-루프의 각 반복에 한 번씩입니다.

```csharp
static void F() {
    for (int i = 0; i < 3; i++) {
        int x = i * 2 + 1;
        ...
    }
}
```

그러나 선언 이동 `x` 루프 결과의 단일 인스턴스화를 외부 `x`:
```csharp
static void F() {
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
```

지역 변수 인스턴스화될 정확한 빈도 확인할 방법이 없기 캡처되지 않습니다 때-있기 때문에 인스턴스화의 수명을 결합 되지 않았는지, 동일한 저장소 위치를 사용 하기만 하면 각 인스턴스화에 대 한 합니다. 그러나 익명 함수 로컬 변수를 캡처한 인스턴스화 미치는 드러납니다.

이 예제에서
```csharp
using System;

delegate void D();

class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i < 3; i++) {
            int x = i * 2 + 1;
            result[i] = () => { Console.WriteLine(x); };
        }
        return result;
    }

    static void Main() {
        foreach (D d in F()) d();
    }
}
```
다음 출력을 생성합니다.
```
1
3
5
```

하지만 경우 선언의 `x` 루프 밖으로 이동 됩니다.
```csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        result[i] = () => { Console.WriteLine(x); };
    }
    return result;
}
```
출력이 됩니다.
```
5
5
5
```

For 루프 반복 변수를 선언 하는 경우 해당 변수 자체는 루프 외부에서 선언으로 간주 됩니다. 따라서 예제를 캡처하는 반복 변수 자체가 변경 된 경우:

```csharp
static D[] F() {
    D[] result = new D[3];
    for (int i = 0; i < 3; i++) {
        result[i] = () => { Console.WriteLine(i); };
    }
    return result;
}
```
출력을 생성 하는 반복 변수의 인스턴스가 하나만 캡처됩니다.
```
3
3
3
```

일부 캡처된 변수를 공유 하면서 다른 별도 인스턴스가 있는 익명 함수 대리자에 대 한 것 같습니다. 예를 들어 경우 `F` 로 변경 됩니다
```csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i < 3; i++) {
        int y = 0;
        result[i] = () => { Console.WriteLine("{0} {1}", ++x, ++y); };
    }
    return result;
}
```
대리자 3 개 캡처의 동일한 인스턴스에 `x` 의 인스턴스를 구분 하지만 `y`, 출력 및:
```
1 1
2 1
3 1
```

별도 익명 함수는 동일한 인스턴스의 외부 변수를 캡처할 수 있습니다. 예제:
```csharp
using System;

delegate void Setter(int value);

delegate int Getter();

class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) => { x = value; };
        Getter g = () => { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
```
두 개의 익명 함수 캡처 지역 변수의 같은 인스턴스 `x`를 수 있으므로 "통신" 해당 변수를 통해. 예제의 출력이 됩니다.
```
5
10
```

### <a name="evaluation-of-anonymous-function-expressions"></a>익명 함수 식의 평가

익명 함수 `F` 항상 대리자 형식으로 변환 해야 합니다 `D` 또는 식 트리 형식을 `E`에서 직접 또는 대리자 생성 식의 실행을 통해 `new D(F)`합니다. 이 변환 결과 확인 합니다 익명 함수에 설명 된 대로 [익명 함수 변환](conversions.md#anonymous-function-conversions)합니다.

## <a name="query-expressions"></a>쿼리 식

***쿼리 식*** SQL 및 XQuery와 같은 관계형 쿼리와 계층형 쿼리 언어와 유사한는 쿼리용 언어 통합 구문을 제공 합니다.

```antlr
query_expression
    : from_clause query_body
    ;

from_clause
    : 'from' type? identifier 'in' expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : 'let' identifier '=' expression
    ;

where_clause
    : 'where' boolean_expression
    ;

join_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression
    ;

join_into_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression 'into' identifier
    ;

orderby_clause
    : 'orderby' orderings
    ;

orderings
    : ordering (',' ordering)*
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : 'ascending'
    | 'descending'
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : 'select' expression
    ;

group_clause
    : 'group' expression 'by' expression
    ;

query_continuation
    : 'into' identifier query_body
    ;
```

쿼리 식 시작을 `from` 절을 사용 하 여 종료를 `select` 또는 `group` 절. 초기 `from` 절 0 개 이상의가 올 수 있습니다 `from`를 `let`를 `where`합니다 `join` 또는 `orderby` 절. 각 `from` 절이 생성기를 소개를 ***범위 변수*** 의 요소를 통해 범위는 한 ***시퀀스***합니다. 각 `let` 절 이전 범위 변수를 사용 하 여 계산 된 값을 나타내는 범위 변수를 소개 합니다. 각 `where` 절은 결과에서 항목을 제외 하는 필터입니다. 각 `join` 절 일치 하는 쌍을 생성 하는 다른 시퀀스의 키를 사용 하 여 소스 시퀀스의 지정 된 키를 비교 합니다. 각 `orderby` 절에 지정 된 조건에 따라 항목 다시 정렬 합니다. 최종 `select` 또는 `group` 절의 범위 변수를 기준으로 결과의 셰이프를 지정 합니다. 마지막으로 `into` 쿼리를 후속 쿼리에 생성기로 한 쿼리의 결과 처리 하 여 "splice" 할 절을 사용할 수 있습니다.

### <a name="ambiguities-in-query-expressions"></a>쿼리 식에 모호성이

쿼리 식은 다양 한 "상황에 맞는 키워드", 즉, 특정 컨텍스트에서 특별 한 의미 있는 식별자를 포함 합니다. 특히 이러한 `from`, `where`, `join`, `on`, `equals`를 `into`, `let`를 `orderby`, `ascending`를 `descending`, `select`, `group` 및 `by`. 키워드 또는 단순한 이름으로 이러한 식별자의 혼합된 사용 하 여 발생 하는 쿼리 식의 모호성을 피하기 위해 이러한 식별자는 쿼리 식 내에서 아무 곳 이나 발생 하는 경우 키워드를 간주 됩니다.

이 작업을 위해 쿼리 식은로 시작 하는 모든 식 "`from identifier`"를 제외한 모든 토큰 뒤 에"`;`","`=`"또는"`,`"입니다.

쿼리 식 내에서 식별자로 이러한 단어를 사용 하려면 해당 접두사로 붙일 수 있습니다 "`@`" ([식별자](lexical-structure.md#identifiers)).

### <a name="query-expression-translation"></a>쿼리 식 변환

C# 언어는 쿼리 식의 실행 의미 체계를 지정 하지 않습니다. 쿼리 식을 준수 하는 메서드 호출으로 변환 됩니다 아니라 합니다 *쿼리 식 패턴* ([쿼리 식 패턴](expressions.md#the-query-expression-pattern)). 쿼리 식 라는 메서드 호출으로 변환 됩니다 특히 `Where`, `Select`, `SelectMany`, `Join`, `GroupJoin`를 `OrderBy`, `OrderByDescending`를 `ThenBy`, `ThenByDescending`, `GroupBy`, 및 `Cast`합니다. 이러한 메서드 해야 하는 특정 서명 및 결과 형식을에 설명 된 대로 [쿼리 식 패턴](expressions.md#the-query-expression-pattern)합니다. 이러한 메서드는 쿼리 하는 개체의 인스턴스 메서드 또는 외부 개체에 있는 확장 메서드 일 수 있습니다 하 고 구현 하는 쿼리의 실제 실행 합니다.

쿼리 식에서 변환 메서드 호출에는 모든 형식 바인딩을 앞에 오는 구문 매핑이 또는 오버 로드 확인을 수행한 합니다. 변환 구문이 올바르지 않습니다 하지만 의미적으로 C# 코드를 생성 하는 보장 되지 않습니다. 다음 쿼리 식 변환 결과 메서드 호출을 일반 메서드 호출으로 처리 되 고 아니면 메서드는 제네릭 메서드가 없는 경우, 인수 형식이 잘못 된 경우에 예를 들어 오류를 발견할 수 있습니다이 고 형식 유추가 실패 했습니다.

쿼리 식 없습니다 추가로 절감할 수 있습니다 때까지 다음 번역을 반복적으로 적용 하 여 처리 됩니다. 번역은 응용 프로그램의 순서로 나열 됩니다: 각 섹션 가정 하 고 이전 섹션에서 번역을 철저히 수행한 고갈 되 면 섹션은 하지 나중 플러그인 같은 쿼리 식 처리에서 합니다.

쿼리 식의 범위 변수를 할당할 수 없습니다. 그러나 C#으로 구현 하므로이 경우에 따라 못할 여기에 제시 된 구문 변환 스키마를 사용 하 여이 제한으로 항상 그렇지는 않습니다 적용 허용 됩니다.

특정 번역 가리키는 투명 식별자를 사용 하 여 범위 변수를 삽입할 `*`합니다. 투명 식별자의 특별 한 속성 설명에 대 한 자세한 [투명 식별자](expressions.md#transparent-identifiers)합니다.

#### <a name="select-and-groupby-clauses-with-continuations"></a>Continuation 사용 하 여 선택 하 고 groupby 절

연속 작업을 사용 하 여 쿼리 식
```csharp
from ... into x ...
```
로 변환 됩니다.
```csharp
from x in ( from ... ) ...
```

다음 섹션에서 번역 쿼리 없는 가정 `into` 연속 작업입니다.

이 예제에서
```csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
```
로 변환 됩니다.
```csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
```
최종 번역이
```csharp
customers.
GroupBy(c => c.Country).
Select(g => new { Country = g.Key, CustCount = g.Count() })
```

#### <a name="explicit-range-variable-types"></a>명시적 범위 변수 형식

`from` 범위 변수 형식을 명시적으로 지정 하는 절
```csharp
from T x in e
```
로 변환 됩니다.
```csharp
from x in ( e ) . Cast < T > ( )
```

`join` 범위 변수 형식을 명시적으로 지정 하는 절
```
join T x in e on k1 equals k2
```
로 변환 됩니다.
```
join x in ( e ) . Cast < T > ( ) on k1 equals k2
```

다음 섹션에서 번역은 쿼리 명시적 범위 변수 형식이 있다고 가정 합니다.

이 예제에서
```csharp
from Customer c in customers
where c.City == "London"
select c
```
로 변환 됩니다.
```csharp
from c in customers.Cast<Customer>()
where c.City == "London"
select c
```
최종 번역이
```csharp
customers.
Cast<Customer>().
Where(c => c.City == "London")
```

제네릭이 아닌 구현 하는 컬렉션을 쿼리 하는 데에 명시적 범위 변수의 유형을 `IEnumerable` 제네릭 하지 않고 인터페이스만 `IEnumerable<T>` 인터페이스입니다. 위의 예에서 경우 것 `customers` 형식 이었습니다 `ArrayList`합니다.

#### <a name="degenerate-query-expressions"></a>디 제너 레이트 쿼리 식

폼의 쿼리 식
```csharp
from x in e select x
```
로 변환 됩니다.
```csharp
( e ) . Select ( x => x )
```

이 예제에서
```csharp
from c in customers
select c
```
로 변환 됩니다.
```csharp
customers.Select(c => c)
```

디 제너 레이트 쿼리 식은 일반적으로 소스 요소를 선택 하는 경우 번역의 이후 단계를 해당 원본과를 대체 하 여 다른 변환 단계에서 중복 제거 쿼리에 제거 합니다. 하지만 것이 중요 쿼리의 결과 되도록 식 되지 소스 개체 자체는 그림 형식 및 id 원본에 쿼리 클라이언트에 따라 합니다. 이 단계에서 명시적으로 호출 하 여 소스 코드에서 직접 작성 하는 중복 제거 쿼리를 보호 하는 따라서 `Select` 원본입니다. 구현자 그러면 `Select` 및 이러한 메서드는 원본 개체 자체를 반환 하지 않도록 하기 위해 다른 쿼리 연산자입니다.

#### <a name="from-let-where-join-and-orderby-clauses"></a>, let, where,: 조인 및 orderby 절

두 번째 쿼리 식을 `from` 뒤에 절을 `select` 절
```csharp
from x1 in e1
from x2 in e2
select v
```
로 변환 됩니다.
```csharp
( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => v )
```

두 번째 쿼리 식을 `from` 절 뒤에 것 이외의 `select` 절:

```csharp
from x1 in e1
from x2 in e2
...
```
로 변환 됩니다.
```csharp
from * in ( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => new { x1 , x2 } )
...
```

쿼리 식에는 `let` 절
```csharp
from x in e
let y = f
...
```
로 변환 됩니다.
```csharp
from * in ( e ) . Select ( x => new { x , y = f } )
...
```

쿼리 식에는 `where` 절
```csharp
from x in e
where f
...
```
로 변환 됩니다.
```csharp
from x in ( e ) . Where ( x => f )
...
```

쿼리 식에는 `join` 없이 절을 `into` 뒤에 `select` 절
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
```
로 변환 됩니다.
```csharp
( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => v )
```

쿼리 식에는 `join` 절 없이 `into` 것 이외의 뒤를 `select` 절
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
```
로 변환 됩니다.
```csharp
from * in ( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => new { x1 , x2 })
...
```

쿼리 식에는 `join` 절을 `into` 뒤에 `select` 절
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
```
로 변환 됩니다.
```csharp
( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => v )
```

쿼리 식에는 `join` 절을 `into` 것 이외의 뒤를 `select` 절
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
```
로 변환 됩니다.
```csharp
from * in ( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => new { x1 , g })
...
```

쿼리 식에는 `orderby` 절
```csharp
from x in e
orderby k1 , k2 , ..., kn
...
```
로 변환 됩니다.
```csharp
from x in ( e ) . 
OrderBy ( x => k1 ) . 
ThenBy ( x => k2 ) .
... .
ThenBy ( x => kn )
...
```

절 지정 하는 경우 순서는 `descending` 방향 표시기, 호출 `OrderByDescending` 또는 `ThenByDescending` 대신 생성 됩니다.

번역 있는지 가정 없음 `let`, `where`, `join` 또는 `orderby` 절 및는 하나의 초기 `from` 각 쿼리 식 절.

이 예제에서
```csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
```
로 변환 됩니다.
```csharp
customers.
SelectMany(c => c.Orders,
     (c,o) => new { c.Name, o.OrderID, o.Total }
)
```

이 예제에서
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
로 변환 됩니다.
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
최종 번역이
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.OrderID, x.o.Total })
```
여기서 `x` 즉 액세스할 수 없는 컴파일러에서 생성 된 식별자입니다.

이 예제에서
```csharp
from o in orders
let t = o.Details.Sum(d => d.UnitPrice * d.Quantity)
where t >= 1000
select new { o.OrderID, Total = t }
```
로 변환 됩니다.
```csharp
from * in orders.
    Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) })
where t >= 1000 
select new { o.OrderID, Total = t }
```
최종 번역이
```csharp
orders.
Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }).
Where(x => x.t >= 1000).
Select(x => new { x.o.OrderID, Total = x.t })
```
여기서 `x` 즉 액세스할 수 없는 컴파일러에서 생성 된 식별자입니다.

이 예제에서
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
```
로 변환 됩니다.
```csharp
customers.Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c.Name, o.OrderDate, o.Total })
```

이 예제에서
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n >= 10
select new { c.Name, OrderCount = n }
```
로 변환 됩니다.
```csharp
from * in customers.
    GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
        (c, co) => new { c, co })
let n = co.Count()
where n >= 10 
select new { c.Name, OrderCount = n }
```
최종 번역이
```csharp
customers.
GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
    (c, co) => new { c, co }).
Select(x => new { x, n = x.co.Count() }).
Where(y => y.n >= 10).
Select(y => new { y.x.c.Name, OrderCount = y.n)
```
여기서 `x` 및 `y` 액세스할 수 없는 고 그렇지 않은 컴파일러에서 생성 된 식별자입니다.

이 예제에서
```csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
```
최종 번역에
```csharp
orders.
OrderBy(o => o.Customer.Name).
ThenByDescending(o => o.Total)
```

#### <a name="select-clauses"></a>Select 절

폼의 쿼리 식
```csharp
from x in e select v
```
로 변환 됩니다.
```csharp
( e ) . Select ( x => v )
```
v 식별자 인 경우 제외 x 번역은 단순히
```csharp
( e )
```

예
```csharp
from c in customers.Where(c => c.City == "London")
select c
```
단순히 변환
```csharp
customers.Where(c => c.City == "London")
```

#### <a name="groupby-clauses"></a>Groupby 절

폼의 쿼리 식
```csharp
from x in e group v by k
```
로 변환 됩니다.
```csharp
( e ) . GroupBy ( x => k , x => v )
```
v 식별자 인 경우 제외 x 번역이
```csharp
( e ) . GroupBy ( x => k )
```

이 예제에서
```csharp
from c in customers
group c.Name by c.Country
```
로 변환 됩니다.
```csharp
customers.
GroupBy(c => c.Country, c => c.Name)
```

#### <a name="transparent-identifiers"></a>투명 식별자

특정 번역 삽입할 범위 변수와 ***투명 식별자*** 가리키는 `*`합니다. 투명 식별자는 적절 한 언어 기능이; 하지 않습니다. 쿼리 식 변환 프로세스에서 중간 단계로 존재합니다.

쿼리 변환 투명 식별자를 삽입 하는 경우 변환 단계 투명 식별자 익명 함수 및 익명 개체 이니셜라이저에 전파 추가. 이러한 컨텍스트 투명 식별자에는 다음 동작:

*  익명 함수에 매개 변수로 식별자를 투명 하 게 발생 하면 연결 된 익명 형식의 멤버는 자동으로 범위 내에서에 익명 함수의 본문입니다.
*  투명 식별자 멤버가 범위의 경우 해당 멤버의 멤버는 범위의 도입니다.
*  투명 식별자는 익명 개체 이니셜라이저에서 멤버 선언으로 발생 하면 투명 식별자 멤버가 소개 합니다.
*  위에서 설명한 변환 단계에서는 투명 한 식별자는 항상 단일 개체의 구성원으로 여러 개의 범위 변수를 캡처의 의도 사용 하 여 익명 형식과 함께 도입 됩니다. 익명 형식 보다 다른 메커니즘을 여러 개의 범위 변수를 함께 그룹화 하는 데 C#의 구현을 허용 됩니다. 다음 변환 예제에서는 무명 형식을 사용 하 고 투명도 식별자 표시 가정 바로 변환 될 수 있습니다.

이 예제에서
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
```
로 변환 됩니다.
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
```

변환 추가
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(* => o.Total).
Select(* => new { c.Name, o.Total })
```
투명 식별자 지워진 경우와 동일
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.Total })
```
여기서 `x` 즉 액세스할 수 없는 컴파일러에서 생성 된 식별자입니다.

이 예제에서
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
로 변환 됩니다.
```csharp
from * in customers.
    Join(orders, c => c.CustomerID, o => o.CustomerID, 
        (c, o) => new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
축소는 추가
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID, (c, o) => new { c, o }).
Join(details, * => o.OrderID, d => d.OrderID, (*, d) => new { *, d }).
Join(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }).
Select(* => new { c.Name, o.OrderDate, p.ProductName })
```
최종 번역이
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c, o }).
Join(details, x => x.o.OrderID, d => d.OrderID,
    (x, d) => new { x, d }).
Join(products, y => y.d.ProductID, p => p.ProductID,
    (y, p) => new { y, p }).
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
```
여기서 `x`, `y`, 및 `z` 액세스할 수 없는 고 그렇지 않은 컴파일러에서 생성 된 식별자입니다.

### <a name="the-query-expression-pattern"></a>쿼리 식 패턴

합니다 ***쿼리 식 패턴*** 패턴 형식 쿼리 식을 지원 하기 위해 구현할 수 있는 메서드를 설정 합니다. 쿼리 식 구문 매핑을 통해 메서드 호출으로 변환 됩니다, 때문에 형식 쿼리 식 패턴을 구현 하는 방법에 유연성을 있습니다. 예를 들어 패턴의 메서드를 구현할 수 있습니다 인스턴스 메서드 또는 확장 메서드로 둘 다 동일한 호출 구문을 이므로 익명 함수 둘 다으로 변환할 수 없으므로 메서드를 대리자 또는 식 트리를 요청할 수 있습니다.

제네릭 형식의 권장 되는 모양을 `C<T>` 는 지원의 쿼리 식 패턴은 다음과 같습니다. 제네릭 형식 매개 변수 및 결과 형식 간의 적절 한 관계를 보여 주기 위해는 하지만 제네릭이 아닌 형식에 대 한 패턴을 구현 하는 것이 가능 합니다.

```csharp
delegate R Func<T1,R>(T1 arg1);

delegate R Func<T1,T2,R>(T1 arg1, T2 arg2);

class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector,
        Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector,
        Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

위의 메서드는 제네릭 대리자 형식을 사용 `Func<T1,R>` 및 `Func<T1,T2,R>`, 이러한 수 원활 하 게 형식을 사용 하는 다른 대리자 또는 식 트리에서 매개 변수 및 결과 형식에서 동일한 관계 있지만.

권장 되는 관계를 확인할 수 있습니다 `C<T>` 및 `O<T>` 되도록 하는 합니다 `ThenBy` 및 `ThenByDescending` 메서드를 결과에 대해서만 사용할 수는 `OrderBy` 또는 `OrderByDescending`합니다. 또한 결과의 권장 되는 모양을 확인할 수 있습니다 `GroupBy` -시퀀스의 시퀀스를 각 내부 시퀀스에 추가 `Key` 속성입니다.

합니다 `System.Linq` 네임 스페이스를 구현 하는 모든 형식에 대 한 쿼리 연산자 패턴의 구현을 제공 합니다 `System.Collections.Generic.IEnumerable<T>` 인터페이스입니다.

## <a name="assignment-operators"></a>대입 연산자

대입 연산자는 변수, 속성, 이벤트 또는 인덱서 요소를 새 값을 할당합니다.

```antlr
assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | right_shift_assignment
    ;
```

할당의 왼쪽된 피연산자는 변수, 속성 액세스, 인덱서 액세스, 또는 이벤트 액세스로 분류 되는 식 이어야 합니다.

합니다 `=` 연산자를 호출 합니다 ***단순 할당 연산자***합니다. 오른쪽 피연산자의 값은 왼쪽된 피연산자가 지정 된 변수, 속성 또는 인덱서 요소에 할당 합니다. 단순 할당 연산자의 왼쪽된 피연산자 이벤트 액세스 되지 않을 수 있습니다 (에 설명 된 대로 except [필드와 유사한 이벤트](classes.md#field-like-events)). 단순 할당 연산자에서 설명한 [단순 할당](expressions.md#simple-assignment)합니다.

이외의 할당 연산자는 `=` 연산자 라고 합니다 ***복합 할당 연산자***합니다. 이러한 연산자는 두 피연산자에 지정 된 작업을 수행 하 고 왼쪽 피연산자로 지정 된 변수, 속성 또는 인덱서 요소 결과 값을 할당 합니다. 복합 할당 연산자에 나와 [복합 할당](expressions.md#compound-assignment)합니다.

합니다 `+=` 및 `-=` 왼쪽 피연산자로 이벤트 액세스 식 사용 하 여 연산자 라고 합니다 *이벤트 대입 연산자*합니다. 왼쪽된 피연산자와 기타 할당 연산자는 이벤트 액세스를 사용 하 여 유효합니다. 이벤트 대입 연산자에 나와 [이벤트 할당](expressions.md#event-assignment)합니다.

대입 연산자는 오른쪽 결합성 작업은 오른쪽에서 왼쪽으로 그룹화 되어 있음을 의미 합니다. 예를 들어, 폼의 식을 `a = b = c` 로 평가 됩니다 `a = (b = c)`합니다.

### <a name="simple-assignment"></a>단순 할당

`=` 연산자는 단순 할당 연산자 라고 합니다.

단순 할당의 왼쪽된 피연산자 형식 인지 `E.P` 또는 `E[Ei]` 여기서 `E` 컴파일 시간 형식이 `dynamic`, 바인딩된 동적으로 할당 한 다음 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 타임 대입 식의 형식이 `dynamic`, 아래에 설명 된 해결의 런타임 형식을 기반으로 런타임 시 수행 됩니다 및 `E`합니다.

단순 할당에서 오른쪽 피연산자의 왼쪽된 피연산자의 형식으로 암시적으로 변환할 수 있는 식 이어야 합니다. 작업은 왼쪽된 피연산자가 지정 된 변수, 속성 또는 인덱서 요소에 오른쪽 피연산자의 값을 할당 합니다.

단순 할당 식의 결과 왼쪽된 피연산자에 할당 된 값입니다. 결과 왼쪽된 피연산자와 동일한 형식 및는 항상 값으로 분류 됩니다.

속성 또는 인덱서 있어야 왼쪽된 피연산자 인 속성 또는 인덱서 액세스를 사용 하는 경우는 `set` 접근자입니다. 이 경우 바인딩 시간 오류가 발생 합니다.

폼의 단순한 할당을 처리 하는 런타임 `x = y` 다음 단계로 구성 됩니다.

*  경우 `x` 변수로로 분류 됩니다.
   * `x` 변수를 생성 하기 위해 평가 됩니다.
   * `y` 평가 되 고, 필요한 경우의 형식으로 변환할 `x` 는 암시적 변환을 통해 ([암시적 변환을](conversions.md#implicit-conversions)).
   * 경우 제공한 변수의 `x` 의 배열 요소를 *reference_type*에 대 한 계산한 값을 확인 하는 런타임 검사가 수행 됩니다 `y` 있는 배열 인스턴스의와 호환 되 `x` 는 요소입니다. 검사가 성공 `y` 됩니다 `null`, 경우 암시적 참조 변환 또는 ([암시적 참조 변환](conversions.md#implicit-reference-conversions))에서 참조 하는 인스턴스의 실제 형식이 존재 `y` 실제 요소 형식으로 포함 하는 배열 인스턴스 `x`합니다. 그렇지 않으면 `System.ArrayTypeMismatchException`이 throw됩니다.
   * 계산 하 고 변환의 결과 값 `y` 계산 하 여 지정 된 위치에 저장 됩니다 `x`합니다.
*  경우 `x` 속성 또는 인덱서에 액세스로 분류 됩니다.
   * 인스턴스 식 (경우 `x` 아닙니다 `static`) 및 인수 목록을 (경우 `x` 인덱서 액세스할)와 연결 된 `x` 평가 결과에서 사용 하는 후속 `set` 접근자 호출 합니다.
   * `y` 평가 되 고, 필요한 경우의 형식으로 변환할 `x` 는 암시적 변환을 통해 ([암시적 변환을](conversions.md#implicit-conversions)).
   * 합니다 `set` 의 접근자 `x` 에 대 한 계산 된 값을 사용 하 여 호출 `y` 으로 해당 `value` 인수입니다.

배열 공동 분산 규칙 ([배열 공변성 (covariance)](arrays.md#array-covariance)) 배열 형식의 값을 허용 `A[]` 배열 형식의 인스턴스에 대 한 참조가 되도록 `B[]`암시적 참조 변환이 존재에서 제공 하는, `B` 를 `A`. 이러한 규칙의 배열 요소에 대 한 할당으로 인해를 *reference_type* 할당 되는 값 배열 인스턴스와 호환 되는지 확인 하는 런타임 검사가 필요 합니다. 예제
```csharp
string[] sa = new string[10];
object[] oa = sa;

oa[0] = null;               // Ok
oa[1] = "Hello";            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
```
마지막으로 할당 하면를 `System.ArrayTypeMismatchException` 때문 인스턴스의 `ArrayList` 의 요소에 저장할 수는 `string[]`합니다.

속성 또는 인덱서를 선언 하는 경우는 *struct_type* 인스턴스 식이 할당 대상 연관 된 속성 또는 인덱서 액세스 변수로 분류 되어야 합니다. 인스턴스 식은 값으로 분류 되는 바인딩 시간 오류가 발생 합니다. 때문에 [멤버 액세스](expressions.md#member-access), 동일한 규칙을 필드에도 적용 됩니다.

다음과 같은 선언이 있습니다.
```csharp
struct Point
{
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int X {
        get { return x; }
        set { x = value; }
    }

    public int Y {
        get { return y; }
        set { y = value; }
    }
}

struct Rectangle
{
    Point a, b;

    public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public Point A {
        get { return a; }
        set { a = value; }
    }

    public Point B {
        get { return b; }
        set { b = value; }
    }
}
```
예제
```csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
```
에 할당 `p.X`, `p.Y`, `r.A`, 및 `r.B` 때문에 허용 됩니다 `p` 및 `r` 변수가 있습니다. 그러나 예제의
```csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
```
할당은 유효 하지 않거나 모든 이후 `r.A` 고 `r.B` 변수가 아닌 합니다.

### <a name="compound-assignment"></a>복합 할당

복합 대입의 왼쪽된 피연산자가 폼의 경우 `E.P` 또는 `E[Ei]` 여기서 `E` 컴파일 시간 형식이 `dynamic`, 바인딩된 동적으로 할당 한 다음 ([동적 바인딩](expressions.md#dynamic-binding)). 이 경우 컴파일 타임 대입 식의 형식이 `dynamic`, 아래에 설명 된 해결의 런타임 형식을 기반으로 런타임 시 수행 됩니다 및 `E`합니다.

폼의 작업 `x op= y` 이항 연산자 오버 로드 확인을 적용 하 여 처리 됩니다 ([이항 연산자 오버 로드 확인](expressions.md#binary-operator-overload-resolution)) 작업 작성 된 것 처럼 `x op y`합니다. 그런 다음

*  선택한 연산자의 반환 형식을 형식으로 암시적으로 변환할 수 있으면 `x`를 작업으로 계산 됩니다 `x = x op y`점을 제외 하 고 `x` 한 번만 평가 됩니다.
*  그렇지 않으면 선택한 연산자는 선택한 연산자의 반환 형식으로의 형식으로 명시적으로 변환할 경우 미리 정의 된 연산자 `x`, 경우에 `y` 의 형식으로 암시적으로 변환할 수 `x` 또는 운영자가을 시프트 연산자, 작업으로 평가 됩니다 `x = (T)(x op y)`, 여기서 `T` 유형의 `x`점을 제외 하 고 `x` 한 번만 평가 됩니다.
*  이 고, 그렇지 복합 할당 유효 하지 않은 및 바인딩 시간에 발생 합니다.

"한 번만 계산" 이라는 용어는의 평가에 의미 `x op y`, 구성 식의 결과 `x` 일시적으로 저장 되 고 할당을 수행할 때 다시 `x`입니다. 할당의 예를 들어 `A()[B()] += C()`여기서 `A` 반환 하는 `int[]`, 및 `B` 하 고 `C` 반환 하는 메서드는 `int`, 메서드는 순서 대로 한 번만 호출 됩니다 `A`, `B`, `C`.

복합 대입의 왼쪽된 피연산자는 속성 액세스 또는 인덱서 액세스 경우 속성 또는 인덱서를 모두가지고 있어야를 `get` 접근자 및 `set` 접근자입니다. 이 경우 바인딩 시간 오류가 발생 합니다.

허용 위의 두 번째 규칙 `x op= y` 로 평가 되도록 하려는 `x = (T)(x op y)` 특정 컨텍스트에서 합니다. 규칙이 존재 하는 형식의 왼쪽된 피연산자가 복합 연산자는 미리 정의 된 연산자를 사용할 수 있습니다 `sbyte`, `byte`를 `short`합니다 `ushort`, 또는 `char`합니다. 미리 정의 된 연산자를 생성도 경우 두 인수가 모두 이러한 형식 중 하나를 결과 유형이 `int`에 설명 된 대로 [이진 숫자 프로 모션](expressions.md#binary-numeric-promotions)합니다. 따라서 캐스팅 하지 않고는 결과 왼쪽된 피연산자에 할당 하려면 불가능 수도 있습니다.

미리 정의 된 연산자에 대 한 규칙의 직관적인 효과 단순히 `x op= y` 모두 허용 됩니다의 `x op y` 고 `x = y` 허용 됩니다. 예제
```csharp
byte b = 0;
char ch = '\0';
int i = 0;

b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok

ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
```
직관적인 각 오류 원인은 해당 단순 할당은 또한 셨 기를 오류가 발생 합니다.

즉, 작업은 지원 되는 복합 할당 작업 리프트는 합니다. 예제
```csharp
int? i = 0;
i += 1;             // Ok
```
리프트 된 연산자 `+(int?,int?)` 사용 됩니다.

### <a name="event-assignment"></a>이벤트 할당

하는 경우의 왼쪽된 피연산자는 `+=` 또는 `-=` 연산자는 이벤트 액세스로 분류 됩니다 다음 식은 다음과 같이 계산 됩니다.

*  인스턴스 식이 있는 경우 이벤트 액세스 평가 됩니다.
*  오른쪽 피연산자는 `+=` 또는 `-=` 연산자 계산을 변환 하는 암시적 변환을 통해 왼쪽된 피연산자의 형식으로 변환 하는 필요한 경우 ([암시적 변환을](conversions.md#implicit-conversions)).
*  오른쪽 피연산자 평가 후 구성 된 인수 목록을 사용 하 여 이벤트의 이벤트 접근자가 호출 하 고, 필요한 경우 변환 합니다. 연산자 되었으면 `+=`, `add` 접근자가 호출 됩니다; 연산자 되었으면 `-=`, `remove` 접근자가 호출 됩니다.

이벤트 대입 식에서 값을 생성 하지 않습니다. 따라서 이벤트 대입 식 에서만 유효의 컨텍스트를 *statement_expression* ([식 문은](statements.md#expression-statements)).

## <a name="expression"></a>식

*식* 이 *non_assignment_expression* 요소나 *할당*.

```antlr
expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
```

## <a name="constant-expressions"></a>상수 식

A *constant_expression* 컴파일 시간에 완전히 계산 될 수 있는 식입니다.

```antlr
constant_expression
    : expression
    ;
```

상수 식 이어야 합니다는 `null` 리터럴 또는 다음 형식 중 하나를 사용 하 여 값: `sbyte`, `byte`, `short`, `ushort`를 `int`, `uint`를 `long`를 `ulong`, `char` `float`, `double`, `decimal`, `bool`를 `object`, `string`, 또는 열거형 형식입니다. 상수 식에서는 다음과 같은 구문이 허용 됩니다.

*  리터럴 (포함 된 `null` 리터럴)입니다.
*  에 대 한 참조 `const` 클래스 및 구조체 형식의 멤버입니다.
*  열거형 형식의 멤버에 대 한 참조입니다.
*  에 대 한 참조 `const` 매개 변수 또는 지역 변수
*  괄호로 묶은 하위 식에서은 그 자체가 상수 식입니다.
*  대상 유형이 제공 되는 캐스트 식 위에 나열 된 형식 중 하나입니다.
*  `checked` 및 `unchecked` 식
*  기본 값 식
*  Nameof 식
*  미리 정의 된 `+`, `-`를 `!`, 및 `~` 단항 연산자입니다.
*  미리 정의 된 `+`, `-`, `*`, `/`, `%`를 `<<`, `>>`를 `&`, `|`를 `^`, `&&`, `||`, `==`, `!=`, `<`를 `>`, `<=`, 및 `>=` 각 피연산자가 위에 나열 된 형식의 이진 연산자를 제공 합니다.
*  `?:` 조건부 연산자입니다.

상수 식에는 다음과 같은 변환이 허용 됩니다.

*  Identity 변환
*  숫자 변환
*  열거형 변환
*  상수 식 변환
*  암시적 및 명시적 참조 변환, 상수 식에서 null 값으로 계산 되는 변환의 소스를 제공 합니다.

Boxing을 비롯 한 다른 변환 상수 식에서 null이 아닌 값의 unboxing 변환과 암시적 참조 변환이 허용 되지 않습니다. 예를 들어:
```csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = "hello"; // error: implicit reference conversion
}
```
초기화 하는 boxing 변환이 필요 하기 때문에 i는 오류가 발생 합니다. Str의 초기화는 null이 아닌 값에서 암시적 참조 변환이 필요 하기 때문에 오류입니다.

위에 나열 된 요구 사항을 충족 하는 식, 때마다 식은 컴파일 시간에 평가 됩니다. 식은 하위 식 상수가 아닌 생성자가 포함 된 더 큰 식의 경우에 마찬가지입니다.

컴파일 타임 오류가 발생 하면 여기서 런타임 계산이 throw 된 예외를 컴파일 시간 계산이 한다는 상수가 아닌 식은 런타임에 평가와 동일한 규칙을 사용 하는 컴파일 시간 상수 식 평가 합니다.

상수 식에 명시적으로 배치 됩니다 하지 않는 한는 `unchecked` 컨텍스트, 정수 형식 산술 연산 및 변환에서 항상 식의 컴파일 타임 확인 하는 동안 발생 하는 오버플로 컴파일 타임 오류를 일으킬 ([상수 식](expressions.md#constant-expressions)).

상수 식은 아래에 나열 된 컨텍스트에서 발생 합니다. 이러한 컨텍스트에서 식을 컴파일할 때 완벽 하 게 평가할 수 없습니다는 컴파일 타임 오류가 발생 합니다.

*  상수 선언 ([상수](classes.md#constants)).
*  열거형 멤버 선언 ([열거형 멤버](enums.md#enum-members)).
*  기본 인수를 형식 매개 변수 목록 ([메서드 매개 변수](classes.md#method-parameters))
*  `case` 레이블에 `switch` 문 ([switch 문](statements.md#the-switch-statement)).
*  `goto case` 문 ([goto 문을](statements.md#the-goto-statement)).
*  차원 배열 생성 식의 길이 ([배열 만들기 식](expressions.md#array-creation-expressions)) 이니셜라이저를 포함 합니다.
*  특성 ([특성](attributes.md)).

변환 하는 상수 식 암시적 변환을 ([암시적 상수 식 변환](conversions.md#implicit-constant-expression-conversions)) 형식의 상수 식을 허용 `int` 변환할 `sbyte`를 `byte`, `short`를 `ushort`, `uint`, 또는 `ulong`, 상수 식의 값이 대상 형식의 범위 내에 제공 합니다.

## <a name="boolean-expressions"></a>부울 식

A *boolean_expression* 형식의 결과 생성 하는 식 `bool`; 하거나 직접 또는 응용 프로그램을 통해 `operator true` 다음에 지정 된 대로 특정 컨텍스트에서 합니다.

```antlr
boolean_expression
    : expression
    ;
```

조건식의 제어를 *if_statement* ([if 문을](statements.md#the-if-statement)), *while_statement* ([는 while 문](statements.md#the-while-statement)), *do_statement* ([do 문에](statements.md#the-do-statement)), 또는 *for_statement* ([는 문에 대 한](statements.md#the-for-statement)) 되는 *boolean_ 식*합니다. 조건식의 제어를 `?:` 연산자 ([조건부 연산자](expressions.md#conditional-operator))와 동일한 규칙을 따릅니다를 *boolean_expression*, 우선 순위 연산자의 이유로 분류 되지만 로 *conditional_or_expression*합니다.

A *boolean_expression* `E` 형식의 값을 생성할 수 하는 데 필요한 `bool`, 다음과 같습니다.

*  하는 경우 `E` 암시적으로 변환할 수 `bool` 런타임에 암시적 변환이 적용 됩니다.
*  단항 연산자 오버 로드 확인이 고, 그렇지 ([단항 연산자 오버 로드 확인](expressions.md#unary-operator-overload-resolution)) 연산자의 고유한 모범 구현을 찾는 데 사용 됩니다 `true` 에서 `E`, 구현에는 런타임에 적용 됩니다.
*  이러한 연산자가 있으면 바인딩 시간 오류를 발생 합니다.

`DBBool` 에서 구조체 형식 [데이터베이스 부울 유형](structs.md#database-boolean-type) 구현 하는 형식의 예가 나와 `operator true` 및 `operator false`합니다.
